;; TON Destination Escrow HTLC Contract for 1inch Fusion+
;; This contract locks assets on the destination chain for maker withdrawal

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/jetton-utils.fc";

;; Operation codes
const int OP_CREATE_ESCROW = 0x1;
const int OP_WITHDRAW = 0x2;
const int OP_REFUND = 0x3;
const int OP_LOCK_ESCROW = 0x4;
const int OP_JETTON_TRANSFER = 0x178d4519;
const int OP_JETTON_NOTIFICATION = 0x7362d09c;

;; Escrow statuses
const int STATUS_CREATED = 1;
const int STATUS_LOCKED = 2;
const int STATUS_WITHDRAWN = 3;
const int STATUS_REFUNDED = 4;
const int STATUS_EXPIRED = 5;

;; Error codes are defined in imports/constants.fc

;; Storage layout for destination escrow
;; escrow_id (uint256)
;; resolver_address (MsgAddress) - who deposits assets
;; maker_address (MsgAddress) - who can withdraw with secret
;; refund_address (MsgAddress) - where to refund resolver
;; asset_type (uint8) - 0 for TON, 1 for Jetton
;; jetton_master (MsgAddress) - only if asset_type = 1
;; amount (Coins)
;; safety_deposit (Coins)
;; secret_hash (uint256)
;; timelock_duration (uint32) - shorter than source chain
;; finality_timelock (uint32)
;; created_at (uint32)
;; status (uint8)
;; merkle_root (uint256) - for partial fills
;; fill_percentage (uint32)
;; exclusive_period (uint32) - resolver exclusive withdrawal period

(slice, slice, slice, slice, int, slice, int, int, int, int, int, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),      ;; escrow_id
        ds~load_msg_addr(),      ;; resolver_address
        ds~load_msg_addr(),      ;; maker_address
        ds~load_msg_addr(),      ;; refund_address
        ds~load_uint(8),         ;; asset_type
        ds~load_msg_addr(),      ;; jetton_master
        ds~load_coins(),         ;; amount
        ds~load_coins(),         ;; safety_deposit
        ds~load_uint(256),       ;; secret_hash
        ds~load_uint(32),        ;; timelock_duration
        ds~load_uint(32),        ;; finality_timelock
        ds~load_uint(32),        ;; created_at
        ds~load_uint(8),         ;; status
        ds~load_uint(256),       ;; merkle_root
        ds~load_uint(32),        ;; fill_percentage
        ds~load_uint(32)         ;; exclusive_period
    );
}

() save_data(slice escrow_id, slice resolver_address, slice maker_address, slice refund_address,
             int asset_type, slice jetton_master, int amount, int safety_deposit,
             int secret_hash, int timelock_duration, int finality_timelock, int created_at,
             int status, int merkle_root, int fill_percentage, int exclusive_period) impure inline {
    set_data(begin_cell()
        .store_slice(escrow_id)
        .store_slice(resolver_address)
        .store_slice(maker_address)
        .store_slice(refund_address)
        .store_uint(asset_type, 8)
        .store_slice(jetton_master)
        .store_coins(amount)
        .store_coins(safety_deposit)
        .store_uint(secret_hash, 256)
        .store_uint(timelock_duration, 32)
        .store_uint(finality_timelock, 32)
        .store_uint(created_at, 32)
        .store_uint(status, 8)
        .store_uint(merkle_root, 256)
        .store_uint(fill_percentage, 32)
        .store_uint(exclusive_period, 32)
        .end_cell());
}

;; Verify secret against hash (supports partial fills with Merkle proofs)
int verify_secret(int secret_hash, slice secret, slice merkle_proof, int fill_amount) inline {
    ;; For full fills, verify direct hash
    if (merkle_proof.slice_empty?()) {
        int computed_hash = string_hash(secret);
        return computed_hash == secret_hash;
    }
    
    ;; For partial fills, verify Merkle proof
    int leaf_hash = string_hash(secret);
    slice proof = merkle_proof;
    int current_hash = leaf_hash;
    
    while (~ proof.slice_empty?()) {
        int sibling = proof~load_uint(256);
        int is_right = proof~load_uint(1);
        
        if (is_right) {
            current_hash = string_hash(begin_cell()
                .store_uint(sibling, 256)
                .store_uint(current_hash, 256)
                .end_cell().begin_parse());
        } else {
            current_hash = string_hash(begin_cell()
                .store_uint(current_hash, 256)
                .store_uint(sibling, 256)
                .end_cell().begin_parse());
        }
    }
    
    return current_hash == secret_hash;
}

;; Create destination escrow (called by resolver with assets)
() create_escrow(int balance, slice sender_address, slice resolver_address, slice maker_address,
                slice refund_address, int asset_type, slice jetton_master,
                int amount, int safety_deposit, int secret_hash, int timelock_duration,
                int finality_timelock, int merkle_root, int exclusive_period) impure {
    
    throw_unless(ERROR_INSUFFICIENT_BALANCE, balance >= amount + safety_deposit);
    
    int now_time = now();
    slice escrow_id = begin_cell()
        .store_uint(now_time, 32)
        .store_slice(maker_address)
        .store_uint(secret_hash, 256)
        .end_cell().begin_parse();
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, now_time, STATUS_CREATED,
              merkle_root, 0, exclusive_period);
    

}

;; Lock escrow after finality period (called by resolver)
() lock_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(101, status == STATUS_CREATED);
    throw_unless(102, now() >= created_at + finality_timelock);
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_LOCKED,
              merkle_root, fill_percentage, exclusive_period);
              

}

;; Withdraw with secret (callable by resolver during exclusive period, then by maker)
() withdraw_with_secret(slice sender_address, slice secret, slice merkle_proof, int withdraw_amount) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    throw_unless(103, status == STATUS_LOCKED);
    throw_unless(ERROR_INVALID_SECRET, verify_secret(secret_hash, secret, merkle_proof, withdraw_amount));
    
    int new_fill_percentage = fill_percentage + withdraw_amount;
    throw_unless(104, new_fill_percentage <= amount);
    
    int now_time = now();
    int locked_at = created_at + finality_timelock;
    int exclusive_end = locked_at + exclusive_period;
    
    ;; During exclusive period, only resolver can withdraw
    if (now_time < exclusive_end) {
        throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
        
        ;; Resolver withdraws to maker's address and gets safety deposit
        if (asset_type == 0) {
            ;; TON transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(maker_address)
                .store_coins(withdraw_amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(withdraw_amount)
                .store_slice(maker_address)
                .store_slice(maker_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
        
        ;; Transfer safety deposit to resolver
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(resolver_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
            
    } else {
        ;; After exclusive period, anyone with secret can withdraw to maker
        throw_unless(ERROR_INVALID_MAKER, 
            equal_slices(sender_address, maker_address) | 
            equal_slices(sender_address, resolver_address));
        
        if (asset_type == 0) {
            ;; TON transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(maker_address)
                .store_coins(withdraw_amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(withdraw_amount)
                .store_slice(maker_address)
                .store_slice(maker_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
        
        ;; Safety deposit goes to whoever executed the withdrawal
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(sender_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    ;; Update status
    int new_status = (new_fill_percentage == amount) ? STATUS_WITHDRAWN : STATUS_LOCKED;
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, new_status,
              merkle_root, new_fill_percentage, exclusive_period);
    

}

;; Refund to resolver after timeout (shorter timeout than source chain)
() refund_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    throw_unless(105, equal_slices(sender_address, resolver_address));
    throw_unless(106, (status == STATUS_LOCKED) | (status == STATUS_CREATED));
    throw_unless(ERROR_TIMEOUT_NOT_REACHED, now() >= created_at + timelock_duration);
    
    int remaining_amount = amount - fill_percentage;
    
    ;; Refund remaining assets to resolver
    if (remaining_amount > 0) {
        if (asset_type == 0) {
            ;; TON refund
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(refund_address)
                .store_coins(remaining_amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton refund
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(remaining_amount)
                .store_slice(refund_address)
                .store_slice(refund_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
    }
    
    ;; Refund safety deposit to resolver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(resolver_address)
        .store_coins(safety_deposit)
        .store_uint(0, 107)
        .end_cell(), 1);
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED,
              merkle_root, fill_percentage, exclusive_period);
    

}

;; Emergency cancellation by resolver (before locking)
() cancel_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(107, status == STATUS_CREATED);
    
    ;; Refund all assets to resolver immediately
    if (asset_type == 0) {
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(amount + safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Return jettons and TON safety deposit separately
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000)
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64)
            .store_coins(amount)
            .store_slice(refund_address)
            .store_slice(refund_address)
            .store_uint(0, 1)
            .store_coins(50000000)
            .store_uint(0, 1)
            .end_cell(), 1);
            
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED,
              merkle_root, fill_percentage, exclusive_period);
              

}

;; Get escrow details (for 1inch SDK queries)
(int, slice, slice, slice, int, int, int, int, int, int, int, int) get_escrow_details() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    return (status, resolver_address, maker_address, refund_address,
            asset_type, amount, safety_deposit, timelock_duration, created_at,
            fill_percentage, (amount - fill_percentage), exclusive_period);
}

;; Check if escrow can be withdrawn
int can_withdraw(slice secret, slice merkle_proof, int withdraw_amount) method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    if (fill_percentage + withdraw_amount > amount) { return 0; }
    if (~ verify_secret(secret_hash, secret, merkle_proof, withdraw_amount)) { return 0; }
    
    return -1;
}

;; Check if escrow can be refunded
int can_refund() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    if ((status != STATUS_LOCKED) & (status != STATUS_CREATED)) { return 0; }
    if (now() < created_at + timelock_duration) { return 0; }
    
    return -1;
}

;; Check if currently in exclusive period
int in_exclusive_period() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage, exclusive_period) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    
    int now_time = now();
    int locked_at = created_at + finality_timelock;
    int exclusive_end = locked_at + exclusive_period;
    
    return (now_time >= locked_at) & (now_time < exclusive_end);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == OP_CREATE_ESCROW) {
        slice resolver_address = in_msg_body~load_msg_addr();
        slice maker_address = in_msg_body~load_msg_addr();
        slice refund_address = in_msg_body~load_msg_addr();
        int asset_type = in_msg_body~load_uint(8);
        slice jetton_master = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        int safety_deposit = in_msg_body~load_coins();
        int secret_hash = in_msg_body~load_uint(256);
        int timelock_duration = in_msg_body~load_uint(32);
        int finality_timelock = in_msg_body~load_uint(32);
        int merkle_root = in_msg_body~load_uint(256);
        int exclusive_period = in_msg_body~load_uint(32);
        
        create_escrow(my_balance, sender_address, resolver_address, maker_address, refund_address,
                     asset_type, jetton_master, amount, safety_deposit,
                     secret_hash, timelock_duration, finality_timelock, merkle_root, exclusive_period);
        return ();
    }
    
    if (op == OP_LOCK_ESCROW) {
        lock_escrow(sender_address);
        return ();
    }
    
    if (op == OP_WITHDRAW) {
        slice secret = in_msg_body~load_ref().begin_parse();
        slice merkle_proof = in_msg_body~load_ref().begin_parse();
        int withdraw_amount = in_msg_body~load_coins();
        
        withdraw_with_secret(sender_address, secret, merkle_proof, withdraw_amount);
        return ();
    }
    
    if (op == OP_REFUND) {
        refund_escrow(sender_address);
        return ();
    }
    
    if (op == 0x5) { ;; cancel_escrow
        cancel_escrow(sender_address);
        return ();
    }
    
    throw(0xffff);
} 