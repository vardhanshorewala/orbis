"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterTransactions = exports.findTransactionRequired = exports.findTransaction = exports.compareTransactionForTest = exports.compareTransaction = exports.flattenTransaction = void 0;
const core_1 = require("@ton/core");
const node_inspect_extracted_1 = require("node-inspect-extracted");
const pretty_transaction_1 = require("../utils/pretty-transaction");
function extractOp(body) {
    const s = body.beginParse();
    if (s.remainingBits >= 32) {
        return s.loadUint(32);
    }
    else {
        return undefined;
    }
}
function extractEc(cc) {
    const r = [];
    for (const [k, v] of cc.other ?? []) {
        r.push([k, v]);
    }
    r.sort((a, b) => a[0] - b[0]);
    return r;
}
function flattenTransaction(tx) {
    return {
        lt: tx.lt,
        now: tx.now,
        outMessagesCount: tx.outMessagesCount,
        oldStatus: tx.oldStatus,
        endStatus: tx.endStatus,
        totalFees: tx.totalFees.coins,
        mode: tx.mode,
        ...(tx.inMessage
            ? {
                from: tx.inMessage.info.src instanceof core_1.Address ? tx.inMessage.info.src : undefined,
                to: tx.inMessage.info.dest,
                on: tx.inMessage.info.dest,
                value: tx.inMessage.info.type === 'internal' ? tx.inMessage.info.value.coins : undefined,
                ec: tx.inMessage.info.type === 'internal' ? extractEc(tx.inMessage.info.value) : undefined,
                body: tx.inMessage.body,
                inMessageBounced: tx.inMessage.info.type === 'internal' ? tx.inMessage.info.bounced : undefined,
                inMessageBounceable: tx.inMessage.info.type === 'internal' ? tx.inMessage.info.bounce : undefined,
                op: extractOp(tx.inMessage.body),
                initData: tx.inMessage.init?.data ?? undefined,
                initCode: tx.inMessage.init?.code ?? undefined,
                deploy: tx.inMessage.init ? tx.oldStatus !== 'active' && tx.endStatus === 'active' : false,
            }
            : {
                from: undefined,
                to: undefined,
                on: undefined,
                value: undefined,
                ec: undefined,
                body: undefined,
                inMessageBounced: undefined,
                inMessageBounceable: undefined,
                op: undefined,
                initData: undefined,
                initCode: undefined,
                deploy: false,
            }),
        ...(tx.description.type === 'generic' ||
            tx.description.type === 'tick-tock' ||
            tx.description.type === 'split-prepare' ||
            tx.description.type === 'merge-install'
            ? {
                aborted: tx.description.aborted,
                destroyed: tx.description.destroyed,
                exitCode: tx.description.computePhase.type === 'vm' ? tx.description.computePhase.exitCode : undefined,
                actionResultCode: tx.description.actionPhase?.resultCode,
                success: tx.description.computePhase.type === 'vm'
                    ? tx.description.computePhase.success && tx.description.actionPhase?.success
                    : false,
            }
            : {
                aborted: undefined,
                destroyed: undefined,
                exitCode: undefined,
                actionResultCode: undefined,
                success: undefined,
            }),
    };
}
exports.flattenTransaction = flattenTransaction;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function compareValue(a, b) {
    if (a instanceof core_1.Address) {
        if (!(b instanceof core_1.Address))
            return false;
        return a.equals(b);
    }
    if (a instanceof core_1.Cell) {
        if (!(b instanceof core_1.Cell))
            return false;
        return a.equals(b);
    }
    if (a instanceof Array) {
        if (!(b instanceof Array))
            return false;
        if (a.length !== b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            if (!compareValue(a[i], b[i]))
                return false;
        }
        return true;
    }
    return a === b;
}
function compareTransaction(tx, cmp) {
    for (const key in cmp) {
        if (!(key in tx))
            throw new Error(`Unknown flat transaction object key ${key}`);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const cmpv = cmp[key];
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const txv = tx[key];
        if (typeof cmpv === 'function') {
            if (!cmpv(txv))
                return false;
        }
        else {
            if (!compareValue(txv, cmpv))
                return false;
        }
    }
    return true;
}
exports.compareTransaction = compareTransaction;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function compareTransactionForTest(subject, cmp) {
    if (Array.isArray(subject)) {
        return {
            pass: subject.some((tx) => compareTransaction(flattenTransaction(tx), cmp)),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            posMessage: ((subj, cmp) => `Expected ${(0, node_inspect_extracted_1.inspect)(subj.map((tx) => (0, pretty_transaction_1.prettifyTransaction)(tx)))} to contain a transaction that matches pattern ${(0, node_inspect_extracted_1.inspect)(cmp)}`).bind(undefined, subject, cmp),
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            negMessage: ((subj, cmp) => `Expected ${(0, node_inspect_extracted_1.inspect)(subj.map((tx) => (0, pretty_transaction_1.prettifyTransaction)(tx)))} NOT to contain a transaction that matches pattern ${(0, node_inspect_extracted_1.inspect)(cmp)}, but it does`).bind(undefined, subject, cmp),
        };
    }
    else {
        try {
            return {
                pass: compareTransaction(flattenTransaction(subject), cmp),
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                posMessage: ((subj, cmp) => `Expected ${(0, node_inspect_extracted_1.inspect)((0, pretty_transaction_1.prettifyTransaction)(subj))} to match pattern ${(0, node_inspect_extracted_1.inspect)(cmp)}`).bind(undefined, subject, cmp),
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                negMessage: ((subj, cmp) => `Expected ${(0, node_inspect_extracted_1.inspect)((0, pretty_transaction_1.prettifyTransaction)(subj))} NOT to match pattern ${(0, node_inspect_extracted_1.inspect)(cmp)}, but it does`).bind(undefined, subject, cmp),
            };
        }
        catch (e) {
            if (subject.transactions !== undefined) {
                // eslint-disable-next-line no-console
                console.warn('It seems that a SendMessageResult is being used for this comparison. Please make sure to pass `result.transactions` instead of just `result` into the matcher.');
            }
            throw e;
        }
    }
}
exports.compareTransactionForTest = compareTransactionForTest;
function findTransaction(txs, match) {
    let res;
    if (Array.isArray(txs)) {
        res = txs.find((x) => compareTransaction(flattenTransaction(x), match));
    }
    else {
        res = compareTransaction(flattenTransaction(txs), match) ? txs : undefined;
    }
    return res;
}
exports.findTransaction = findTransaction;
function findTransactionRequired(txs, match) {
    const res = findTransaction(txs, match);
    if (res === undefined) {
        throw new Error(`Expected ${(0, node_inspect_extracted_1.inspect)(Array.isArray(txs) ? txs.map((x) => flattenTransaction(x)) : flattenTransaction(txs))} to contain a transaction that matches pattern ${(0, node_inspect_extracted_1.inspect)(match)}`);
    }
    return res;
}
exports.findTransactionRequired = findTransactionRequired;
function filterTransactions(txs, match) {
    return txs.filter((x) => compareTransaction(flattenTransaction(x), match));
}
exports.filterTransactions = filterTransactions;
