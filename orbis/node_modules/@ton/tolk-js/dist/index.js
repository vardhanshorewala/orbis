"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTolkCompilerVersion = getTolkCompilerVersion;
exports.runTolkCompiler = runTolkCompiler;
// @ts-ignore
const tolkfiftlib_js_1 = __importDefault(require("./tolkfiftlib.js"));
// @ts-ignore
const tolkfiftlib_wasm_js_1 = __importDefault(require("./tolkfiftlib.wasm.js"));
// @ts-ignore
const stdlib_tolk_js_1 = __importDefault(require("./stdlib.tolk.js"));
const path_utils_1 = require("./path-utils");
let wasmBinary = undefined;
function copyToCStringAllocating(mod, inStr) {
    const len = mod.lengthBytesUTF8(inStr) + 1;
    const ptr = mod._malloc(len);
    mod.stringToUTF8(inStr, ptr, len);
    return ptr;
}
function copyToCStringPtr(mod, inStr, destPtr) {
    const allocated = copyToCStringAllocating(mod, inStr);
    mod.setValue(destPtr, allocated, '*');
    return allocated;
}
function copyFromCString(mod, inPtr) {
    return mod.UTF8ToString(inPtr);
}
async function instantiateWasmModule() {
    if (wasmBinary === undefined) {
        if (typeof Buffer !== 'undefined') { // node.js
            wasmBinary = new Uint8Array(Buffer.from(tolkfiftlib_wasm_js_1.default, 'base64'));
        }
        else if (typeof window !== 'undefined') { // browser
            const binaryString = atob(tolkfiftlib_wasm_js_1.default); // window.atob() is fast and safe for valid base64 strings
            wasmBinary = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                wasmBinary[i] = binaryString.charCodeAt(i);
            }
        }
    }
    return await (0, tolkfiftlib_js_1.default)({ wasmBinary });
}
async function getTolkCompilerVersion() {
    const mod = await instantiateWasmModule();
    const versionJsonPtr = mod._version();
    const result = JSON.parse(copyFromCString(mod, versionJsonPtr));
    mod._free(versionJsonPtr);
    return result.tolkVersion;
}
async function runTolkCompiler(compilerConfig) {
    const mod = await instantiateWasmModule();
    const allocatedPointers = [];
    const sourcesSnapshot = [];
    // see tolk-wasm.cpp: typedef void (*WasmFsReadCallback)(int, char const*, char**, char**)
    const callbackPtr = mod.addFunction(function (kind, dataPtr, destContents, destError) {
        switch (kind) { // enum ReadCallback::Kind in C++
            case 0: // realpath
                let relativeFilename = copyFromCString(mod, dataPtr); // from `import` statement, relative to cur file
                if (!relativeFilename.endsWith('.tolk')) {
                    relativeFilename += '.tolk';
                }
                allocatedPointers.push(copyToCStringPtr(mod, (0, path_utils_1.realpath)(relativeFilename), destContents));
                break;
            case 1: // read file
                try {
                    const filename = copyFromCString(mod, dataPtr); // already normalized (as returned above)
                    if (filename.startsWith('@stdlib/')) {
                        if (filename in stdlib_tolk_js_1.default) {
                            allocatedPointers.push(copyToCStringPtr(mod, stdlib_tolk_js_1.default[filename], destContents));
                        }
                        else {
                            allocatedPointers.push(copyToCStringPtr(mod, filename + " not found", destError));
                        }
                    }
                    else {
                        const contents = compilerConfig.fsReadCallback(filename);
                        sourcesSnapshot.push({ filename, contents });
                        allocatedPointers.push(copyToCStringPtr(mod, contents, destContents));
                    }
                }
                catch (err) {
                    allocatedPointers.push(copyToCStringPtr(mod, err.message || err.toString(), destError));
                }
                break;
            default:
                allocatedPointers.push(copyToCStringPtr(mod, 'Unknown callback kind=' + kind, destError));
                break;
        }
    }, 'viiii');
    const configStr = JSON.stringify({
        entrypointFileName: compilerConfig.entrypointFileName,
        optimizationLevel: compilerConfig.optimizationLevel,
        withStackComments: compilerConfig.withStackComments,
        withSrcLineComments: compilerConfig.withSrcLineComments,
        experimentalOptions: compilerConfig.experimentalOptions,
    });
    const configStrPtr = copyToCStringAllocating(mod, configStr);
    allocatedPointers.push(configStrPtr);
    const resultPtr = mod._tolk_compile(configStrPtr, callbackPtr);
    allocatedPointers.push(resultPtr);
    const result = JSON.parse(copyFromCString(mod, resultPtr));
    allocatedPointers.forEach(ptr => mod._free(ptr));
    mod.removeFunction(callbackPtr);
    return result.status === 'error' ? result : { ...result, sourcesSnapshot };
}
