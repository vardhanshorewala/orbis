"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepcopy = void 0;
const core_1 = require("@ton/core");
function deepcopyBuffer(buffer) {
    if (!buffer)
        return;
    const newBuffer = Buffer.alloc(buffer.length);
    buffer.copy(newBuffer);
    return newBuffer;
}
function deepcopyDict(dict) {
    const rawDict = dict;
    // TODO: make pr to @ton/core with key, value and map fields
    // @ts-expect-error Accessing private constructor for cloning purposes
    return new core_1.Dictionary(deepcopy(rawDict._map), rawDict._key, rawDict._value);
}
function deepcopy(obj) {
    if (obj === null || obj === undefined)
        return obj;
    if (Buffer.isBuffer(obj)) {
        return deepcopyBuffer(obj);
    }
    if (obj instanceof (core_1.Dictionary)) {
        return deepcopyDict(obj);
    }
    if (core_1.Address.isAddress(obj)) {
        return new core_1.Address(obj.workChain, deepcopyBuffer(obj.hash));
    }
    if (Array.isArray(obj)) {
        return obj.map((item) => deepcopy(item));
    }
    if (obj instanceof core_1.Cell) {
        return obj;
    }
    if (obj instanceof Map) {
        const newMap = new Map();
        for (const [key, value] of obj) {
            newMap.set(deepcopy(key), deepcopy(value));
        }
        return newMap;
    }
    if (typeof obj === 'object') {
        if (obj.constructor && obj.constructor.name !== 'Object') {
            throw new Error(`Unknown class ${obj.constructor.name} passed to deepcopy`);
        }
        const result = {};
        for (const [key, value] of Object.entries(obj)) {
            result[key] = deepcopy(value);
        }
        return result;
    }
    return obj;
}
exports.deepcopy = deepcopy;
