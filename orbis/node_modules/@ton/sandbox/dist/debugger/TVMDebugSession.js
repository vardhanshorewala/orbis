"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TVMDebugSession = void 0;
const node_path_1 = require("node:path");
const debugadapter_1 = require("@vscode/debugadapter");
class TVMDebugSession extends debugadapter_1.LoggingDebugSession {
    constructor(debuggee) {
        super();
        this.debuggee = debuggee;
        this.debuggee.on('stopOnEntry', () => {
            this.sendEvent(new debugadapter_1.StoppedEvent('entry', TVMDebugSession.threadID));
        });
        this.debuggee.on('stopOnBreakpoint', () => {
            this.sendEvent(new debugadapter_1.StoppedEvent('breakpoint', TVMDebugSession.threadID));
        });
        this.debuggee.on('stopOnStep', () => {
            this.sendEvent(new debugadapter_1.StoppedEvent('step', TVMDebugSession.threadID));
        });
        this.debuggee.on('end', () => {
            this.sendEvent(new debugadapter_1.TerminatedEvent());
        });
        this.debuggee.on('output', (s) => {
            this.sendEvent(new debugadapter_1.OutputEvent(s + '\n', 'stdout'));
        });
    }
    initializeRequest(response, _args) {
        response.body = response.body || {};
        const b = response.body;
        b.supportsConfigurationDoneRequest = false;
        b.supportsFunctionBreakpoints = false;
        b.supportsConditionalBreakpoints = false;
        b.supportsHitConditionalBreakpoints = false;
        b.supportsEvaluateForHovers = false;
        b.supportsStepBack = false;
        b.supportsSetVariable = false;
        b.supportsRestartFrame = false;
        b.supportsGotoTargetsRequest = false;
        b.supportsStepInTargetsRequest = false;
        b.supportsCompletionsRequest = false;
        b.supportsModulesRequest = false;
        b.supportsRestartRequest = false;
        b.supportsValueFormattingOptions = false;
        b.supportsExceptionInfoRequest = false;
        b.supportTerminateDebuggee = false;
        b.supportSuspendDebuggee = false;
        b.supportsDelayedStackTraceLoading = false;
        b.supportsLoadedSourcesRequest = true;
        b.supportsLogPoints = false;
        b.supportsTerminateThreadsRequest = false;
        b.supportsSetExpression = false;
        b.supportsTerminateRequest = false;
        b.supportsDataBreakpoints = false;
        b.supportsReadMemoryRequest = false;
        b.supportsWriteMemoryRequest = false;
        b.supportsDisassembleRequest = false;
        b.supportsCancelRequest = false;
        b.supportsBreakpointLocationsRequest = true;
        b.supportsClipboardContext = false;
        b.supportsSteppingGranularity = false;
        b.supportsInstructionBreakpoints = false;
        b.supportsExceptionFilterOptions = false;
        b.supportsSingleThreadExecutionRequests = false;
        this.sendResponse(response);
        this.sendEvent(new debugadapter_1.InitializedEvent());
    }
    loadedSourcesRequest(response, _args, _request) {
        response.body = response.body || {};
        response.body.sources = this.debuggee.getAvailableSourcePaths().map((v) => ({
            path: v,
            name: (0, node_path_1.basename)(v),
        }));
        this.sendResponse(response);
    }
    breakpointLocationsRequest(response, args, _request) {
        response.body = response.body || {};
        const path = args.source.path;
        if (path === undefined) {
            this.sendErrorResponse(response, {
                id: 1001,
                format: 'No path',
            });
            return;
        }
        response.body.breakpoints = this.debuggee
            .getAvailableLines(path)
            .filter((l) => l >= args.line && l <= (args.endLine ?? args.line))
            .map((l) => ({
            line: l,
        }));
        this.sendResponse(response);
    }
    launchRequest(response, args, _request) {
        debugadapter_1.logger.setup(debugadapter_1.Logger.LogLevel.Log);
        this.debuggee.start(!args.noDebug, true);
        this.sendResponse(response);
    }
    attachRequest(response, args, request) {
        this.launchRequest(response, args, request);
    }
    setBreakPointsRequest(response, args, _request) {
        const path = args.source.path;
        if (path === undefined) {
            this.sendErrorResponse(response, {
                id: 1001,
                format: 'No path',
            });
            return;
        }
        const breakpoints = args.breakpoints;
        if (breakpoints === undefined) {
            this.sendErrorResponse(response, {
                id: 1002,
                format: 'No breakpoints',
            });
            return;
        }
        this.debuggee.clearBreakpoints(path);
        const bps = [];
        for (const bp of breakpoints) {
            const sbp = this.debuggee.setBreakpoint(path, bp.line);
            bps.push({
                id: sbp.id,
                line: sbp.line,
                verified: sbp.verified,
            });
        }
        response.body = {
            breakpoints: bps,
        };
        this.sendResponse(response);
    }
    threadsRequest(response, _request) {
        response.body = {
            threads: [new debugadapter_1.Thread(TVMDebugSession.threadID, 'main')],
        };
        this.sendResponse(response);
    }
    continueRequest(response, _args, _request) {
        this.debuggee.continue();
        this.sendResponse(response);
    }
    nextRequest(response, _args, _request) {
        this.debuggee.stepOver();
        this.sendResponse(response);
    }
    stepInRequest(response, _args, _request) {
        this.debuggee.stepIn();
        this.sendResponse(response);
    }
    stepOutRequest(response, _args, _request) {
        this.debuggee.stepOut();
        this.sendResponse(response);
    }
    stackTraceRequest(response, args, _request) {
        response.body = response.body || {};
        const sme = this.debuggee.currentSourceMapEntry(false);
        if (sme === undefined) {
            response.body.stackFrames = [];
            response.body.totalFrames = 0;
            this.sendResponse(response);
            return;
        }
        const frames = this.debuggee.stackFrames();
        response.body.totalFrames = frames.length;
        if (args.startFrame ?? 0 >= frames.length) {
            response.body.stackFrames = [];
            this.sendResponse(response);
            return;
        }
        response.body.stackFrames = [];
        for (let i = args.startFrame ?? 0; i < frames.length; i++) {
            const frame = frames[i];
            response.body.stackFrames.push({
                id: i === frames.length - 1 ? TVMDebugSession.stackFrameID : 0,
                name: frame.function,
                line: frame.line,
                column: 0,
                source: {
                    name: (0, node_path_1.basename)(frame.path),
                    path: frame.path,
                },
            });
        }
        response.body.stackFrames.reverse();
        this.sendResponse(response);
    }
    scopesRequest(response, args, _request) {
        response.body = response.body || {};
        if (args.frameId !== TVMDebugSession.stackFrameID) {
            response.body.scopes = [];
            this.sendResponse(response);
            return;
        }
        const sme = this.debuggee.currentSourceMapEntry(false);
        if (sme === undefined) {
            response.body.scopes = [];
            this.sendResponse(response);
            return;
        }
        response.body.scopes = [
            {
                name: 'Locals',
                variablesReference: TVMDebugSession.localVariablesReference,
                expensive: false,
            },
            {
                name: 'Globals',
                variablesReference: TVMDebugSession.globalVariablesReference,
                expensive: false,
            },
        ];
        this.sendResponse(response);
    }
    variablesRequest(response, args, _request) {
        response.body = response.body || {};
        response.body.variables = [];
        let vars = undefined;
        if (args.variablesReference === TVMDebugSession.localVariablesReference) {
            vars = this.debuggee.getLocalVariables();
        }
        else if (args.variablesReference === TVMDebugSession.globalVariablesReference) {
            vars = this.debuggee.getGlobalVariables();
        }
        if (vars === undefined) {
            this.sendResponse(response);
            return;
        }
        for (const v of vars) {
            response.body.variables.push({
                name: v.name,
                value: tupleItemToString(v.value),
                type: v.value.type,
                variablesReference: 0,
            });
        }
        response.body.variables.sort((a, b) => (a.name < b.name ? -1 : a.name > b.name ? 1 : 0));
        this.sendResponse(response);
    }
    disconnectRequest(response, args, _request) {
        if (args.restart) {
            this.sendErrorResponse(response, {
                id: 1003,
                format: 'Cannot restart',
            });
        }
        else {
            this.sendResponse(response);
        }
    }
}
exports.TVMDebugSession = TVMDebugSession;
TVMDebugSession.threadID = 1;
TVMDebugSession.stackFrameID = 1;
TVMDebugSession.localVariablesReference = 1;
TVMDebugSession.globalVariablesReference = 2;
function tupleItemToString(ti) {
    switch (ti.type) {
        case 'int':
            return ti.value.toString();
        case 'null':
            return 'null';
        case 'nan':
            return 'NaN';
        case 'cell':
        case 'slice':
        case 'builder':
            return ti.cell.toBoc().toString('base64');
        case 'tuple':
            return `[${ti.items.map((v) => tupleItemToString(v)).join(', ')}]`;
    }
}
