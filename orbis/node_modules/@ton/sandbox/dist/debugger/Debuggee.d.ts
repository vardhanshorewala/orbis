/// <reference types="node" />
import EventEmitter from 'node:events';
import { TupleItem } from '@ton/core';
import { Executor, GetMethodArgs, RunTransactionArgs } from '../executor/Executor';
export type SourceMapEntry = {
    path: string;
    line: number;
    function: string;
    contextId: number;
    requireContextId?: number;
} & ({
    type: 'statement';
    variables: string[];
    firstStatement?: true;
} | {
    type: 'return';
} | {
    type: 'try_begin';
    catchContextId: number;
} | {
    type: 'try_end';
} | {
    type: 'context';
} | {
    type: 'branch';
    trueContextId: number;
    falseContextId?: number;
});
export type DebugMarks = Map<string, Map<number, number[]>>;
export type SourceMap = {
    [k: number]: SourceMapEntry;
};
export type GlobalEntry = {
    name: string;
};
export type DebugInfo = {
    sourceMap: SourceMap;
    globals: GlobalEntry[];
    marks: DebugMarks;
};
type Breakpoint = {
    id: number;
    line: number;
    verified: boolean;
};
export type Variable = {
    name: string;
    value: TupleItem;
};
type StackFrame = {
    function: string;
    path: string;
    line: number;
    nextContextId: number;
    contextId: number;
    shouldTryNoStep: boolean;
    stepped: boolean;
};
type StepUntil = {
    type: 'breakpoint';
} | {
    type: 'any-line';
    stopEvent: 'stopOnBreakpoint' | 'stopOnStep';
} | {
    type: 'next-line';
    depth: number;
} | {
    type: 'out';
    depth: number;
};
type TryContext = {
    contextId: number;
    frameDepth: number;
};
export declare class Debuggee extends EventEmitter {
    executor: Executor;
    ptr: number;
    debugType: 'get' | 'tx';
    sourceMap: SourceMap;
    availableLines: {
        [k: string]: number[];
    };
    breakpoints: Map<string, Breakpoint[]>;
    breakpointID: number;
    frames: StackFrame[];
    globals: GlobalEntry[];
    debugMarks: DebugMarks;
    tryContexts: TryContext[];
    finishedCallback: (v: unknown) => void;
    constructor(executor: Executor, finishedCallback: (v: unknown) => void);
    setDebugInfo(debugInfo: DebugInfo): void;
    setDebugMarks(marks: DebugMarks): void;
    setSourceMap(sourceMap: SourceMap): void;
    setGlobals(globals: GlobalEntry[]): void;
    getAvailableSourcePaths(): string[];
    getAvailableLines(path: string): number[];
    isLineAvailable(path: string, line: number): boolean;
    continue(): void;
    stepIn(): void;
    stepOver(): void;
    stepOut(): void;
    startGetMethod(args: GetMethodArgs): void;
    startTransaction(args: RunTransactionArgs): void;
    getC7(): TupleItem;
    vmStep(): boolean;
    codePos(): {
        hash: string;
        offset: number;
    };
    getStack(): TupleItem[];
    getContDistinguisher(): number;
    setContDistinguishers(distinguisher: number, trueDistinguisher: number, falseDistinguisher: number): void;
    getContDistinguisherTriggered(): boolean;
    setTryParams(primed: number, triggered: number): void;
    getTriggeredTryParam(): number;
    getLocalVariables(): Variable[] | undefined;
    getGlobalVariables(): Variable[] | undefined;
    currentDebugMarks(): number[] | undefined;
    currentSourceMapEntry(honorStepped: boolean): SourceMapEntry | undefined;
    breakpointKey(path: string, line: number): string;
    splitBreakpointKey(k: string): {
        path: string;
        line: number;
    };
    clearBreakpoints(path: string): void;
    hasBreakpoint(path: string, line: number): boolean;
    setBreakpoint(path: string, line: number): Breakpoint;
    sendEvent(event: string, ...args: unknown[]): void;
    onFinished(): void;
    stackFrames(): StackFrame[];
    applySourceMapEntry(sme: SourceMapEntry, until: StepUntil): {
        stopStepping: boolean;
    };
    stepUntil(what: {
        type: 'breakpoint';
    } | {
        type: 'any-line';
        stopEvent: 'stopOnBreakpoint' | 'stopOnStep';
    } | {
        type: 'next-line';
    } | {
        type: 'out';
    }): void;
    prepareGetMethod(args: GetMethodArgs, debugInfo: DebugInfo): void;
    prepareTransaction(args: RunTransactionArgs, debugInfo: DebugInfo): void;
    start(debug: boolean, stopOnEntry: boolean): void;
}
export {};
