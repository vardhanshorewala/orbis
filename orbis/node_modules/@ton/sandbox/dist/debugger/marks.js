"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMarks = void 0;
const core_1 = require("@ton/core");
const MarksDictValue = {
    parse(src) {
        return src
            .loadRef()
            .beginParse()
            .loadDictDirect(core_1.Dictionary.Keys.Uint(10), {
            parse(_src) {
                return null;
            },
            serialize(_src, _builder) {
                throw new Error('Not implemented');
            },
        });
    },
    serialize(_src, _builder) {
        throw new Error('Not implemented');
    },
};
const CellInfoValue = {
    parse(src) {
        return {
            isNormal: src.loadBit(),
            marks: src.loadDict(core_1.Dictionary.Keys.Uint(32), MarksDictValue),
        };
    },
    serialize(_src, _builder) {
        throw new Error('Not implemented');
    },
};
const CellValue = {
    parse(src) {
        return src.asCell();
    },
    serialize(_src, _builder) {
        throw new Error('Not implemented');
    },
};
function sliceToString(slice, len) {
    let out = '';
    for (let i = 0; i < len; i++) {
        out += slice.loadBit() ? '1' : '0';
    }
    return out;
}
function readLabel(slice, m) {
    if (slice.loadBit()) {
        if (slice.loadBit()) {
            const bit = slice.loadBit();
            const len = slice.loadUint(Math.ceil(Math.log2(m + 1)));
            return (bit ? '1' : '0').repeat(len);
        }
        else {
            const len = slice.loadUint(Math.ceil(Math.log2(m + 1)));
            return sliceToString(slice, len);
        }
    }
    else {
        let len = 0;
        while (slice.loadBit()) {
            len++;
        }
        return sliceToString(slice, len);
    }
}
function getFinalSlice(dc, key) {
    const dict = dc.beginParse();
    const lbl = readLabel(dict, key.length);
    if (!key.startsWith(lbl)) {
        throw new Error('Invalid label');
    }
    if (lbl.length === key.length) {
        return dc;
    }
    let child = dict.loadRef();
    if (key[lbl.length] === '1') {
        child = dict.loadRef();
    }
    return getFinalSlice(child, key.slice(lbl.length + 1));
}
function hashToString(hash) {
    return hash.toString('hex').toUpperCase();
}
function getRealCodeHashes(code) {
    const dictC = code.beginParse().loadRef();
    const d = dictC.beginParse().loadDictDirect(core_1.Dictionary.Keys.Int(19), CellValue);
    const r = new Map();
    for (const [idx, v] of d) {
        const idxKey = sliceToString((0, core_1.beginCell)().storeInt(idx, 19).endCell().beginParse(), 19);
        const finalSlice = getFinalSlice(dictC, idxKey);
        const originalSlice = d.get(idx);
        if (originalSlice === undefined) {
            throw new Error('Unknown original slice');
        }
        r.set(hashToString(v.hash()), {
            hash: hashToString(finalSlice.hash()),
            diff: finalSlice.bits.length - originalSlice.bits.length,
        });
    }
    return r;
}
function parseMarks(marksCell, code) {
    const realCodeHashes = getRealCodeHashes(code);
    const d = marksCell.beginParse().loadDictDirect(core_1.Dictionary.Keys.Buffer(32), CellInfoValue);
    const r = new Map();
    for (const [hash, info] of d) {
        const hashStr = hashToString(hash);
        const finalHash = info.isNormal ? hashStr : realCodeHashes.get(hashStr)?.hash;
        if (finalHash === undefined) {
            continue;
        }
        const marks = new Map();
        for (const [mark, offsets] of info.marks) {
            for (const offset of offsets.keys()) {
                const adjustedOffset = offset + (info.isNormal ? 0 : (realCodeHashes.get(hashStr)?.diff ?? 0));
                const arr = marks.get(adjustedOffset) ?? [];
                arr.push(mark);
                marks.set(adjustedOffset, arr);
            }
        }
        r.set(finalHash, marks);
    }
    return r;
}
exports.parseMarks = parseMarks;
