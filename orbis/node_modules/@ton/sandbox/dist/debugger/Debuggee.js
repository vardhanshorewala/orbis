"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Debuggee = void 0;
const node_events_1 = __importDefault(require("node:events"));
class Debuggee extends node_events_1.default {
    constructor(executor, finishedCallback) {
        super();
        this.ptr = 0;
        this.debugType = 'get';
        this.sourceMap = {};
        this.availableLines = {};
        this.breakpoints = new Map();
        this.breakpointID = 0;
        this.frames = [];
        this.globals = [];
        this.debugMarks = new Map();
        this.tryContexts = [];
        this.executor = executor;
        this.executor.debugLogFunc = (s) => {
            this.sendEvent('output', s);
        };
        this.finishedCallback = finishedCallback;
    }
    setDebugInfo(debugInfo) {
        this.setSourceMap(debugInfo.sourceMap);
        this.setGlobals(debugInfo.globals);
        this.setDebugMarks(debugInfo.marks);
    }
    setDebugMarks(marks) {
        this.debugMarks = marks;
    }
    setSourceMap(sourceMap) {
        this.sourceMap = sourceMap;
        for (const di in sourceMap) {
            const sem = sourceMap[di];
            if (!(sem.path in this.availableLines)) {
                this.availableLines[sem.path] = [];
            }
            this.availableLines[sem.path].push(sem.line);
        }
    }
    setGlobals(globals) {
        this.globals = globals;
    }
    getAvailableSourcePaths() {
        return Object.keys(this.availableLines);
    }
    getAvailableLines(path) {
        return this.availableLines[path] ?? [];
    }
    isLineAvailable(path, line) {
        if (!(path in this.availableLines)) {
            return false;
        }
        const lines = this.availableLines[path];
        return lines.indexOf(line) >= 0;
    }
    continue() {
        this.stepUntil({ type: 'breakpoint' });
    }
    stepIn() {
        this.stepUntil({ type: 'any-line', stopEvent: 'stopOnStep' });
    }
    stepOver() {
        this.stepUntil({ type: 'next-line' });
    }
    stepOut() {
        this.stepUntil({ type: 'out' });
    }
    startGetMethod(args) {
        this.ptr = this.executor.sbsGetMethodSetup(args);
        this.debugType = 'get';
    }
    startTransaction(args) {
        const { emptr, res } = this.executor.sbsTransactionSetup(args);
        if (res !== 1) {
            throw new Error('Could not setup SBS transaction, result: ' + res);
        }
        this.ptr = emptr;
        this.debugType = 'tx';
    }
    getC7() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodC7(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionC7(this.ptr);
        }
    }
    vmStep() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodStep(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionStep(this.ptr);
        }
    }
    codePos() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodCodePos(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionCodePos(this.ptr);
        }
    }
    getStack() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodStack(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionStack(this.ptr);
        }
    }
    getContDistinguisher() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodGetContDistinguisher(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionGetContDistinguisher(this.ptr);
        }
    }
    setContDistinguishers(distinguisher, trueDistinguisher, falseDistinguisher) {
        switch (this.debugType) {
            case 'get':
                this.executor.sbsGetMethodSetContDistinguishers(this.ptr, distinguisher, trueDistinguisher, falseDistinguisher);
                break;
            case 'tx':
                this.executor.sbsTransactionSetContDistinguishers(this.ptr, distinguisher, trueDistinguisher, falseDistinguisher);
                break;
        }
    }
    getContDistinguisherTriggered() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodGetContDistinguisherTriggered(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionGetContDistinguisherTriggered(this.ptr);
        }
    }
    setTryParams(primed, triggered) {
        switch (this.debugType) {
            case 'get':
                this.executor.sbsGetMethodSetTryParams(this.ptr, primed, triggered);
                break;
            case 'tx':
                this.executor.sbsTransactionSetTryParams(this.ptr, primed, triggered);
                break;
        }
    }
    getTriggeredTryParam() {
        switch (this.debugType) {
            case 'get':
                return this.executor.sbsGetMethodGetTriggeredTryParam(this.ptr);
            case 'tx':
                return this.executor.sbsTransactionGetTriggeredTryParam(this.ptr);
        }
    }
    getLocalVariables() {
        const sme = this.currentSourceMapEntry(false);
        if (sme === undefined || sme.type !== 'statement') {
            return undefined;
        }
        const vars = [];
        const stack = this.getStack();
        for (let i = 0; i < sme.variables.length; i++) {
            vars.push({
                name: sme.variables[i],
                value: stack[i],
            });
        }
        return vars;
    }
    getGlobalVariables() {
        const vars = [];
        const c7item = this.getC7();
        if (c7item.type !== 'tuple') {
            return undefined;
        }
        const c7 = c7item.items;
        for (let i = 0; i < this.globals.length; i++) {
            if (i + 1 < c7.length) {
                vars.push({
                    name: this.globals[i].name,
                    value: c7[i + 1],
                });
                continue;
            }
            vars.push({
                name: this.globals[i].name,
                value: { type: 'null' },
            });
        }
        return vars;
    }
    currentDebugMarks() {
        const codepos = this.codePos();
        return this.debugMarks.get(codepos.hash)?.get(codepos.offset);
    }
    currentSourceMapEntry(honorStepped) {
        const dms = this.currentDebugMarks();
        if (dms === undefined) {
            return undefined;
        }
        let currentContextId;
        let stepped;
        if (this.frames.length > 0) {
            const topFrame = this.frames[this.frames.length - 1];
            currentContextId = topFrame.contextId;
            stepped = topFrame.stepped;
        }
        for (const dm of dms) {
            const entry = this.sourceMap[dm];
            if ((entry.type === 'statement' &&
                entry.firstStatement &&
                entry.requireContextId === undefined &&
                (stepped || !honorStepped)) ||
                entry.requireContextId === currentContextId) {
                return entry;
            }
        }
        return undefined;
    }
    breakpointKey(path, line) {
        return path + ':' + line;
    }
    splitBreakpointKey(k) {
        const i = k.lastIndexOf(':');
        return {
            path: k.slice(0, i),
            line: parseInt(k.slice(i + 1)),
        };
    }
    clearBreakpoints(path) {
        this.breakpoints.set(path, []);
    }
    hasBreakpoint(path, line) {
        return (this.breakpoints.get(path) ?? []).findIndex((v) => v.line === line) >= 0;
    }
    setBreakpoint(path, line) {
        let arr = this.breakpoints.get(path);
        if (arr === undefined) {
            arr = [];
            this.breakpoints.set(path, arr);
        }
        const bp = {
            id: this.breakpointID++,
            line,
            verified: this.isLineAvailable(path, line),
        };
        arr.push(bp);
        return bp;
    }
    sendEvent(event, ...args) {
        setTimeout(() => {
            this.emit(event, ...args);
        }, 0);
    }
    onFinished() {
        this.sendEvent('end');
        let r;
        switch (this.debugType) {
            case 'get': {
                r = this.executor.sbsGetMethodResult(this.ptr);
                this.executor.destroyTvmEmulator(this.ptr);
                break;
            }
            case 'tx': {
                r = this.executor.sbsTransactionResult(this.ptr);
                this.executor.destroyEmulator(this.ptr);
                break;
            }
        }
        this.finishedCallback(r);
    }
    stackFrames() {
        return this.frames;
    }
    applySourceMapEntry(sme, until) {
        let stopStepping = false;
        switch (sme.type) {
            case 'statement': {
                if (sme.firstStatement) {
                    this.frames.push({
                        function: sme.function,
                        path: sme.path,
                        line: sme.line,
                        contextId: sme.contextId,
                        shouldTryNoStep: true,
                        nextContextId: sme.contextId,
                        stepped: false,
                    });
                }
                if (this.frames.length > 0) {
                    const topFrame = this.frames[this.frames.length - 1];
                    topFrame.line = sme.line;
                }
                switch (until.type) {
                    case 'breakpoint': {
                        if (this.hasBreakpoint(sme.path, sme.line)) {
                            this.sendEvent('stopOnBreakpoint');
                            stopStepping = true;
                        }
                        break;
                    }
                    case 'any-line': {
                        this.sendEvent(until.stopEvent);
                        stopStepping = true;
                        break;
                    }
                    case 'next-line': {
                        if (this.frames.length <= until.depth) {
                            this.sendEvent('stopOnStep');
                            stopStepping = true;
                        }
                        break;
                    }
                    case 'out': {
                        if (this.frames.length < until.depth) {
                            this.sendEvent('stopOnStep');
                            stopStepping = true;
                        }
                        break;
                    }
                }
                break;
            }
            case 'return': {
                this.frames.pop();
                return { stopStepping };
            }
            case 'try_begin': {
                this.tryContexts.push({
                    contextId: sme.catchContextId,
                    frameDepth: this.frames.length,
                });
                this.setTryParams(this.tryContexts.length - 1, -1);
                break;
            }
            case 'try_end': {
                this.tryContexts.pop();
                this.setTryParams(-1, -1);
                break;
            }
            case 'branch': {
                let falseId = -1;
                if (sme.falseContextId !== undefined) {
                    falseId = sme.falseContextId;
                }
                this.setContDistinguishers(-1, sme.trueContextId, falseId);
                break;
            }
        }
        if (this.frames.length > 0) {
            const topFrame = this.frames[this.frames.length - 1];
            topFrame.shouldTryNoStep = true;
            topFrame.nextContextId = sme.contextId;
        }
        return { stopStepping };
    }
    stepUntil(what) {
        let until;
        switch (what.type) {
            case 'next-line':
            case 'out': {
                until = { type: what.type, depth: this.frames.length };
                break;
            }
            default:
                until = what;
        }
        while (true) {
            if (this.frames.length > 0) {
                const topFrame = this.frames[this.frames.length - 1];
                while (topFrame.shouldTryNoStep) {
                    topFrame.contextId = topFrame.nextContextId;
                    const sme = this.currentSourceMapEntry(true);
                    if (sme === undefined) {
                        topFrame.shouldTryNoStep = false;
                        break;
                    }
                    const { stopStepping } = this.applySourceMapEntry(sme, until);
                    if (stopStepping) {
                        return;
                    }
                }
            }
            if (this.frames.length > 0) {
                const topFrame = this.frames[this.frames.length - 1];
                topFrame.stepped = true;
            }
            const finished = this.vmStep();
            if (finished) {
                this.onFinished();
                return;
            }
            const triggeredTryParam = this.getTriggeredTryParam();
            if (triggeredTryParam >= 0) {
                if (triggeredTryParam !== this.tryContexts.length - 1) {
                    throw new Error(`Got triggered try param ${triggeredTryParam} but expected ${this.tryContexts.length - 1}`);
                }
                const tryContext = this.tryContexts[triggeredTryParam];
                this.tryContexts.pop();
                this.setTryParams(-1, -1);
                this.frames = this.frames.slice(0, tryContext.frameDepth);
                this.frames[this.frames.length - 1].contextId = tryContext.contextId;
            }
            if (this.getContDistinguisherTriggered()) {
                const distinguisher = this.getContDistinguisher();
                this.setContDistinguishers(-1, -1, -1);
                if (distinguisher >= 0 && this.frames.length > 0) {
                    const topFrame = this.frames[this.frames.length - 1];
                    topFrame.contextId = distinguisher;
                }
            }
            const sme = this.currentSourceMapEntry(true);
            if (sme !== undefined) {
                const { stopStepping } = this.applySourceMapEntry(sme, until);
                if (stopStepping) {
                    return;
                }
            }
        }
    }
    prepareGetMethod(args, debugInfo) {
        this.startGetMethod(args);
        this.setDebugInfo(debugInfo);
    }
    prepareTransaction(args, debugInfo) {
        this.startTransaction(args);
        this.setDebugInfo(debugInfo);
    }
    start(debug, stopOnEntry) {
        if (debug) {
            if (stopOnEntry) {
                this.stepUntil({ type: 'any-line', stopEvent: 'stopOnBreakpoint' });
            }
            else {
                this.continue();
            }
        }
        else {
            this.continue();
        }
    }
}
exports.Debuggee = Debuggee;
