"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = void 0;
const core_1 = require("@ton/core");
const fflate_1 = require("fflate");
const base64_1 = require("../utils/base64");
const bpatch_1 = require("../utils/bpatch");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const EmulatorModule = require('./emulator-emscripten.js');
// eslint-disable-next-line @typescript-eslint/no-require-imports
const DebuggerEmulatorModule = require('./emulator-emscripten.debugger.js');
function blockIdToTuple(blockId) {
    return [
        { type: 'int', value: BigInt(blockId.workchain) },
        { type: 'int', value: blockId.shard },
        { type: 'int', value: BigInt(blockId.seqno) },
        { type: 'int', value: BigInt('0x' + blockId.rootHash.toString('hex')) },
        { type: 'int', value: BigInt('0x' + blockId.fileHash.toString('hex')) },
    ];
}
function prevBlocksInfoToTuple(prevBlocksInfo) {
    const r = [
        {
            type: 'tuple',
            items: prevBlocksInfo.lastMcBlocks.map((bid) => ({ type: 'tuple', items: blockIdToTuple(bid) })),
        },
        { type: 'tuple', items: blockIdToTuple(prevBlocksInfo.prevKeyBlock) },
    ];
    if (prevBlocksInfo.lastMcBlocks100) {
        r.push({
            type: 'tuple',
            items: prevBlocksInfo.lastMcBlocks100.map((bid) => ({ type: 'tuple', items: blockIdToTuple(bid) })),
        });
    }
    return r;
}
function serializeTupleAsStackEntry(tuple) {
    const c = (0, core_1.serializeTuple)([{ type: 'tuple', items: tuple }]);
    const s = c.beginParse();
    s.skip(24);
    s.loadRef();
    return s.asCell();
}
const verbosityToNum = {
    short: 0,
    full: 1,
    full_location: 2,
    full_location_gas: 3,
    full_location_stack: 4,
    full_location_stack_verbose: 5,
};
function runCommonArgsToInternalParams(args) {
    const p = {
        utime: args.now,
        lt: args.lt.toString(),
        rand_seed: args.randomSeed === null ? '' : args.randomSeed.toString('hex'),
        ignore_chksig: args.ignoreChksig,
        debug_enabled: args.debugEnabled,
    };
    if (args.prevBlocksInfo !== undefined) {
        p.prev_blocks_info = serializeTupleAsStackEntry(prevBlocksInfoToTuple(args.prevBlocksInfo))
            .toBoc()
            .toString('base64');
    }
    return p;
}
function getMethodArgsToInternalParams(args) {
    const params = {
        code: args.code.toBoc().toString('base64'),
        data: args.data.toBoc().toString('base64'),
        verbosity: verbosityToNum[args.verbosity],
        libs: args.libs?.toBoc().toString('base64') ?? '',
        address: args.address.toString(),
        unixtime: args.unixTime,
        balance: args.balance.toString(),
        rand_seed: args.randomSeed.toString('hex'),
        gas_limit: args.gasLimit.toString(),
        method_id: args.methodId,
        debug_enabled: args.debugEnabled,
    };
    if (args.extraCurrency !== undefined) {
        params.extra_currencies = {};
        for (const [k, v] of Object.entries(args.extraCurrency)) {
            params.extra_currencies[k] = v.toString();
        }
    }
    if (args.prevBlocksInfo !== undefined) {
        params.prev_blocks_info = serializeTupleAsStackEntry(prevBlocksInfoToTuple(args.prevBlocksInfo))
            .toBoc()
            .toString('base64');
    }
    return params;
}
class Pointer {
    constructor(length, rawPointer) {
        this.inUse = true;
        this.length = length;
        this.rawPointer = rawPointer;
    }
    alloc() {
        this.inUse = true;
    }
    free() {
        this.inUse = false;
    }
}
class Heap {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(module) {
        this.pointers = [];
        this.maxPtrs = 0;
        this.module = module;
    }
    getPointersForStrings(strs) {
        this.maxPtrs = Math.max(this.maxPtrs, strs.length);
        const sorted = strs.map((str, i) => ({ str, i })).sort((a, b) => b.str.length - a.str.length);
        const ptrs = sorted
            .map((e) => ({ i: e.i, ptr: this.getCStringPointer(e.str) }))
            .sort((a, b) => a.i - b.i)
            .map((e) => e.ptr.rawPointer);
        this.pointers.sort((a, b) => b.length - a.length);
        this.pointers.slice(this.maxPtrs).forEach((ptr) => this.module._free(ptr.rawPointer));
        this.pointers = this.pointers.slice(0, this.maxPtrs);
        this.pointers.forEach((p) => p.free());
        return ptrs;
    }
    getCStringPointer(data) {
        let length = this.module.lengthBytesUTF8(data) + 1;
        let existing = this.pointers.find((p) => p.length >= length && !p.inUse);
        if (existing) {
            this.module.stringToUTF8(data, existing.rawPointer, length);
            existing.alloc();
            return existing;
        }
        const len = this.module.lengthBytesUTF8(data) + 1;
        const ptr = this.module._malloc(len);
        this.module.stringToUTF8(data, ptr, len);
        let pointer = new Pointer(length, ptr);
        this.pointers.push(new Pointer(length, ptr));
        return pointer;
    }
}
let wasmBinary = undefined;
function getWasmBinary() {
    if (wasmBinary !== undefined) {
        return wasmBinary;
    }
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    wasmBinary = new Uint8Array((0, base64_1.base64Decode)(require('./emulator-emscripten.wasm.js').EmulatorEmscriptenWasm));
    return wasmBinary;
}
let debuggerWasmBinary = undefined;
function getDebuggerWasmBinary() {
    if (debuggerWasmBinary !== undefined) {
        return debuggerWasmBinary;
    }
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const patch = (0, base64_1.base64Decode)(require('./emulator-emscripten.debugger.bpatch.gzip.js').DebuggerPatchGzip);
    const unzipped = (0, fflate_1.gunzipSync)(patch);
    debuggerWasmBinary = (0, bpatch_1.decodePatch)(getWasmBinary(), unzipped);
    return debuggerWasmBinary;
}
class Executor {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(module) {
        this.debugLogs = [];
        this.debugLogFunc = () => { };
        this.module = module;
        this.heap = new Heap(module);
    }
    handleDebugLog(text) {
        this.debugLogs.push(text);
        this.debugLogFunc(text);
    }
    static async create(opts) {
        const binary = opts?.debug ? getDebuggerWasmBinary() : getWasmBinary();
        const module = opts?.debug ? DebuggerEmulatorModule : EmulatorModule;
        let ex = undefined;
        const printErr = (text) => {
            if (ex === undefined) {
                // eslint-disable-next-line no-console
                console.error('Debug log received before executor was created:', text);
            }
            else {
                ex.handleDebugLog(text);
            }
        };
        ex = new Executor(await module({
            wasmBinary: binary,
            printErr,
        }));
        return ex;
    }
    async runGetMethod(args) {
        const params = getMethodArgsToInternalParams(args);
        let stack = (0, core_1.serializeTuple)(args.stack);
        this.debugLogs = [];
        const resp = JSON.parse(this.extractString(this.invoke('_run_get_method', [JSON.stringify(params), stack.toBoc().toString('base64'), args.config])));
        const debugLogs = this.debugLogs.join('\n');
        if (resp.fail) {
            // eslint-disable-next-line no-console
            console.error(resp);
            throw new Error('Unknown emulation error');
        }
        return {
            output: resp.output,
            logs: resp.logs,
            debugLogs,
        };
    }
    runCommon(args) {
        this.debugLogs = [];
        const resp = JSON.parse(this.extractString(this.invoke('_emulate_with_emulator', args)));
        const debugLogs = this.debugLogs.join('\n');
        if (resp.fail) {
            // eslint-disable-next-line no-console
            console.error(resp);
            throw new Error('Unknown emulation error');
        }
        const logs = resp.logs;
        const result = resp.output;
        return {
            result: result.success
                ? {
                    success: true,
                    transaction: result.transaction,
                    shardAccount: result.shard_account,
                    vmLog: result.vm_log,
                    actions: result.actions,
                }
                : {
                    success: false,
                    error: result.error,
                    vmResults: 'vm_log' in result
                        ? {
                            vmLog: result.vm_log,
                            vmExitCode: result.vm_exit_code,
                        }
                        : undefined,
                },
            logs,
            debugLogs,
        };
    }
    async runTickTock(args) {
        const params = {
            ...runCommonArgsToInternalParams(args),
            is_tick_tock: true,
            is_tock: args.which === 'tock',
        };
        return this.runCommon([
            this.getEmulatorPointer(args.config, verbosityToNum[args.verbosity]),
            args.libs?.toBoc().toString('base64') ?? 0,
            args.shardAccount,
            '',
            JSON.stringify(params),
        ]);
    }
    async runTransaction(args) {
        const params = runCommonArgsToInternalParams(args);
        return this.runCommon([
            this.getEmulatorPointer(args.config, verbosityToNum[args.verbosity]),
            args.libs?.toBoc().toString('base64') ?? 0,
            args.shardAccount,
            args.message.toBoc().toString('base64'),
            JSON.stringify(params),
        ]);
    }
    createEmulator(config, verbosity) {
        if (this.emulator !== undefined) {
            this.invoke('_destroy_emulator', [this.emulator.ptr]);
        }
        const ptr = this.invoke('_create_emulator', [config, verbosity]);
        this.emulator = {
            ptr,
            config,
            verbosity,
        };
    }
    getEmulatorPointer(config, verbosity) {
        if (this.emulator === undefined || verbosity !== this.emulator.verbosity || config !== this.emulator.config) {
            this.createEmulator(config, verbosity);
        }
        return this.emulator.ptr;
    }
    invoke(method, args) {
        const invocationArgs = [];
        const strArgs = [];
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === 'string') {
                strArgs.push({ str: arg, i });
            }
            else {
                invocationArgs[i] = arg;
            }
        }
        const strPtrs = this.heap.getPointersForStrings(strArgs.map((e) => e.str));
        for (let i = 0; i < strPtrs.length; i++) {
            invocationArgs[strArgs[i].i] = strPtrs[i];
        }
        return this.module[method](...invocationArgs);
    }
    sbsGetMethodSetup(args) {
        const params = getMethodArgsToInternalParams(args);
        let stack = (0, core_1.serializeTuple)(args.stack);
        this.debugLogs = [];
        const res = this.invoke('_setup_sbs_get_method', [
            JSON.stringify(params),
            stack.toBoc().toString('base64'),
            args.config,
        ]);
        return res;
    }
    destroyTvmEmulator(ptr) {
        this.invoke('_destroy_tvm_emulator', [ptr]);
    }
    sbsGetMethodStep(ptr) {
        const res = this.invoke('_sbs_step', [ptr]);
        return res !== 0;
    }
    sbsGetMethodStack(ptr) {
        const resp = this.extractString(this.invoke('_sbs_get_stack', [ptr]));
        return (0, core_1.parseTuple)(core_1.Cell.fromBase64(resp));
    }
    sbsGetMethodC7(ptr) {
        const resp = this.extractString(this.invoke('_sbs_get_c7', [ptr]));
        return (0, core_1.parseTuple)((0, core_1.beginCell)().storeUint(1, 24).storeRef(core_1.Cell.EMPTY).storeSlice(core_1.Cell.fromBase64(resp).beginParse()).endCell())[0];
    }
    sbsGetMethodGetContDistinguisher(ptr) {
        return this.invoke('_sbs_get_cont_distinguisher', [ptr]);
    }
    sbsGetMethodSetContDistinguishers(ptr, distinguisher, trueDistinguisher, falseDistinguisher) {
        this.invoke('_sbs_set_cont_distinguishers', [ptr, distinguisher, trueDistinguisher, falseDistinguisher]);
    }
    sbsGetMethodGetContDistinguisherTriggered(ptr) {
        return this.invoke('_sbs_get_cont_distinguisher_triggered', [ptr]) !== 0;
    }
    sbsGetMethodSetTryParams(ptr, primed, triggered) {
        this.invoke('_sbs_set_try_params', [ptr, primed, triggered]);
    }
    sbsGetMethodGetTriggeredTryParam(ptr) {
        return this.invoke('_sbs_get_triggered_try_param', [ptr]);
    }
    sbsGetMethodCodePos(ptr) {
        const resp = this.extractString(this.invoke('_sbs_get_code_pos', [ptr]));
        const parts = resp.split(':');
        return {
            hash: parts[0],
            offset: parseInt(parts[1]),
        };
    }
    sbsGetMethodResult(ptr) {
        const resp = JSON.parse(this.extractString(this.invoke('_sbs_get_method_result', [ptr])));
        const debugLogs = this.debugLogs.join('\n');
        return {
            output: resp,
            logs: 'BLOCKCHAIN LOGS ARE NOT AVAILABLE IN DEBUGGER BETA',
            debugLogs,
        };
    }
    sbsTransactionSetup(args) {
        const emptr = this.invoke('_create_emulator', [args.config, verbosityToNum[args.verbosity]]);
        const params = runCommonArgsToInternalParams(args);
        this.debugLogs = [];
        const res = this.invoke('_emulate_sbs', [
            emptr,
            args.libs?.toBoc().toString('base64') ?? 0,
            args.shardAccount,
            args.message.toBoc().toString('base64'),
            JSON.stringify(params),
        ]);
        return { res, emptr };
    }
    destroyEmulator(ptr) {
        this.invoke('_destroy_emulator', [ptr]);
    }
    sbsTransactionStep(ptr) {
        const res = this.invoke('_em_sbs_step', [ptr]);
        return res !== 0;
    }
    sbsTransactionCodePos(ptr) {
        const resp = this.extractString(this.invoke('_em_sbs_code_pos', [ptr]));
        const parts = resp.split(':');
        return {
            hash: parts[0],
            offset: parseInt(parts[1]),
        };
    }
    sbsTransactionStack(ptr) {
        const resp = this.extractString(this.invoke('_em_sbs_stack', [ptr]));
        return (0, core_1.parseTuple)(core_1.Cell.fromBase64(resp));
    }
    sbsTransactionC7(ptr) {
        const resp = this.extractString(this.invoke('_em_sbs_c7', [ptr]));
        return (0, core_1.parseTuple)((0, core_1.beginCell)().storeUint(1, 24).storeRef(core_1.Cell.EMPTY).storeSlice(core_1.Cell.fromBase64(resp).beginParse()).endCell())[0];
    }
    sbsTransactionGetContDistinguisher(ptr) {
        return this.invoke('_em_sbs_get_cont_distinguisher', [ptr]);
    }
    sbsTransactionSetContDistinguishers(ptr, distinguisher, trueDistinguisher, falseDistinguisher) {
        this.invoke('_em_sbs_set_cont_distinguishers', [ptr, distinguisher, trueDistinguisher, falseDistinguisher]);
    }
    sbsTransactionGetContDistinguisherTriggered(ptr) {
        return this.invoke('_em_sbs_get_cont_distinguisher_triggered', [ptr]) !== 0;
    }
    sbsTransactionSetTryParams(ptr, primed, triggered) {
        this.invoke('_em_sbs_set_try_params', [ptr, primed, triggered]);
    }
    sbsTransactionGetTriggeredTryParam(ptr) {
        return this.invoke('_em_sbs_get_triggered_try_param', [ptr]);
    }
    sbsTransactionResult(ptr) {
        const result = JSON.parse(this.extractString(this.invoke('_em_sbs_result', [ptr])));
        const debugLogs = this.debugLogs.join('\n');
        return {
            result: result.success
                ? {
                    success: true,
                    transaction: result.transaction,
                    shardAccount: result.shard_account,
                    vmLog: result.vm_log,
                    actions: result.actions,
                }
                : {
                    success: false,
                    error: result.error,
                    vmResults: 'vm_log' in result
                        ? {
                            vmLog: result.vm_log,
                            vmExitCode: result.vm_exit_code,
                        }
                        : undefined,
                },
            logs: 'BLOCKCHAIN LOGS ARE NOT AVAILABLE IN DEBUGGER BETA',
            debugLogs,
        };
    }
    extractString(ptr) {
        const str = this.module.UTF8ToString(ptr);
        this.module._free(ptr);
        return str;
    }
    getVersion() {
        const v = JSON.parse(this.extractString(this.invoke('_version', [])));
        return {
            commitHash: v.emulatorLibCommitHash,
            commitDate: v.emulatorLibCommitDate,
        };
    }
}
exports.Executor = Executor;
