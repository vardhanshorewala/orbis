/// <reference types="node" />
import { Address, Cell, Message, ContractProvider, Contract, Sender, ShardAccount, TupleItem, ExternalAddress, StateInit, OpenedContract } from '@ton/core';
import { IExecutor, Executor, TickOrTock, PrevBlocksInfo } from '../executor/Executor';
import { BlockchainStorage } from './BlockchainStorage';
import { Event } from '../event/Event';
import { SandboxContractProvider } from './BlockchainContractProvider';
import { TreasuryContract } from '../treasury/Treasury';
import { GetMethodParams, LogsVerbosity, MessageParams, SmartContract, SmartContractSnapshot, SmartContractTransaction, Verbosity } from './SmartContract';
import { AsyncLock } from '../utils/AsyncLock';
import { ContractsMeta } from '../meta/ContractsMeta';
export type ExternalOutInfo = {
    type: 'external-out';
    src: Address;
    dest?: ExternalAddress;
    createdAt: number;
    createdLt: bigint;
};
export type ExternalOut = {
    info: ExternalOutInfo;
    init?: StateInit;
    body: Cell;
};
export type BlockchainTransaction = SmartContractTransaction & {
    events: Event[];
    parent?: BlockchainTransaction;
    children: BlockchainTransaction[];
    externals: ExternalOut[];
    mode?: number;
};
/**
 * @type SendMessageResult Represents the result of sending a message.
 * @property {BlockchainTransaction[]} transactions Array of blockchain transactions.
 * @property {Event[]} events Array of blockchain events.
 * @property {ExternalOut[]} externals - Array of external messages.
 */
export type SendMessageResult = {
    transactions: BlockchainTransaction[];
    events: Event[];
    externals: ExternalOut[];
};
type ExtendsContractProvider<T> = T extends ContractProvider ? true : T extends SandboxContractProvider ? true : false;
export declare const SANDBOX_CONTRACT_SYMBOL: unique symbol;
/**
 * @type SandboxContract Represents a sandbox contract.
 * @template F Type parameter representing the original contract object.
 */
export type SandboxContract<F> = {
    [P in keyof F]: P extends `${'get' | 'is'}${string}` ? F[P] extends (x: infer CP, ...args: infer P) => infer R ? ExtendsContractProvider<CP> extends true ? (...args: P) => R : never : never : P extends `send${string}` ? F[P] extends (x: infer CP, ...args: infer P) => infer R ? ExtendsContractProvider<CP> extends true ? (...args: P) => Promise<SendMessageResult & {
        result: R extends Promise<infer PR> ? PR : R;
    }> : never : never : F[P];
};
/**
 * Provide way to check if contract is in sandbox environment.
 * @param contract Any open contract
 * @throws Error if contract not a sandbox contract
 */
export declare function toSandboxContract<T>(contract: OpenedContract<T>): SandboxContract<T>;
export type PendingMessage = (({
    type: 'message';
    mode?: number;
} & Message) | {
    type: 'ticktock';
    which: TickOrTock;
    on: Address;
}) & {
    parentTransaction?: BlockchainTransaction;
};
/**
 * @type TreasuryParams Parameters for configuring a treasury contract.
 * @property {number} workchain The workchain ID of the treasury.
 * @property {boolean} predeploy If set the treasury will be deployed on the moment of creation.
 * @property {bigint} balance Initial balance of the treasury. If omitted 1_000_000 is used.
 * @property {boolean} resetBalanceIfZero If set and treasury balance is zero on moment of calling method it reset balance to {@link balance}.
 */
export type TreasuryParams = Partial<{
    workchain: number;
    predeploy: boolean;
    balance: bigint;
    resetBalanceIfZero: boolean;
}>;
export type BlockchainConfig = Cell | 'default' | 'slim';
export type BlockchainSnapshot = {
    contracts: SmartContractSnapshot[];
    networkConfig: string;
    lt: bigint;
    time?: number;
    verbosity: LogsVerbosity;
    libs?: Cell;
    nextCreateWalletIndex: number;
    prevBlocksInfo?: PrevBlocksInfo;
    randomSeed?: Buffer;
};
export declare class Blockchain {
    protected storage: BlockchainStorage;
    protected networkConfig: string;
    protected currentLt: bigint;
    protected currentTime?: number;
    protected messageQueue: PendingMessage[];
    protected logsVerbosity: LogsVerbosity;
    protected globalLibs?: Cell;
    protected lock: AsyncLock;
    protected contractFetches: Map<string, Promise<SmartContract>>;
    protected nextCreateWalletIndex: number;
    protected shouldRecordStorage: boolean;
    protected meta?: ContractsMeta;
    protected prevBlocksInfo?: PrevBlocksInfo;
    protected randomSeed?: Buffer;
    protected shouldDebug: boolean;
    readonly executor: IExecutor;
    protected debuggerExecutor?: Executor;
    getDebuggerExecutor(): Promise<Executor>;
    /**
     * Saves snapshot of current blockchain.
     * @example
     * const snapshot = blockchain.snapshot();
     * // some operations
     * await blockchain.loadFrom(snapshot); // restores blockchain state
     */
    snapshot(): BlockchainSnapshot;
    /**
     * Restores blockchain state from snapshot.
     * Usage provided in {@link Blockchain#snapshot}.
     *
     * @param snapshot Snapshot of blockchain
     */
    loadFrom(snapshot: BlockchainSnapshot): Promise<void>;
    get recordStorage(): boolean;
    /**
     * If set to `true`, [BlockchainTransaction]{@link BlockchainTransaction} will have `oldStorage` and `newStorage` fields.
     *
     * Note that enabling this flag will disable a certain optimization, which will slow down contract emulation
     *
     * @param v
     */
    set recordStorage(v: boolean);
    get debug(): boolean;
    set debug(value: boolean);
    /**
     * @returns Current time in blockchain
     */
    get now(): number | undefined;
    /**
     * Updates Current time in blockchain.
     * @param now UNIX time to set
     */
    set now(now: number | undefined);
    /**
     * @returns Current logical time in blockchain
     */
    get lt(): bigint;
    protected constructor(opts: {
        executor: IExecutor;
        config?: BlockchainConfig;
        storage: BlockchainStorage;
        meta?: ContractsMeta;
    });
    /**
     * @returns Config used in blockchain.
     */
    get config(): Cell;
    /**
     * @returns Config used in blockchain in base64 format.
     */
    get configBase64(): string;
    /**
     * @returns Current PrevBlocksInfo
     */
    get prevBlocks(): PrevBlocksInfo | undefined;
    /**
     * Sets PrevBlocksInfo.
     * @param value PrevBlocksInfo to set
     */
    set prevBlocks(value: PrevBlocksInfo | undefined);
    /**
     * @returns The current random seed
     */
    get random(): Buffer | undefined;
    /**
     * Sets the random seed
     * @param value A Buffer containing the new random seed
     */
    set random(value: Buffer | undefined);
    /**
     * Generates and sets a new random seed using secure random bytes.
     */
    randomize(): Promise<Buffer>;
    /**
     * Emulates the result of sending a message to this Blockchain. Emulates the whole chain of transactions before returning the result. Each transaction increases lt by 1000000.
     *
     * @param message Message to send
     * @param params Optional params
     * @returns Result of queue processing
     *
     * @example
     * const result = await blockchain.sendMessage(internal({
     *      from: sender.address,
     *      to: address,
     *      value: toNano('1'),
     *      body: beginCell().storeUint(0, 32).endCell(),
     * }));
     */
    sendMessage(message: Message | Cell, params?: MessageParams): Promise<SendMessageResult>;
    /**
     * Starts emulating the result of sending a message to this Blockchain (refer to {@link sendMessage}). Each iterator call emulates one transaction, so the whole chain is not emulated immediately, unlike in {@link sendMessage}.
     *
     * @param message Message to send
     * @param params Optional params
     * @returns Async iterable of {@link BlockchainTransaction}
     *
     * @example
     * const message = internal({
     *     from: sender.address,
     *     to: address,
     *     value: toNano('1'),
     *     body: beginCell().storeUint(0, 32).endCell(),
     * }, { randomSeed: crypto.randomBytes(32) });
     * for await (const tx of await blockchain.sendMessageIter(message)) {
     *     // process transaction
     * }
     */
    sendMessageIter(message: Message | Cell, params?: MessageParams): Promise<AsyncIterator<BlockchainTransaction> & AsyncIterable<BlockchainTransaction>>;
    /**
     * Runs tick or tock transaction.
     *
     * @param on Address or addresses to run tick-tock
     * @param which Type of transaction (tick or tock)
     * @param [params] Params to run tick tock transaction
     * @returns Result of tick-tock transaction
     *
     * @example
     * let res = await blockchain.runTickTock(address, 'tock');
     */
    runTickTock(on: Address | Address[], which: TickOrTock, params?: MessageParams): Promise<SendMessageResult>;
    /**
     * Runs get method on contract.
     *
     * @param address Address or addresses to run get method
     * @param method MethodId or method name to run
     * @param stack Method params
     * @param [params] Params to run get method
     * @returns Result of get method
     *
     * @example
     * const { stackReader } = await blockchain.runGetMethod(address, 'get_now', [], {
     *     now: 2,
     * });
     * const now = res.stackReader.readNumber();
     */
    runGetMethod(address: Address, method: number | string, stack?: TupleItem[], params?: GetMethodParams): Promise<import("./SmartContract").GetMethodResult>;
    protected pushMessage(message: Message | Cell): Promise<void>;
    protected pushTickTock(on: Address, which: TickOrTock): Promise<void>;
    protected runQueue(params?: MessageParams): Promise<SendMessageResult>;
    protected txIter(needsLocking: boolean, params?: MessageParams): AsyncIterator<BlockchainTransaction> & AsyncIterable<BlockchainTransaction>;
    protected processInternal(params?: MessageParams): Promise<IteratorResult<BlockchainTransaction>>;
    protected processTx(needsLocking: boolean, params?: MessageParams): Promise<IteratorResult<BlockchainTransaction>>;
    protected processQueue(params?: MessageParams): Promise<BlockchainTransaction[]>;
    /**
     * Creates new {@link ContractProvider} for contract address.
     *
     * @param address Address to create contract provider for
     * @param init Initial state of contract
     *
     * @example
     * const contractProvider = blockchain.provider(address, init);
     */
    provider(address: Address, init?: StateInit | null): ContractProvider;
    /**
     * Creates {@link Sender} for address.
     *
     * Note, that this sender pushes internal messages to Blockchain directly.
     * No value is deducted from sender address, all the values are set to defaults. Use for test purposes only.
     *
     * @example
     * const sender = this.sender(address);
     * await contract.send(sender, ...);
     *
     * @param address Address to create sender for
     */
    sender(address: Address): Sender;
    protected treasuryParamsToMapKey(workchain: number, seed: string): string;
    /**
     * Creates treasury wallet contract. This wallet is used as alternative to wallet smart contract.
     *
     * @param {string} seed Initial seed for treasury. If the same seed is used to create a treasury, then these treasuries will be identical
     * @param {TreasuryParams} params Params for treasury creation. See {@link TreasuryParams} for more information.
     *
     * @example
     * const wallet = await blockchain.treasury('wallet')
     * await wallet.send({
     *     to: someAddress,
     *     value: toNano('0.5'),
     * });
     */
    treasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>>;
    /**
     * Bulk variant of {@link treasury}.
     * @param n Number of wallets to create
     * @param params Params for treasury creation. See {@link TreasuryParams} for more information.
     * @returns Array of opened treasury contracts
     *
     * @example
     * const [wallet1, wallet2, wallet3] = await blockchain.createWallets(3);
     */
    createWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]>;
    /**
     * Opens contract. Returns proxy that substitutes the blockchain Provider in methods starting with get and set.
     *
     * @param contract Contract to open.
     *
     * @example
     * const contract = blockchain.openContract(new Contract(address));
     */
    openContract<T extends Contract>(contract: T): SandboxContract<T>;
    protected startFetchingContract(address: Address): Promise<SmartContract>;
    /**
     * Retrieves {@link SmartContract} from {@link BlockchainStorage}.
     * @param address Address of contract to get
     */
    getContract(address: Address): Promise<SmartContract>;
    /**
     * @returns {LogsVerbosity} level
     */
    get verbosity(): LogsVerbosity;
    /**
     * Updates logs verbosity level.
     * @param {LogsVerbosity} value
     */
    set verbosity(value: LogsVerbosity);
    /**
     * Updates logs verbosity level for address.
     */
    setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void>;
    /**
     * Updates blockchain config
     *
     * @param {BlockchainConfig} config - Custom config in Cell format, or predefined `default` | `slim`
     */
    setConfig(config: BlockchainConfig): void;
    setShardAccount(address: Address, account: ShardAccount): Promise<void>;
    /**
     * Retrieves global libs cell
     */
    get libs(): Cell | undefined;
    /**
     * Update global blockchain libs.
     *
     * @param value Cell in libs format: Dictionary<CellHash, Cell>
     *
     * @example
     * const code = await compile('Contract');
     *
     * const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell());
     * libsDict.set(code.hash(), code);
     *
     * blockchain.libs = beginCell().storeDictDirect(libsDict).endCell();
     */
    set libs(value: Cell | undefined);
    /**
     * Creates instance of sandbox blockchain.
     *
     * @param [opts.executor] Custom contract executor. If omitted {@link Executor} is used.
     * @param [opts.config] Config used in blockchain. If omitted {@link defaultConfig} is used.
     * @param [opts.storage] Contracts storage used for blockchain. If omitted {@link LocalBlockchainStorage} is used.
     * @param [opts.meta] Optional contracts metadata provider. If not provided, {@link @ton/test-utils.contractsMeta} will be used to accumulate contracts metadata.
     * @example
     * const blockchain = await Blockchain.create({ config: 'slim' });
     *
     * @example Remote storage
     * let client = new TonClient4({
     *     endpoint: 'https://mainnet-v4.tonhubapi.com'
     * })
     *
     * let blockchain = await Blockchain.create({
     *     storage: new RemoteBlockchainStorage(wrapTonClient4ForRemote(client), 34892000)
     * });
     */
    static create(opts?: {
        executor?: IExecutor;
        config?: BlockchainConfig;
        storage?: BlockchainStorage;
        meta?: ContractsMeta;
    }): Promise<Blockchain>;
}
export {};
