"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfigVotingSetup = exports.storeConfigProposalSetup = exports.loadConfigProposalSetup = exports.storeGlobalVersion = exports.loadGlobalVersion = exports.storeBurningConfig = exports.loadBurningConfig = exports.storeConfigParam = exports.loadConfigParam = exports.storeValidatorSet = exports.loadValidatorSet = exports.storeValidatorDescr = exports.loadValidatorDescr = exports.storeSignedCertificate = exports.loadSignedCertificate = exports.storeCertificate = exports.loadCertificate = exports.storeCryptoSignature = exports.loadCryptoSignature = exports.storeCryptoSignatureSimple = exports.loadCryptoSignatureSimple = exports.storeSigPubKey = exports.loadSigPubKey = exports.storeExtraCurrencyCollection = exports.loadExtraCurrencyCollection = exports.storeCoins = exports.loadCoins = exports.storeUnary = exports.loadUnary = exports.unary_unary_succ_get_n = exports.storeHmLabel = exports.loadHmLabel = exports.hmLabel_hml_short_get_n = exports.storeHashmapNode = exports.loadHashmapNode = exports.storeHashmap = exports.loadHashmap = exports.hashmap_get_l = exports.storeMaybe = exports.loadMaybe = exports.storeTrue = exports.loadTrue = exports.storeUnit = exports.loadUnit = exports.copyCellToBuilder = exports.loadBoolTrue = exports.loadBoolFalse = exports.storeBool = exports.loadBool = exports.bitLen = void 0;
exports.storeJettonBridgeParams = exports.loadJettonBridgeParams = exports.storeJettonBridgePrices = exports.loadJettonBridgePrices = exports.storeOracleBridgeParams = exports.loadOracleBridgeParams = exports.storePrecompiledContractsConfig = exports.loadPrecompiledContractsConfig = exports.storePrecompiledSmc = exports.loadPrecompiledSmc = exports.storeSuspendedAddressList = exports.loadSuspendedAddressList = exports.storeSizeLimitsConfig = exports.loadSizeLimitsConfig = exports.storeMisbehaviourPunishmentConfig = exports.loadMisbehaviourPunishmentConfig = exports.storeValidatorSignedTempKey = exports.loadValidatorSignedTempKey = exports.storeValidatorTempKey = exports.loadValidatorTempKey = exports.storeConsensusConfig = exports.loadConsensusConfig = exports.storeCatchainConfig = exports.loadCatchainConfig = exports.storeMsgForwardPrices = exports.loadMsgForwardPrices = exports.storeBlockLimits = exports.loadBlockLimits = exports.storeParamLimits = exports.loadParamLimits = exports.storeGasLimitsPrices = exports.loadGasLimitsPrices = exports.storeStoragePrices = exports.loadStoragePrices = exports.storeBlockCreateFees = exports.loadBlockCreateFees = exports.storeComplaintPricing = exports.loadComplaintPricing = exports.storeWorkchainDescr = exports.loadWorkchainDescr = exports.storeWcSplitMergeTimings = exports.loadWcSplitMergeTimings = exports.storeWorkchainFormat = exports.loadWorkchainFormat = exports.storeConfigProposalStatus = exports.loadConfigProposalStatus = exports.storeConfigProposal = exports.loadConfigProposal = exports.storeConfigVotingSetup = void 0;
const core_1 = require("@ton/core");
const core_2 = require("@ton/core");
function bitLen(n) {
    return n.toString(2).length;
}
exports.bitLen = bitLen;
function loadBool(slice) {
    if (slice.remainingBits >= 1) {
        let value = slice.loadUint(1);
        return {
            kind: 'Bool',
            value: value == 1
        };
    }
    throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}
exports.loadBool = loadBool;
function storeBool(bool) {
    return ((builder) => {
        builder.storeUint(bool.value ? 1 : 0, 1);
    });
}
exports.storeBool = storeBool;
function loadBoolFalse(slice) {
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
        slice.loadUint(1);
        return {
            kind: 'Bool',
            value: false
        };
    }
    throw new Error('Expected one of "BoolFalse" in loading "BoolFalse", but data does not satisfy any constructor');
}
exports.loadBoolFalse = loadBoolFalse;
function loadBoolTrue(slice) {
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
        slice.loadUint(1);
        return {
            kind: 'Bool',
            value: true
        };
    }
    throw new Error('Expected one of "BoolTrue" in loading "BoolTrue", but data does not satisfy any constructor');
}
exports.loadBoolTrue = loadBoolTrue;
function copyCellToBuilder(from, to) {
    let slice = from.beginParse();
    to.storeBits(slice.loadBits(slice.remainingBits));
    while (slice.remainingRefs) {
        to.storeRef(slice.loadRef());
    }
}
exports.copyCellToBuilder = copyCellToBuilder;
// unit$_ = Unit;
function loadUnit(slice) {
    return {
        kind: 'Unit',
    };
}
exports.loadUnit = loadUnit;
function storeUnit(unit) {
    return ((builder) => {
    });
}
exports.storeUnit = storeUnit;
// true$_ = True;
function loadTrue(slice) {
    return {
        kind: 'True',
    };
}
exports.loadTrue = loadTrue;
function storeTrue(true0) {
    return ((builder) => {
    });
}
exports.storeTrue = storeTrue;
// nothing$0 {X:Type} = Maybe X;
// just$1 {X:Type} value:X = Maybe X;
function loadMaybe(slice, loadX) {
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
        slice.loadUint(1);
        return {
            kind: 'Maybe_nothing',
        };
    }
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
        slice.loadUint(1);
        let value = loadX(slice);
        return {
            kind: 'Maybe_just',
            value: value,
        };
    }
    throw new Error('Expected one of "Maybe_nothing", "Maybe_just" in loading "Maybe", but data does not satisfy any constructor');
}
exports.loadMaybe = loadMaybe;
function storeMaybe(maybe, storeX) {
    if ((maybe.kind == 'Maybe_nothing')) {
        return ((builder) => {
            builder.storeUint(0b0, 1);
        });
    }
    if ((maybe.kind == 'Maybe_just')) {
        return ((builder) => {
            builder.storeUint(0b1, 1);
            storeX(maybe.value)(builder);
        });
    }
    throw new Error('Expected one of "Maybe_nothing", "Maybe_just" in loading "Maybe", but data does not satisfy any constructor');
}
exports.storeMaybe = storeMaybe;
function hashmap_get_l(label) {
    if ((label.kind == 'HmLabel_hml_short')) {
        let n = label.n;
        return n;
    }
    if ((label.kind == 'HmLabel_hml_long')) {
        let n = label.n;
        return n;
    }
    if ((label.kind == 'HmLabel_hml_same')) {
        let n = label.n;
        return n;
    }
    throw new Error('Expected one of "HmLabel_hml_short", "HmLabel_hml_long", "HmLabel_hml_same" for type "HmLabel" while getting "label", but data does not satisfy any constructor');
}
exports.hashmap_get_l = hashmap_get_l;
/*
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n)
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;
*/
function loadHashmap(slice, n, loadX) {
    let label = loadHmLabel(slice, n);
    let l = hashmap_get_l(label);
    let node = loadHashmapNode(slice, (n - l), loadX);
    return {
        kind: 'Hashmap',
        n: n,
        m: (n - l),
        label: label,
        l: l,
        node: node,
    };
}
exports.loadHashmap = loadHashmap;
function storeHashmap(hashmap, storeX) {
    return ((builder) => {
        storeHmLabel(hashmap.label)(builder);
        storeHashmapNode(hashmap.node, storeX)(builder);
    });
}
exports.storeHashmap = storeHashmap;
// hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
/*
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X)
           right:^(Hashmap n X) = HashmapNode (n + 1) X;
*/
function loadHashmapNode(slice, arg0, loadX) {
    if ((arg0 == 0)) {
        let value = loadX(slice);
        return {
            kind: 'HashmapNode_hmn_leaf',
            value: value,
        };
    }
    if (true) {
        let slice1 = slice.loadRef().beginParse(true);
        let left = loadHashmap(slice1, (arg0 - 1), loadX);
        let slice2 = slice.loadRef().beginParse(true);
        let right = loadHashmap(slice2, (arg0 - 1), loadX);
        return {
            kind: 'HashmapNode_hmn_fork',
            n: (arg0 - 1),
            left: left,
            right: right,
        };
    }
    throw new Error('Expected one of "HashmapNode_hmn_leaf", "HashmapNode_hmn_fork" in loading "HashmapNode", but data does not satisfy any constructor');
}
exports.loadHashmapNode = loadHashmapNode;
function storeHashmapNode(hashmapNode, storeX) {
    if ((hashmapNode.kind == 'HashmapNode_hmn_leaf')) {
        return ((builder) => {
            storeX(hashmapNode.value)(builder);
        });
    }
    if ((hashmapNode.kind == 'HashmapNode_hmn_fork')) {
        return ((builder) => {
            let cell1 = (0, core_1.beginCell)();
            storeHashmap(hashmapNode.left, storeX)(cell1);
            builder.storeRef(cell1);
            let cell2 = (0, core_1.beginCell)();
            storeHashmap(hashmapNode.right, storeX)(cell2);
            builder.storeRef(cell2);
        });
    }
    throw new Error('Expected one of "HashmapNode_hmn_leaf", "HashmapNode_hmn_fork" in loading "HashmapNode", but data does not satisfy any constructor');
}
exports.storeHashmapNode = storeHashmapNode;
function hmLabel_hml_short_get_n(len) {
    if ((len.kind == 'Unary_unary_zero')) {
        return 0;
    }
    if ((len.kind == 'Unary_unary_succ')) {
        let n = len.n;
        return (n + 1);
    }
    throw new Error('Expected one of "Unary_unary_zero", "Unary_unary_succ" for type "Unary" while getting "len", but data does not satisfy any constructor');
}
exports.hmLabel_hml_short_get_n = hmLabel_hml_short_get_n;
// hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
// hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
// hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;
function loadHmLabel(slice, m) {
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
        slice.loadUint(1);
        let len = loadUnary(slice);
        let n = hmLabel_hml_short_get_n(len);
        let s = Array.from(Array(n).keys()).map(((arg) => {
            return slice.loadBit();
        }));
        if ((!(n <= m))) {
            throw new Error('Condition (n <= m) is not satisfied while loading "HmLabel_hml_short" for type "HmLabel"');
        }
        return {
            kind: 'HmLabel_hml_short',
            m: m,
            len: len,
            n: n,
            s: s,
        };
    }
    if (((slice.remainingBits >= 2) && (slice.preloadUint(2) == 0b10))) {
        slice.loadUint(2);
        let n = slice.loadUint(bitLen(m));
        let s = Array.from(Array(n).keys()).map(((arg) => {
            return slice.loadBit();
        }));
        return {
            kind: 'HmLabel_hml_long',
            m: m,
            n: n,
            s: s,
        };
    }
    if (((slice.remainingBits >= 2) && (slice.preloadUint(2) == 0b11))) {
        slice.loadUint(2);
        let v = slice.loadBit();
        let n = slice.loadUint(bitLen(m));
        return {
            kind: 'HmLabel_hml_same',
            m: m,
            v: v,
            n: n,
        };
    }
    throw new Error('Expected one of "HmLabel_hml_short", "HmLabel_hml_long", "HmLabel_hml_same" in loading "HmLabel", but data does not satisfy any constructor');
}
exports.loadHmLabel = loadHmLabel;
function storeHmLabel(hmLabel) {
    if ((hmLabel.kind == 'HmLabel_hml_short')) {
        return ((builder) => {
            builder.storeUint(0b0, 1);
            storeUnary(hmLabel.len)(builder);
            hmLabel.s.forEach(((arg) => {
                builder.storeBit(arg);
            }));
            if ((!(hmLabel.n <= hmLabel.m))) {
                throw new Error('Condition (hmLabel.n <= hmLabel.m) is not satisfied while loading "HmLabel_hml_short" for type "HmLabel"');
            }
        });
    }
    if ((hmLabel.kind == 'HmLabel_hml_long')) {
        return ((builder) => {
            builder.storeUint(0b10, 2);
            builder.storeUint(hmLabel.n, bitLen(hmLabel.m));
            hmLabel.s.forEach(((arg) => {
                builder.storeBit(arg);
            }));
        });
    }
    if ((hmLabel.kind == 'HmLabel_hml_same')) {
        return ((builder) => {
            builder.storeUint(0b11, 2);
            builder.storeBit(hmLabel.v);
            builder.storeUint(hmLabel.n, bitLen(hmLabel.m));
        });
    }
    throw new Error('Expected one of "HmLabel_hml_short", "HmLabel_hml_long", "HmLabel_hml_same" in loading "HmLabel", but data does not satisfy any constructor');
}
exports.storeHmLabel = storeHmLabel;
// unary_zero$0 = Unary ~0;
function unary_unary_succ_get_n(x) {
    if ((x.kind == 'Unary_unary_zero')) {
        return 0;
    }
    if ((x.kind == 'Unary_unary_succ')) {
        let n = x.n;
        return (n + 1);
    }
    throw new Error('Expected one of "Unary_unary_zero", "Unary_unary_succ" for type "Unary" while getting "x", but data does not satisfy any constructor');
}
exports.unary_unary_succ_get_n = unary_unary_succ_get_n;
// unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);
function loadUnary(slice) {
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b0))) {
        slice.loadUint(1);
        return {
            kind: 'Unary_unary_zero',
        };
    }
    if (((slice.remainingBits >= 1) && (slice.preloadUint(1) == 0b1))) {
        slice.loadUint(1);
        let x = loadUnary(slice);
        let n = unary_unary_succ_get_n(x);
        return {
            kind: 'Unary_unary_succ',
            x: x,
            n: n,
        };
    }
    throw new Error('Expected one of "Unary_unary_zero", "Unary_unary_succ" in loading "Unary", but data does not satisfy any constructor');
}
exports.loadUnary = loadUnary;
function storeUnary(unary) {
    if ((unary.kind == 'Unary_unary_zero')) {
        return ((builder) => {
            builder.storeUint(0b0, 1);
        });
    }
    if ((unary.kind == 'Unary_unary_succ')) {
        return ((builder) => {
            builder.storeUint(0b1, 1);
            storeUnary(unary.x)(builder);
        });
    }
    throw new Error('Expected one of "Unary_unary_zero", "Unary_unary_succ" in loading "Unary", but data does not satisfy any constructor');
}
exports.storeUnary = storeUnary;
// _ grams:Grams = Coins;
function loadCoins(slice) {
    let grams = slice.loadCoins();
    return {
        kind: 'Coins',
        grams: grams,
    };
}
exports.loadCoins = loadCoins;
function storeCoins(coins) {
    return ((builder) => {
        builder.storeCoins(coins.grams);
    });
}
exports.storeCoins = storeCoins;
/*
extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32))
                 = ExtraCurrencyCollection;
*/
function loadExtraCurrencyCollection(slice) {
    let dict = core_2.Dictionary.load(core_2.Dictionary.Keys.Uint(32), {
        serialize: () => { throw new Error('Not implemented'); },
        parse: ((slice) => {
            return slice.loadVarUintBig(bitLen((32 - 1)));
        }),
    }, slice);
    return {
        kind: 'ExtraCurrencyCollection',
        dict: dict,
    };
}
exports.loadExtraCurrencyCollection = loadExtraCurrencyCollection;
function storeExtraCurrencyCollection(extraCurrencyCollection) {
    return ((builder) => {
        builder.storeDict(extraCurrencyCollection.dict, core_2.Dictionary.Keys.Uint(32), {
            serialize: ((arg, builder) => {
                ((arg) => {
                    return ((builder) => {
                        builder.storeVarUint(arg, bitLen((32 - 1)));
                    });
                })(arg)(builder);
            }),
            parse: () => { throw new Error('Not implemented'); },
        });
    });
}
exports.storeExtraCurrencyCollection = storeExtraCurrencyCollection;
// ed25519_pubkey#8e81278a pubkey:bits256 = SigPubKey;
function loadSigPubKey(slice) {
    if (((slice.remainingBits >= 32) && (slice.preloadUint(32) == 0x8e81278a))) {
        slice.loadUint(32);
        let pubkey = slice.loadBuffer((256 / 8));
        return {
            kind: 'SigPubKey',
            pubkey: pubkey,
        };
    }
    throw new Error('Expected one of "SigPubKey" in loading "SigPubKey", but data does not satisfy any constructor');
}
exports.loadSigPubKey = loadSigPubKey;
function storeSigPubKey(sigPubKey) {
    return ((builder) => {
        builder.storeUint(0x8e81278a, 32);
        builder.storeBuffer(sigPubKey.pubkey, (256 / 8));
    });
}
exports.storeSigPubKey = storeSigPubKey;
// ed25519_signature#5 R:bits256 s:bits256 = CryptoSignatureSimple;
function loadCryptoSignatureSimple(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0x5))) {
        slice.loadUint(4);
        let R = slice.loadBuffer((256 / 8));
        let s = slice.loadBuffer((256 / 8));
        return {
            kind: 'CryptoSignatureSimple',
            R: R,
            s: s,
        };
    }
    throw new Error('Expected one of "CryptoSignatureSimple" in loading "CryptoSignatureSimple", but data does not satisfy any constructor');
}
exports.loadCryptoSignatureSimple = loadCryptoSignatureSimple;
function storeCryptoSignatureSimple(cryptoSignatureSimple) {
    return ((builder) => {
        builder.storeUint(0x5, 4);
        builder.storeBuffer(cryptoSignatureSimple.R, (256 / 8));
        builder.storeBuffer(cryptoSignatureSimple.s, (256 / 8));
    });
}
exports.storeCryptoSignatureSimple = storeCryptoSignatureSimple;
/*
chained_signature#f signed_cert:^SignedCertificate temp_key_signature:CryptoSignatureSimple
  = CryptoSignature;
*/
// _ CryptoSignatureSimple = CryptoSignature;
function loadCryptoSignature(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0xf))) {
        slice.loadUint(4);
        let slice1 = slice.loadRef().beginParse(true);
        let signed_cert = loadSignedCertificate(slice1);
        let temp_key_signature = loadCryptoSignatureSimple(slice);
        return {
            kind: 'CryptoSignature_chained_signature',
            signed_cert: signed_cert,
            temp_key_signature: temp_key_signature,
        };
    }
    if (true) {
        let anon0 = loadCryptoSignatureSimple(slice);
        return {
            kind: 'CryptoSignature__',
            anon0: anon0,
        };
    }
    throw new Error('Expected one of "CryptoSignature_chained_signature", "CryptoSignature__" in loading "CryptoSignature", but data does not satisfy any constructor');
}
exports.loadCryptoSignature = loadCryptoSignature;
function storeCryptoSignature(cryptoSignature) {
    if ((cryptoSignature.kind == 'CryptoSignature_chained_signature')) {
        return ((builder) => {
            builder.storeUint(0xf, 4);
            let cell1 = (0, core_1.beginCell)();
            storeSignedCertificate(cryptoSignature.signed_cert)(cell1);
            builder.storeRef(cell1);
            storeCryptoSignatureSimple(cryptoSignature.temp_key_signature)(builder);
        });
    }
    if ((cryptoSignature.kind == 'CryptoSignature__')) {
        return ((builder) => {
            storeCryptoSignatureSimple(cryptoSignature.anon0)(builder);
        });
    }
    throw new Error('Expected one of "CryptoSignature_chained_signature", "CryptoSignature__" in loading "CryptoSignature", but data does not satisfy any constructor');
}
exports.storeCryptoSignature = storeCryptoSignature;
// certificate#4 temp_key:SigPubKey valid_since:uint32 valid_until:uint32 = Certificate;
function loadCertificate(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0x4))) {
        slice.loadUint(4);
        let temp_key = loadSigPubKey(slice);
        let valid_since = slice.loadUint(32);
        let valid_until = slice.loadUint(32);
        return {
            kind: 'Certificate',
            temp_key: temp_key,
            valid_since: valid_since,
            valid_until: valid_until,
        };
    }
    throw new Error('Expected one of "Certificate" in loading "Certificate", but data does not satisfy any constructor');
}
exports.loadCertificate = loadCertificate;
function storeCertificate(certificate) {
    return ((builder) => {
        builder.storeUint(0x4, 4);
        storeSigPubKey(certificate.temp_key)(builder);
        builder.storeUint(certificate.valid_since, 32);
        builder.storeUint(certificate.valid_until, 32);
    });
}
exports.storeCertificate = storeCertificate;
/*
signed_certificate$_ certificate:Certificate certificate_signature:CryptoSignature
  = SignedCertificate;
*/
function loadSignedCertificate(slice) {
    let certificate = loadCertificate(slice);
    let certificate_signature = loadCryptoSignature(slice);
    return {
        kind: 'SignedCertificate',
        certificate: certificate,
        certificate_signature: certificate_signature,
    };
}
exports.loadSignedCertificate = loadSignedCertificate;
function storeSignedCertificate(signedCertificate) {
    return ((builder) => {
        storeCertificate(signedCertificate.certificate)(builder);
        storeCryptoSignature(signedCertificate.certificate_signature)(builder);
    });
}
exports.storeSignedCertificate = storeSignedCertificate;
// validator#53 public_key:SigPubKey weight:uint64 = ValidatorDescr;
// validator_addr#73 public_key:SigPubKey weight:uint64 adnl_addr:bits256 = ValidatorDescr;
function loadValidatorDescr(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x53))) {
        slice.loadUint(8);
        let public_key = loadSigPubKey(slice);
        let weight = slice.loadUintBig(64);
        return {
            kind: 'ValidatorDescr_validator',
            public_key: public_key,
            weight: weight,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x73))) {
        slice.loadUint(8);
        let public_key = loadSigPubKey(slice);
        let weight = slice.loadUintBig(64);
        let adnl_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ValidatorDescr_validator_addr',
            public_key: public_key,
            weight: weight,
            adnl_addr: adnl_addr,
        };
    }
    throw new Error('Expected one of "ValidatorDescr_validator", "ValidatorDescr_validator_addr" in loading "ValidatorDescr", but data does not satisfy any constructor');
}
exports.loadValidatorDescr = loadValidatorDescr;
function storeValidatorDescr(validatorDescr) {
    if ((validatorDescr.kind == 'ValidatorDescr_validator')) {
        return ((builder) => {
            builder.storeUint(0x53, 8);
            storeSigPubKey(validatorDescr.public_key)(builder);
            builder.storeUint(validatorDescr.weight, 64);
        });
    }
    if ((validatorDescr.kind == 'ValidatorDescr_validator_addr')) {
        return ((builder) => {
            builder.storeUint(0x73, 8);
            storeSigPubKey(validatorDescr.public_key)(builder);
            builder.storeUint(validatorDescr.weight, 64);
            builder.storeBuffer(validatorDescr.adnl_addr, (256 / 8));
        });
    }
    throw new Error('Expected one of "ValidatorDescr_validator", "ValidatorDescr_validator_addr" in loading "ValidatorDescr", but data does not satisfy any constructor');
}
exports.storeValidatorDescr = storeValidatorDescr;
/*
validators#11 utime_since:uint32 utime_until:uint32
  total:(## 16) main:(## 16) { main <= total } { main >= 1 }
  list:(Hashmap 16 ValidatorDescr) = ValidatorSet;
*/
/*
validators_ext#12 utime_since:uint32 utime_until:uint32
  total:(## 16) main:(## 16) { main <= total } { main >= 1 }
  total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;
*/
function loadValidatorSet(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x11))) {
        slice.loadUint(8);
        let utime_since = slice.loadUint(32);
        let utime_until = slice.loadUint(32);
        let total = slice.loadUint(16);
        let main = slice.loadUint(16);
        let list = core_2.Dictionary.loadDirect(core_2.Dictionary.Keys.Uint(16), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadValidatorDescr,
        }, slice);
        if ((!(main <= total))) {
            throw new Error('Condition (main <= total) is not satisfied while loading "ValidatorSet_validators" for type "ValidatorSet"');
        }
        if ((!(main >= 1))) {
            throw new Error('Condition (main >= 1) is not satisfied while loading "ValidatorSet_validators" for type "ValidatorSet"');
        }
        return {
            kind: 'ValidatorSet_validators',
            utime_since: utime_since,
            utime_until: utime_until,
            total: total,
            main: main,
            list: list,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x12))) {
        slice.loadUint(8);
        let utime_since = slice.loadUint(32);
        let utime_until = slice.loadUint(32);
        let total = slice.loadUint(16);
        let main = slice.loadUint(16);
        let total_weight = slice.loadUintBig(64);
        let list = core_2.Dictionary.load(core_2.Dictionary.Keys.Uint(16), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadValidatorDescr,
        }, slice);
        if ((!(main <= total))) {
            throw new Error('Condition (main <= total) is not satisfied while loading "ValidatorSet_validators_ext" for type "ValidatorSet"');
        }
        if ((!(main >= 1))) {
            throw new Error('Condition (main >= 1) is not satisfied while loading "ValidatorSet_validators_ext" for type "ValidatorSet"');
        }
        return {
            kind: 'ValidatorSet_validators_ext',
            utime_since: utime_since,
            utime_until: utime_until,
            total: total,
            main: main,
            total_weight: total_weight,
            list: list,
        };
    }
    throw new Error('Expected one of "ValidatorSet_validators", "ValidatorSet_validators_ext" in loading "ValidatorSet", but data does not satisfy any constructor');
}
exports.loadValidatorSet = loadValidatorSet;
function storeValidatorSet(validatorSet) {
    if ((validatorSet.kind == 'ValidatorSet_validators')) {
        return ((builder) => {
            builder.storeUint(0x11, 8);
            builder.storeUint(validatorSet.utime_since, 32);
            builder.storeUint(validatorSet.utime_until, 32);
            builder.storeUint(validatorSet.total, 16);
            builder.storeUint(validatorSet.main, 16);
            builder.storeDictDirect(validatorSet.list, core_2.Dictionary.Keys.Uint(16), {
                serialize: ((arg, builder) => {
                    storeValidatorDescr(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
            if ((!(validatorSet.main <= validatorSet.total))) {
                throw new Error('Condition (validatorSet.main <= validatorSet.total) is not satisfied while loading "ValidatorSet_validators" for type "ValidatorSet"');
            }
            if ((!(validatorSet.main >= 1))) {
                throw new Error('Condition (validatorSet.main >= 1) is not satisfied while loading "ValidatorSet_validators" for type "ValidatorSet"');
            }
        });
    }
    if ((validatorSet.kind == 'ValidatorSet_validators_ext')) {
        return ((builder) => {
            builder.storeUint(0x12, 8);
            builder.storeUint(validatorSet.utime_since, 32);
            builder.storeUint(validatorSet.utime_until, 32);
            builder.storeUint(validatorSet.total, 16);
            builder.storeUint(validatorSet.main, 16);
            builder.storeUint(validatorSet.total_weight, 64);
            builder.storeDict(validatorSet.list, core_2.Dictionary.Keys.Uint(16), {
                serialize: ((arg, builder) => {
                    storeValidatorDescr(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
            if ((!(validatorSet.main <= validatorSet.total))) {
                throw new Error('Condition (validatorSet.main <= validatorSet.total) is not satisfied while loading "ValidatorSet_validators_ext" for type "ValidatorSet"');
            }
            if ((!(validatorSet.main >= 1))) {
                throw new Error('Condition (validatorSet.main >= 1) is not satisfied while loading "ValidatorSet_validators_ext" for type "ValidatorSet"');
            }
        });
    }
    throw new Error('Expected one of "ValidatorSet_validators", "ValidatorSet_validators_ext" in loading "ValidatorSet", but data does not satisfy any constructor');
}
exports.storeValidatorSet = storeValidatorSet;
// _ config_addr:bits256 = ConfigParam 0;
// _ elector_addr:bits256 = ConfigParam 1;
// _ minter_addr:bits256 = ConfigParam 2;
// _ fee_collector_addr:bits256 = ConfigParam 3;
// _ dns_root_addr:bits256 = ConfigParam 4;
// _ BurningConfig = ConfigParam 5;
// _ mint_new_price:Grams mint_add_price:Grams = ConfigParam 6;
// _ to_mint:ExtraCurrencyCollection = ConfigParam 7;
// _ GlobalVersion = ConfigParam 8;
// _ mandatory_params:(Hashmap 32 True) = ConfigParam 9;
// _ critical_params:(Hashmap 32 True) = ConfigParam 10;
// _ ConfigVotingSetup = ConfigParam 11;
// _ workchains:(HashmapE 32 WorkchainDescr) = ConfigParam 12;
// _ ComplaintPricing = ConfigParam 13;
// _ BlockCreateFees = ConfigParam 14;
/*
_ validators_elected_for:uint32 elections_start_before:uint32
  elections_end_before:uint32 stake_held_for:uint32
  = ConfigParam 15;
*/
/*
_ max_validators:(## 16) max_main_validators:(## 16) min_validators:(## 16)
  { max_validators >= max_main_validators }
  { max_main_validators >= min_validators }
  { min_validators >= 1 }
  = ConfigParam 16;
*/
// _ min_stake:Grams max_stake:Grams min_total_stake:Grams max_stake_factor:uint32 = ConfigParam 17;
// _ (Hashmap 32 StoragePrices) = ConfigParam 18;
// _ global_id:int32 = ConfigParam 19;
// config_mc_gas_prices#_ GasLimitsPrices = ConfigParam 20;
// config_gas_prices#_ GasLimitsPrices = ConfigParam 21;
// config_mc_block_limits#_ BlockLimits = ConfigParam 22;
// config_block_limits#_ BlockLimits = ConfigParam 23;
// config_mc_fwd_prices#_ MsgForwardPrices = ConfigParam 24;
// config_fwd_prices#_ MsgForwardPrices = ConfigParam 25;
// _ CatchainConfig = ConfigParam 28;
// _ ConsensusConfig = ConfigParam 29;
// _ fundamental_smc_addr:(HashmapE 256 True) = ConfigParam 31;
// _ prev_validators:ValidatorSet = ConfigParam 32;
// _ prev_temp_validators:ValidatorSet = ConfigParam 33;
// _ cur_validators:ValidatorSet = ConfigParam 34;
// _ cur_temp_validators:ValidatorSet = ConfigParam 35;
// _ next_validators:ValidatorSet = ConfigParam 36;
// _ next_temp_validators:ValidatorSet = ConfigParam 37;
// _ (HashmapE 256 ValidatorSignedTempKey) = ConfigParam 39;
// _ MisbehaviourPunishmentConfig = ConfigParam 40;
// _ SizeLimitsConfig = ConfigParam 43;
// _ SuspendedAddressList = ConfigParam 44;
// _ PrecompiledContractsConfig = ConfigParam 45;
// _ OracleBridgeParams = ConfigParam 71;
// _ OracleBridgeParams = ConfigParam 72;
// _ OracleBridgeParams = ConfigParam 73;
// _ JettonBridgeParams = ConfigParam 79;
// _ JettonBridgeParams = ConfigParam 81;
// _ JettonBridgeParams = ConfigParam 82;
function loadConfigParam(slice, arg0) {
    if ((arg0 == 0)) {
        let config_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ConfigParam__',
            config_addr: config_addr,
        };
    }
    if ((arg0 == 1)) {
        let elector_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ConfigParam__1',
            elector_addr: elector_addr,
        };
    }
    if ((arg0 == 2)) {
        let minter_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ConfigParam__2',
            minter_addr: minter_addr,
        };
    }
    if ((arg0 == 3)) {
        let fee_collector_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ConfigParam__3',
            fee_collector_addr: fee_collector_addr,
        };
    }
    if ((arg0 == 4)) {
        let dns_root_addr = slice.loadBuffer((256 / 8));
        return {
            kind: 'ConfigParam__4',
            dns_root_addr: dns_root_addr,
        };
    }
    if ((arg0 == 5)) {
        let anon0 = loadBurningConfig(slice);
        return {
            kind: 'ConfigParam__5',
            anon0: anon0,
        };
    }
    if ((arg0 == 6)) {
        let mint_new_price = slice.loadCoins();
        let mint_add_price = slice.loadCoins();
        return {
            kind: 'ConfigParam__6',
            mint_new_price: mint_new_price,
            mint_add_price: mint_add_price,
        };
    }
    if ((arg0 == 7)) {
        let to_mint = loadExtraCurrencyCollection(slice);
        return {
            kind: 'ConfigParam__7',
            to_mint: to_mint,
        };
    }
    if ((arg0 == 8)) {
        let anon0 = loadGlobalVersion(slice);
        return {
            kind: 'ConfigParam__8',
            anon0: anon0,
        };
    }
    if ((arg0 == 9)) {
        let mandatory_params = core_2.Dictionary.loadDirect(core_2.Dictionary.Keys.Uint(32), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadTrue,
        }, slice);
        return {
            kind: 'ConfigParam__9',
            mandatory_params: mandatory_params,
        };
    }
    if ((arg0 == 10)) {
        let critical_params = core_2.Dictionary.loadDirect(core_2.Dictionary.Keys.Uint(32), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadTrue,
        }, slice);
        return {
            kind: 'ConfigParam__10',
            critical_params: critical_params,
        };
    }
    if ((arg0 == 11)) {
        let anon0 = loadConfigVotingSetup(slice);
        return {
            kind: 'ConfigParam__11',
            anon0: anon0,
        };
    }
    if ((arg0 == 12)) {
        let workchains = core_2.Dictionary.load(core_2.Dictionary.Keys.Uint(32), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadWorkchainDescr,
        }, slice);
        return {
            kind: 'ConfigParam__12',
            workchains: workchains,
        };
    }
    if ((arg0 == 13)) {
        let anon0 = loadComplaintPricing(slice);
        return {
            kind: 'ConfigParam__13',
            anon0: anon0,
        };
    }
    if ((arg0 == 14)) {
        let anon0 = loadBlockCreateFees(slice);
        return {
            kind: 'ConfigParam__14',
            anon0: anon0,
        };
    }
    if ((arg0 == 15)) {
        let validators_elected_for = slice.loadUint(32);
        let elections_start_before = slice.loadUint(32);
        let elections_end_before = slice.loadUint(32);
        let stake_held_for = slice.loadUint(32);
        return {
            kind: 'ConfigParam__15',
            validators_elected_for: validators_elected_for,
            elections_start_before: elections_start_before,
            elections_end_before: elections_end_before,
            stake_held_for: stake_held_for,
        };
    }
    if ((arg0 == 16)) {
        let max_validators = slice.loadUint(16);
        let max_main_validators = slice.loadUint(16);
        let min_validators = slice.loadUint(16);
        if ((!(max_validators >= max_main_validators))) {
            throw new Error('Condition (max_validators >= max_main_validators) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
        }
        if ((!(max_main_validators >= min_validators))) {
            throw new Error('Condition (max_main_validators >= min_validators) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
        }
        if ((!(min_validators >= 1))) {
            throw new Error('Condition (min_validators >= 1) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
        }
        return {
            kind: 'ConfigParam__16',
            max_validators: max_validators,
            max_main_validators: max_main_validators,
            min_validators: min_validators,
        };
    }
    if ((arg0 == 17)) {
        let min_stake = slice.loadCoins();
        let max_stake = slice.loadCoins();
        let min_total_stake = slice.loadCoins();
        let max_stake_factor = slice.loadUint(32);
        return {
            kind: 'ConfigParam__17',
            min_stake: min_stake,
            max_stake: max_stake,
            min_total_stake: min_total_stake,
            max_stake_factor: max_stake_factor,
        };
    }
    if ((arg0 == 18)) {
        let anon0 = core_2.Dictionary.loadDirect(core_2.Dictionary.Keys.Uint(32), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadStoragePrices,
        }, slice);
        return {
            kind: 'ConfigParam__18',
            anon0: anon0,
        };
    }
    if ((arg0 == 19)) {
        let global_id = slice.loadInt(32);
        return {
            kind: 'ConfigParam__19',
            global_id: global_id,
        };
    }
    if ((arg0 == 20)) {
        let anon0 = loadGasLimitsPrices(slice);
        return {
            kind: 'ConfigParam_config_mc_gas_prices',
            anon0: anon0,
        };
    }
    if ((arg0 == 21)) {
        let anon0 = loadGasLimitsPrices(slice);
        return {
            kind: 'ConfigParam_config_gas_prices',
            anon0: anon0,
        };
    }
    if ((arg0 == 22)) {
        let anon0 = loadBlockLimits(slice);
        return {
            kind: 'ConfigParam_config_mc_block_limits',
            anon0: anon0,
        };
    }
    if ((arg0 == 23)) {
        let anon0 = loadBlockLimits(slice);
        return {
            kind: 'ConfigParam_config_block_limits',
            anon0: anon0,
        };
    }
    if ((arg0 == 24)) {
        let anon0 = loadMsgForwardPrices(slice);
        return {
            kind: 'ConfigParam_config_mc_fwd_prices',
            anon0: anon0,
        };
    }
    if ((arg0 == 25)) {
        let anon0 = loadMsgForwardPrices(slice);
        return {
            kind: 'ConfigParam_config_fwd_prices',
            anon0: anon0,
        };
    }
    if ((arg0 == 28)) {
        let anon0 = loadCatchainConfig(slice);
        return {
            kind: 'ConfigParam__26',
            anon0: anon0,
        };
    }
    if ((arg0 == 29)) {
        let anon0 = loadConsensusConfig(slice);
        return {
            kind: 'ConfigParam__27',
            anon0: anon0,
        };
    }
    if ((arg0 == 31)) {
        let fundamental_smc_addr = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadTrue,
        }, slice);
        return {
            kind: 'ConfigParam__28',
            fundamental_smc_addr: fundamental_smc_addr,
        };
    }
    if ((arg0 == 32)) {
        let prev_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__29',
            prev_validators: prev_validators,
        };
    }
    if ((arg0 == 33)) {
        let prev_temp_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__30',
            prev_temp_validators: prev_temp_validators,
        };
    }
    if ((arg0 == 34)) {
        let cur_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__31',
            cur_validators: cur_validators,
        };
    }
    if ((arg0 == 35)) {
        let cur_temp_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__32',
            cur_temp_validators: cur_temp_validators,
        };
    }
    if ((arg0 == 36)) {
        let next_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__33',
            next_validators: next_validators,
        };
    }
    if ((arg0 == 37)) {
        let next_temp_validators = loadValidatorSet(slice);
        return {
            kind: 'ConfigParam__34',
            next_temp_validators: next_temp_validators,
        };
    }
    if ((arg0 == 39)) {
        let anon0 = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadValidatorSignedTempKey,
        }, slice);
        return {
            kind: 'ConfigParam__35',
            anon0: anon0,
        };
    }
    if ((arg0 == 40)) {
        let anon0 = loadMisbehaviourPunishmentConfig(slice);
        return {
            kind: 'ConfigParam__36',
            anon0: anon0,
        };
    }
    if ((arg0 == 43)) {
        let anon0 = loadSizeLimitsConfig(slice);
        return {
            kind: 'ConfigParam__37',
            anon0: anon0,
        };
    }
    if ((arg0 == 44)) {
        let anon0 = loadSuspendedAddressList(slice);
        return {
            kind: 'ConfigParam__38',
            anon0: anon0,
        };
    }
    if ((arg0 == 45)) {
        let anon0 = loadPrecompiledContractsConfig(slice);
        return {
            kind: 'ConfigParam__39',
            anon0: anon0,
        };
    }
    if ((arg0 == 71)) {
        let anon0 = loadOracleBridgeParams(slice);
        return {
            kind: 'ConfigParam__40',
            anon0: anon0,
        };
    }
    if ((arg0 == 72)) {
        let anon0 = loadOracleBridgeParams(slice);
        return {
            kind: 'ConfigParam__41',
            anon0: anon0,
        };
    }
    if ((arg0 == 73)) {
        let anon0 = loadOracleBridgeParams(slice);
        return {
            kind: 'ConfigParam__42',
            anon0: anon0,
        };
    }
    if ((arg0 == 79)) {
        let anon0 = loadJettonBridgeParams(slice);
        return {
            kind: 'ConfigParam__43',
            anon0: anon0,
        };
    }
    if ((arg0 == 81)) {
        let anon0 = loadJettonBridgeParams(slice);
        return {
            kind: 'ConfigParam__44',
            anon0: anon0,
        };
    }
    if ((arg0 == 82)) {
        let anon0 = loadJettonBridgeParams(slice);
        return {
            kind: 'ConfigParam__45',
            anon0: anon0,
        };
    }
    throw new Error('Expected one of "ConfigParam__", "ConfigParam__1", "ConfigParam__2", "ConfigParam__3", "ConfigParam__4", "ConfigParam__5", "ConfigParam__6", "ConfigParam__7", "ConfigParam__8", "ConfigParam__9", "ConfigParam__10", "ConfigParam__11", "ConfigParam__12", "ConfigParam__13", "ConfigParam__14", "ConfigParam__15", "ConfigParam__16", "ConfigParam__17", "ConfigParam__18", "ConfigParam__19", "ConfigParam_config_mc_gas_prices", "ConfigParam_config_gas_prices", "ConfigParam_config_mc_block_limits", "ConfigParam_config_block_limits", "ConfigParam_config_mc_fwd_prices", "ConfigParam_config_fwd_prices", "ConfigParam__26", "ConfigParam__27", "ConfigParam__28", "ConfigParam__29", "ConfigParam__30", "ConfigParam__31", "ConfigParam__32", "ConfigParam__33", "ConfigParam__34", "ConfigParam__35", "ConfigParam__36", "ConfigParam__37", "ConfigParam__38", "ConfigParam__39", "ConfigParam__40", "ConfigParam__41", "ConfigParam__42", "ConfigParam__43", "ConfigParam__44", "ConfigParam__45" in loading "ConfigParam", but data does not satisfy any constructor');
}
exports.loadConfigParam = loadConfigParam;
function storeConfigParam(configParam) {
    if ((configParam.kind == 'ConfigParam__')) {
        return ((builder) => {
            builder.storeBuffer(configParam.config_addr, (256 / 8));
        });
    }
    if ((configParam.kind == 'ConfigParam__1')) {
        return ((builder) => {
            builder.storeBuffer(configParam.elector_addr, (256 / 8));
        });
    }
    if ((configParam.kind == 'ConfigParam__2')) {
        return ((builder) => {
            builder.storeBuffer(configParam.minter_addr, (256 / 8));
        });
    }
    if ((configParam.kind == 'ConfigParam__3')) {
        return ((builder) => {
            builder.storeBuffer(configParam.fee_collector_addr, (256 / 8));
        });
    }
    if ((configParam.kind == 'ConfigParam__4')) {
        return ((builder) => {
            builder.storeBuffer(configParam.dns_root_addr, (256 / 8));
        });
    }
    if ((configParam.kind == 'ConfigParam__5')) {
        return ((builder) => {
            storeBurningConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__6')) {
        return ((builder) => {
            builder.storeCoins(configParam.mint_new_price);
            builder.storeCoins(configParam.mint_add_price);
        });
    }
    if ((configParam.kind == 'ConfigParam__7')) {
        return ((builder) => {
            storeExtraCurrencyCollection(configParam.to_mint)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__8')) {
        return ((builder) => {
            storeGlobalVersion(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__9')) {
        return ((builder) => {
            builder.storeDictDirect(configParam.mandatory_params, core_2.Dictionary.Keys.Uint(32), {
                serialize: ((arg, builder) => {
                    storeTrue(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__10')) {
        return ((builder) => {
            builder.storeDictDirect(configParam.critical_params, core_2.Dictionary.Keys.Uint(32), {
                serialize: ((arg, builder) => {
                    storeTrue(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__11')) {
        return ((builder) => {
            storeConfigVotingSetup(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__12')) {
        return ((builder) => {
            builder.storeDict(configParam.workchains, core_2.Dictionary.Keys.Uint(32), {
                serialize: ((arg, builder) => {
                    storeWorkchainDescr(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__13')) {
        return ((builder) => {
            storeComplaintPricing(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__14')) {
        return ((builder) => {
            storeBlockCreateFees(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__15')) {
        return ((builder) => {
            builder.storeUint(configParam.validators_elected_for, 32);
            builder.storeUint(configParam.elections_start_before, 32);
            builder.storeUint(configParam.elections_end_before, 32);
            builder.storeUint(configParam.stake_held_for, 32);
        });
    }
    if ((configParam.kind == 'ConfigParam__16')) {
        return ((builder) => {
            builder.storeUint(configParam.max_validators, 16);
            builder.storeUint(configParam.max_main_validators, 16);
            builder.storeUint(configParam.min_validators, 16);
            if ((!(configParam.max_validators >= configParam.max_main_validators))) {
                throw new Error('Condition (configParam.max_validators >= configParam.max_main_validators) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
            }
            if ((!(configParam.max_main_validators >= configParam.min_validators))) {
                throw new Error('Condition (configParam.max_main_validators >= configParam.min_validators) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
            }
            if ((!(configParam.min_validators >= 1))) {
                throw new Error('Condition (configParam.min_validators >= 1) is not satisfied while loading "ConfigParam__16" for type "ConfigParam"');
            }
        });
    }
    if ((configParam.kind == 'ConfigParam__17')) {
        return ((builder) => {
            builder.storeCoins(configParam.min_stake);
            builder.storeCoins(configParam.max_stake);
            builder.storeCoins(configParam.min_total_stake);
            builder.storeUint(configParam.max_stake_factor, 32);
        });
    }
    if ((configParam.kind == 'ConfigParam__18')) {
        return ((builder) => {
            builder.storeDictDirect(configParam.anon0, core_2.Dictionary.Keys.Uint(32), {
                serialize: ((arg, builder) => {
                    storeStoragePrices(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__19')) {
        return ((builder) => {
            builder.storeInt(configParam.global_id, 32);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_mc_gas_prices')) {
        return ((builder) => {
            storeGasLimitsPrices(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_gas_prices')) {
        return ((builder) => {
            storeGasLimitsPrices(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_mc_block_limits')) {
        return ((builder) => {
            storeBlockLimits(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_block_limits')) {
        return ((builder) => {
            storeBlockLimits(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_mc_fwd_prices')) {
        return ((builder) => {
            storeMsgForwardPrices(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam_config_fwd_prices')) {
        return ((builder) => {
            storeMsgForwardPrices(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__26')) {
        return ((builder) => {
            storeCatchainConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__27')) {
        return ((builder) => {
            storeConsensusConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__28')) {
        return ((builder) => {
            builder.storeDict(configParam.fundamental_smc_addr, core_2.Dictionary.Keys.BigUint(256), {
                serialize: ((arg, builder) => {
                    storeTrue(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__29')) {
        return ((builder) => {
            storeValidatorSet(configParam.prev_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__30')) {
        return ((builder) => {
            storeValidatorSet(configParam.prev_temp_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__31')) {
        return ((builder) => {
            storeValidatorSet(configParam.cur_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__32')) {
        return ((builder) => {
            storeValidatorSet(configParam.cur_temp_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__33')) {
        return ((builder) => {
            storeValidatorSet(configParam.next_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__34')) {
        return ((builder) => {
            storeValidatorSet(configParam.next_temp_validators)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__35')) {
        return ((builder) => {
            builder.storeDict(configParam.anon0, core_2.Dictionary.Keys.BigUint(256), {
                serialize: ((arg, builder) => {
                    storeValidatorSignedTempKey(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
        });
    }
    if ((configParam.kind == 'ConfigParam__36')) {
        return ((builder) => {
            storeMisbehaviourPunishmentConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__37')) {
        return ((builder) => {
            storeSizeLimitsConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__38')) {
        return ((builder) => {
            storeSuspendedAddressList(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__39')) {
        return ((builder) => {
            storePrecompiledContractsConfig(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__40')) {
        return ((builder) => {
            storeOracleBridgeParams(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__41')) {
        return ((builder) => {
            storeOracleBridgeParams(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__42')) {
        return ((builder) => {
            storeOracleBridgeParams(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__43')) {
        return ((builder) => {
            storeJettonBridgeParams(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__44')) {
        return ((builder) => {
            storeJettonBridgeParams(configParam.anon0)(builder);
        });
    }
    if ((configParam.kind == 'ConfigParam__45')) {
        return ((builder) => {
            storeJettonBridgeParams(configParam.anon0)(builder);
        });
    }
    throw new Error('Expected one of "ConfigParam__", "ConfigParam__1", "ConfigParam__2", "ConfigParam__3", "ConfigParam__4", "ConfigParam__5", "ConfigParam__6", "ConfigParam__7", "ConfigParam__8", "ConfigParam__9", "ConfigParam__10", "ConfigParam__11", "ConfigParam__12", "ConfigParam__13", "ConfigParam__14", "ConfigParam__15", "ConfigParam__16", "ConfigParam__17", "ConfigParam__18", "ConfigParam__19", "ConfigParam_config_mc_gas_prices", "ConfigParam_config_gas_prices", "ConfigParam_config_mc_block_limits", "ConfigParam_config_block_limits", "ConfigParam_config_mc_fwd_prices", "ConfigParam_config_fwd_prices", "ConfigParam__26", "ConfigParam__27", "ConfigParam__28", "ConfigParam__29", "ConfigParam__30", "ConfigParam__31", "ConfigParam__32", "ConfigParam__33", "ConfigParam__34", "ConfigParam__35", "ConfigParam__36", "ConfigParam__37", "ConfigParam__38", "ConfigParam__39", "ConfigParam__40", "ConfigParam__41", "ConfigParam__42", "ConfigParam__43", "ConfigParam__44", "ConfigParam__45" in loading "ConfigParam", but data does not satisfy any constructor');
}
exports.storeConfigParam = storeConfigParam;
/*
burning_config#01
  blackhole_addr:(Maybe bits256)
  fee_burn_num:# fee_burn_denom:# { fee_burn_num <= fee_burn_denom } { fee_burn_denom >= 1 } = BurningConfig;
*/
function loadBurningConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x01))) {
        slice.loadUint(8);
        let blackhole_addr = loadMaybe(slice, ((slice) => {
            return slice.loadBuffer((256 / 8));
        }));
        let fee_burn_num = slice.loadUint(32);
        let fee_burn_denom = slice.loadUint(32);
        if ((!(fee_burn_num <= fee_burn_denom))) {
            throw new Error('Condition (fee_burn_num <= fee_burn_denom) is not satisfied while loading "BurningConfig" for type "BurningConfig"');
        }
        if ((!(fee_burn_denom >= 1))) {
            throw new Error('Condition (fee_burn_denom >= 1) is not satisfied while loading "BurningConfig" for type "BurningConfig"');
        }
        return {
            kind: 'BurningConfig',
            blackhole_addr: blackhole_addr,
            fee_burn_num: fee_burn_num,
            fee_burn_denom: fee_burn_denom,
        };
    }
    throw new Error('Expected one of "BurningConfig" in loading "BurningConfig", but data does not satisfy any constructor');
}
exports.loadBurningConfig = loadBurningConfig;
function storeBurningConfig(burningConfig) {
    return ((builder) => {
        builder.storeUint(0x01, 8);
        storeMaybe(burningConfig.blackhole_addr, ((arg) => {
            return ((builder) => {
                builder.storeBuffer(arg, (256 / 8));
            });
        }))(builder);
        builder.storeUint(burningConfig.fee_burn_num, 32);
        builder.storeUint(burningConfig.fee_burn_denom, 32);
        if ((!(burningConfig.fee_burn_num <= burningConfig.fee_burn_denom))) {
            throw new Error('Condition (burningConfig.fee_burn_num <= burningConfig.fee_burn_denom) is not satisfied while loading "BurningConfig" for type "BurningConfig"');
        }
        if ((!(burningConfig.fee_burn_denom >= 1))) {
            throw new Error('Condition (burningConfig.fee_burn_denom >= 1) is not satisfied while loading "BurningConfig" for type "BurningConfig"');
        }
    });
}
exports.storeBurningConfig = storeBurningConfig;
// capabilities#c4 version:uint32 capabilities:uint64 = GlobalVersion;
function loadGlobalVersion(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xc4))) {
        slice.loadUint(8);
        let version = slice.loadUint(32);
        let capabilities = slice.loadUintBig(64);
        return {
            kind: 'GlobalVersion',
            version: version,
            capabilities: capabilities,
        };
    }
    throw new Error('Expected one of "GlobalVersion" in loading "GlobalVersion", but data does not satisfy any constructor');
}
exports.loadGlobalVersion = loadGlobalVersion;
function storeGlobalVersion(globalVersion) {
    return ((builder) => {
        builder.storeUint(0xc4, 8);
        builder.storeUint(globalVersion.version, 32);
        builder.storeUint(globalVersion.capabilities, 64);
    });
}
exports.storeGlobalVersion = storeGlobalVersion;
// cfg_vote_cfg#36 min_tot_rounds:uint8 max_tot_rounds:uint8 min_wins:uint8 max_losses:uint8 min_store_sec:uint32 max_store_sec:uint32 bit_price:uint32 cell_price:uint32 = ConfigProposalSetup;
function loadConfigProposalSetup(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x36))) {
        slice.loadUint(8);
        let min_tot_rounds = slice.loadUint(8);
        let max_tot_rounds = slice.loadUint(8);
        let min_wins = slice.loadUint(8);
        let max_losses = slice.loadUint(8);
        let min_store_sec = slice.loadUint(32);
        let max_store_sec = slice.loadUint(32);
        let bit_price = slice.loadUint(32);
        let _cell_price = slice.loadUint(32);
        return {
            kind: 'ConfigProposalSetup',
            min_tot_rounds: min_tot_rounds,
            max_tot_rounds: max_tot_rounds,
            min_wins: min_wins,
            max_losses: max_losses,
            min_store_sec: min_store_sec,
            max_store_sec: max_store_sec,
            bit_price: bit_price,
            _cell_price: _cell_price,
        };
    }
    throw new Error('Expected one of "ConfigProposalSetup" in loading "ConfigProposalSetup", but data does not satisfy any constructor');
}
exports.loadConfigProposalSetup = loadConfigProposalSetup;
function storeConfigProposalSetup(configProposalSetup) {
    return ((builder) => {
        builder.storeUint(0x36, 8);
        builder.storeUint(configProposalSetup.min_tot_rounds, 8);
        builder.storeUint(configProposalSetup.max_tot_rounds, 8);
        builder.storeUint(configProposalSetup.min_wins, 8);
        builder.storeUint(configProposalSetup.max_losses, 8);
        builder.storeUint(configProposalSetup.min_store_sec, 32);
        builder.storeUint(configProposalSetup.max_store_sec, 32);
        builder.storeUint(configProposalSetup.bit_price, 32);
        builder.storeUint(configProposalSetup._cell_price, 32);
    });
}
exports.storeConfigProposalSetup = storeConfigProposalSetup;
// cfg_vote_setup#91 normal_params:^ConfigProposalSetup critical_params:^ConfigProposalSetup = ConfigVotingSetup;
function loadConfigVotingSetup(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x91))) {
        slice.loadUint(8);
        let slice1 = slice.loadRef().beginParse(true);
        let normal_params = loadConfigProposalSetup(slice1);
        let slice2 = slice.loadRef().beginParse(true);
        let critical_params = loadConfigProposalSetup(slice2);
        return {
            kind: 'ConfigVotingSetup',
            normal_params: normal_params,
            critical_params: critical_params,
        };
    }
    throw new Error('Expected one of "ConfigVotingSetup" in loading "ConfigVotingSetup", but data does not satisfy any constructor');
}
exports.loadConfigVotingSetup = loadConfigVotingSetup;
function storeConfigVotingSetup(configVotingSetup) {
    return ((builder) => {
        builder.storeUint(0x91, 8);
        let cell1 = (0, core_1.beginCell)();
        storeConfigProposalSetup(configVotingSetup.normal_params)(cell1);
        builder.storeRef(cell1);
        let cell2 = (0, core_1.beginCell)();
        storeConfigProposalSetup(configVotingSetup.critical_params)(cell2);
        builder.storeRef(cell2);
    });
}
exports.storeConfigVotingSetup = storeConfigVotingSetup;
/*
cfg_proposal#f3 param_id:int32 param_value:(Maybe ^Cell) if_hash_equal:(Maybe uint256)
  = ConfigProposal;
*/
function loadConfigProposal(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xf3))) {
        slice.loadUint(8);
        let param_id = slice.loadInt(32);
        let param_value = loadMaybe(slice, ((slice) => {
            let slice1 = slice.loadRef().beginParse(true);
            return slice1.asCell();
        }));
        let if_hash_equal = loadMaybe(slice, ((slice) => {
            return slice.loadUintBig(256);
        }));
        return {
            kind: 'ConfigProposal',
            param_id: param_id,
            param_value: param_value,
            if_hash_equal: if_hash_equal,
        };
    }
    throw new Error('Expected one of "ConfigProposal" in loading "ConfigProposal", but data does not satisfy any constructor');
}
exports.loadConfigProposal = loadConfigProposal;
function storeConfigProposal(configProposal) {
    return ((builder) => {
        builder.storeUint(0xf3, 8);
        builder.storeInt(configProposal.param_id, 32);
        storeMaybe(configProposal.param_value, ((arg) => {
            return ((builder) => {
                let cell1 = (0, core_1.beginCell)();
                cell1.storeSlice(arg.beginParse(true));
                builder.storeRef(cell1);
            });
        }))(builder);
        storeMaybe(configProposal.if_hash_equal, ((arg) => {
            return ((builder) => {
                builder.storeUint(arg, 256);
            });
        }))(builder);
    });
}
exports.storeConfigProposal = storeConfigProposal;
/*
cfg_proposal_status#ce expires:uint32 proposal:^ConfigProposal is_critical:Bool
  voters:(HashmapE 16 True) remaining_weight:int64 validator_set_id:uint256
  rounds_remaining:uint8 wins:uint8 losses:uint8 = ConfigProposalStatus;
*/
function loadConfigProposalStatus(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xce))) {
        slice.loadUint(8);
        let expires = slice.loadUint(32);
        let slice1 = slice.loadRef().beginParse(true);
        let proposal = loadConfigProposal(slice1);
        let is_critical = loadBool(slice);
        let voters = core_2.Dictionary.load(core_2.Dictionary.Keys.Uint(16), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadTrue,
        }, slice);
        let remaining_weight = slice.loadIntBig(64);
        let validator_set_id = slice.loadUintBig(256);
        let rounds_remaining = slice.loadUint(8);
        let wins = slice.loadUint(8);
        let losses = slice.loadUint(8);
        return {
            kind: 'ConfigProposalStatus',
            expires: expires,
            proposal: proposal,
            is_critical: is_critical,
            voters: voters,
            remaining_weight: remaining_weight,
            validator_set_id: validator_set_id,
            rounds_remaining: rounds_remaining,
            wins: wins,
            losses: losses,
        };
    }
    throw new Error('Expected one of "ConfigProposalStatus" in loading "ConfigProposalStatus", but data does not satisfy any constructor');
}
exports.loadConfigProposalStatus = loadConfigProposalStatus;
function storeConfigProposalStatus(configProposalStatus) {
    return ((builder) => {
        builder.storeUint(0xce, 8);
        builder.storeUint(configProposalStatus.expires, 32);
        let cell1 = (0, core_1.beginCell)();
        storeConfigProposal(configProposalStatus.proposal)(cell1);
        builder.storeRef(cell1);
        storeBool(configProposalStatus.is_critical)(builder);
        builder.storeDict(configProposalStatus.voters, core_2.Dictionary.Keys.Uint(16), {
            serialize: ((arg, builder) => {
                storeTrue(arg)(builder);
            }),
            parse: () => { throw new Error('Not implemented'); },
        });
        builder.storeInt(configProposalStatus.remaining_weight, 64);
        builder.storeUint(configProposalStatus.validator_set_id, 256);
        builder.storeUint(configProposalStatus.rounds_remaining, 8);
        builder.storeUint(configProposalStatus.wins, 8);
        builder.storeUint(configProposalStatus.losses, 8);
    });
}
exports.storeConfigProposalStatus = storeConfigProposalStatus;
// wfmt_basic#1 vm_version:int32 vm_mode:uint64 = WorkchainFormat 1;
/*
wfmt_ext#0 min_addr_len:(## 12) max_addr_len:(## 12) addr_len_step:(## 12)
  { min_addr_len >= 64 } { min_addr_len <= max_addr_len }
  { max_addr_len <= 1023 } { addr_len_step <= 1023 }
  workchain_type_id:(## 32) { workchain_type_id >= 1 }
  = WorkchainFormat 0;
*/
function loadWorkchainFormat(slice, arg0) {
    if (((slice.remainingBits >= 4) && ((slice.preloadUint(4) == 0x1) && (arg0 == 1)))) {
        slice.loadUint(4);
        let vm_version = slice.loadInt(32);
        let vm_mode = slice.loadUintBig(64);
        return {
            kind: 'WorkchainFormat_wfmt_basic',
            vm_version: vm_version,
            vm_mode: vm_mode,
        };
    }
    if (((slice.remainingBits >= 4) && ((slice.preloadUint(4) == 0x0) && (arg0 == 0)))) {
        slice.loadUint(4);
        let min_addr_len = slice.loadUint(12);
        let max_addr_len = slice.loadUint(12);
        let addr_len_step = slice.loadUint(12);
        let workchain_type_id = slice.loadUint(32);
        if ((!(min_addr_len >= 64))) {
            throw new Error('Condition (min_addr_len >= 64) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
        }
        if ((!(min_addr_len <= max_addr_len))) {
            throw new Error('Condition (min_addr_len <= max_addr_len) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
        }
        if ((!(max_addr_len <= 1023))) {
            throw new Error('Condition (max_addr_len <= 1023) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
        }
        if ((!(addr_len_step <= 1023))) {
            throw new Error('Condition (addr_len_step <= 1023) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
        }
        if ((!(workchain_type_id >= 1))) {
            throw new Error('Condition (workchain_type_id >= 1) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
        }
        return {
            kind: 'WorkchainFormat_wfmt_ext',
            min_addr_len: min_addr_len,
            max_addr_len: max_addr_len,
            addr_len_step: addr_len_step,
            workchain_type_id: workchain_type_id,
        };
    }
    throw new Error('Expected one of "WorkchainFormat_wfmt_basic", "WorkchainFormat_wfmt_ext" in loading "WorkchainFormat", but data does not satisfy any constructor');
}
exports.loadWorkchainFormat = loadWorkchainFormat;
function storeWorkchainFormat(workchainFormat) {
    if ((workchainFormat.kind == 'WorkchainFormat_wfmt_basic')) {
        return ((builder) => {
            builder.storeUint(0x1, 4);
            builder.storeInt(workchainFormat.vm_version, 32);
            builder.storeUint(workchainFormat.vm_mode, 64);
        });
    }
    if ((workchainFormat.kind == 'WorkchainFormat_wfmt_ext')) {
        return ((builder) => {
            builder.storeUint(0x0, 4);
            builder.storeUint(workchainFormat.min_addr_len, 12);
            builder.storeUint(workchainFormat.max_addr_len, 12);
            builder.storeUint(workchainFormat.addr_len_step, 12);
            builder.storeUint(workchainFormat.workchain_type_id, 32);
            if ((!(workchainFormat.min_addr_len >= 64))) {
                throw new Error('Condition (workchainFormat.min_addr_len >= 64) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
            }
            if ((!(workchainFormat.min_addr_len <= workchainFormat.max_addr_len))) {
                throw new Error('Condition (workchainFormat.min_addr_len <= workchainFormat.max_addr_len) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
            }
            if ((!(workchainFormat.max_addr_len <= 1023))) {
                throw new Error('Condition (workchainFormat.max_addr_len <= 1023) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
            }
            if ((!(workchainFormat.addr_len_step <= 1023))) {
                throw new Error('Condition (workchainFormat.addr_len_step <= 1023) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
            }
            if ((!(workchainFormat.workchain_type_id >= 1))) {
                throw new Error('Condition (workchainFormat.workchain_type_id >= 1) is not satisfied while loading "WorkchainFormat_wfmt_ext" for type "WorkchainFormat"');
            }
        });
    }
    throw new Error('Expected one of "WorkchainFormat_wfmt_basic", "WorkchainFormat_wfmt_ext" in loading "WorkchainFormat", but data does not satisfy any constructor');
}
exports.storeWorkchainFormat = storeWorkchainFormat;
/*
wc_split_merge_timings#0
  split_merge_delay:uint32 split_merge_interval:uint32
  min_split_merge_interval:uint32 max_split_merge_delay:uint32
  = WcSplitMergeTimings;
*/
function loadWcSplitMergeTimings(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0x0))) {
        slice.loadUint(4);
        let split_merge_delay = slice.loadUint(32);
        let split_merge_interval = slice.loadUint(32);
        let min_split_merge_interval = slice.loadUint(32);
        let max_split_merge_delay = slice.loadUint(32);
        return {
            kind: 'WcSplitMergeTimings',
            split_merge_delay: split_merge_delay,
            split_merge_interval: split_merge_interval,
            min_split_merge_interval: min_split_merge_interval,
            max_split_merge_delay: max_split_merge_delay,
        };
    }
    throw new Error('Expected one of "WcSplitMergeTimings" in loading "WcSplitMergeTimings", but data does not satisfy any constructor');
}
exports.loadWcSplitMergeTimings = loadWcSplitMergeTimings;
function storeWcSplitMergeTimings(wcSplitMergeTimings) {
    return ((builder) => {
        builder.storeUint(0x0, 4);
        builder.storeUint(wcSplitMergeTimings.split_merge_delay, 32);
        builder.storeUint(wcSplitMergeTimings.split_merge_interval, 32);
        builder.storeUint(wcSplitMergeTimings.min_split_merge_interval, 32);
        builder.storeUint(wcSplitMergeTimings.max_split_merge_delay, 32);
    });
}
exports.storeWcSplitMergeTimings = storeWcSplitMergeTimings;
/*
workchain#a6 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  = WorkchainDescr;
*/
/*
workchain_v2#a7 enabled_since:uint32 monitor_min_split:(## 8)
  min_split:(## 8) max_split:(## 8) { monitor_min_split <= min_split }
  basic:(## 1) active:Bool accept_msgs:Bool flags:(## 13) { flags = 0 }
  zerostate_root_hash:bits256 zerostate_file_hash:bits256
  version:uint32 format:(WorkchainFormat basic)
  split_merge_timings:WcSplitMergeTimings
  = WorkchainDescr;
*/
function loadWorkchainDescr(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xa6))) {
        slice.loadUint(8);
        let enabled_since = slice.loadUint(32);
        let monitor_min_split = slice.loadUint(8);
        let min_split = slice.loadUint(8);
        let max_split = slice.loadUint(8);
        let basic = slice.loadUint(1);
        let active = loadBool(slice);
        let accept_msgs = loadBool(slice);
        let flags = slice.loadUint(13);
        let zerostate_root_hash = slice.loadBuffer((256 / 8));
        let zerostate_file_hash = slice.loadBuffer((256 / 8));
        let version = slice.loadUint(32);
        let format = loadWorkchainFormat(slice, basic);
        if ((!(monitor_min_split <= min_split))) {
            throw new Error('Condition (monitor_min_split <= min_split) is not satisfied while loading "WorkchainDescr_workchain" for type "WorkchainDescr"');
        }
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "WorkchainDescr_workchain" for type "WorkchainDescr"');
        }
        return {
            kind: 'WorkchainDescr_workchain',
            enabled_since: enabled_since,
            monitor_min_split: monitor_min_split,
            min_split: min_split,
            max_split: max_split,
            basic: basic,
            active: active,
            accept_msgs: accept_msgs,
            flags: flags,
            zerostate_root_hash: zerostate_root_hash,
            zerostate_file_hash: zerostate_file_hash,
            version: version,
            format: format,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xa7))) {
        slice.loadUint(8);
        let enabled_since = slice.loadUint(32);
        let monitor_min_split = slice.loadUint(8);
        let min_split = slice.loadUint(8);
        let max_split = slice.loadUint(8);
        let basic = slice.loadUint(1);
        let active = loadBool(slice);
        let accept_msgs = loadBool(slice);
        let flags = slice.loadUint(13);
        let zerostate_root_hash = slice.loadBuffer((256 / 8));
        let zerostate_file_hash = slice.loadBuffer((256 / 8));
        let version = slice.loadUint(32);
        let format = loadWorkchainFormat(slice, basic);
        let split_merge_timings = loadWcSplitMergeTimings(slice);
        if ((!(monitor_min_split <= min_split))) {
            throw new Error('Condition (monitor_min_split <= min_split) is not satisfied while loading "WorkchainDescr_workchain_v2" for type "WorkchainDescr"');
        }
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "WorkchainDescr_workchain_v2" for type "WorkchainDescr"');
        }
        return {
            kind: 'WorkchainDescr_workchain_v2',
            enabled_since: enabled_since,
            monitor_min_split: monitor_min_split,
            min_split: min_split,
            max_split: max_split,
            basic: basic,
            active: active,
            accept_msgs: accept_msgs,
            flags: flags,
            zerostate_root_hash: zerostate_root_hash,
            zerostate_file_hash: zerostate_file_hash,
            version: version,
            format: format,
            split_merge_timings: split_merge_timings,
        };
    }
    throw new Error('Expected one of "WorkchainDescr_workchain", "WorkchainDescr_workchain_v2" in loading "WorkchainDescr", but data does not satisfy any constructor');
}
exports.loadWorkchainDescr = loadWorkchainDescr;
function storeWorkchainDescr(workchainDescr) {
    if ((workchainDescr.kind == 'WorkchainDescr_workchain')) {
        return ((builder) => {
            builder.storeUint(0xa6, 8);
            builder.storeUint(workchainDescr.enabled_since, 32);
            builder.storeUint(workchainDescr.monitor_min_split, 8);
            builder.storeUint(workchainDescr.min_split, 8);
            builder.storeUint(workchainDescr.max_split, 8);
            builder.storeUint(workchainDescr.basic, 1);
            storeBool(workchainDescr.active)(builder);
            storeBool(workchainDescr.accept_msgs)(builder);
            builder.storeUint(workchainDescr.flags, 13);
            builder.storeBuffer(workchainDescr.zerostate_root_hash, (256 / 8));
            builder.storeBuffer(workchainDescr.zerostate_file_hash, (256 / 8));
            builder.storeUint(workchainDescr.version, 32);
            storeWorkchainFormat(workchainDescr.format)(builder);
            if ((!(workchainDescr.monitor_min_split <= workchainDescr.min_split))) {
                throw new Error('Condition (workchainDescr.monitor_min_split <= workchainDescr.min_split) is not satisfied while loading "WorkchainDescr_workchain" for type "WorkchainDescr"');
            }
            if ((!(workchainDescr.flags == 0))) {
                throw new Error('Condition (workchainDescr.flags == 0) is not satisfied while loading "WorkchainDescr_workchain" for type "WorkchainDescr"');
            }
        });
    }
    if ((workchainDescr.kind == 'WorkchainDescr_workchain_v2')) {
        return ((builder) => {
            builder.storeUint(0xa7, 8);
            builder.storeUint(workchainDescr.enabled_since, 32);
            builder.storeUint(workchainDescr.monitor_min_split, 8);
            builder.storeUint(workchainDescr.min_split, 8);
            builder.storeUint(workchainDescr.max_split, 8);
            builder.storeUint(workchainDescr.basic, 1);
            storeBool(workchainDescr.active)(builder);
            storeBool(workchainDescr.accept_msgs)(builder);
            builder.storeUint(workchainDescr.flags, 13);
            builder.storeBuffer(workchainDescr.zerostate_root_hash, (256 / 8));
            builder.storeBuffer(workchainDescr.zerostate_file_hash, (256 / 8));
            builder.storeUint(workchainDescr.version, 32);
            storeWorkchainFormat(workchainDescr.format)(builder);
            storeWcSplitMergeTimings(workchainDescr.split_merge_timings)(builder);
            if ((!(workchainDescr.monitor_min_split <= workchainDescr.min_split))) {
                throw new Error('Condition (workchainDescr.monitor_min_split <= workchainDescr.min_split) is not satisfied while loading "WorkchainDescr_workchain_v2" for type "WorkchainDescr"');
            }
            if ((!(workchainDescr.flags == 0))) {
                throw new Error('Condition (workchainDescr.flags == 0) is not satisfied while loading "WorkchainDescr_workchain_v2" for type "WorkchainDescr"');
            }
        });
    }
    throw new Error('Expected one of "WorkchainDescr_workchain", "WorkchainDescr_workchain_v2" in loading "WorkchainDescr", but data does not satisfy any constructor');
}
exports.storeWorkchainDescr = storeWorkchainDescr;
// complaint_prices#1a deposit:Grams bit_price:Grams cell_price:Grams = ComplaintPricing;
function loadComplaintPricing(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x1a))) {
        slice.loadUint(8);
        let deposit = slice.loadCoins();
        let bit_price = slice.loadCoins();
        let _cell_price = slice.loadCoins();
        return {
            kind: 'ComplaintPricing',
            deposit: deposit,
            bit_price: bit_price,
            _cell_price: _cell_price,
        };
    }
    throw new Error('Expected one of "ComplaintPricing" in loading "ComplaintPricing", but data does not satisfy any constructor');
}
exports.loadComplaintPricing = loadComplaintPricing;
function storeComplaintPricing(complaintPricing) {
    return ((builder) => {
        builder.storeUint(0x1a, 8);
        builder.storeCoins(complaintPricing.deposit);
        builder.storeCoins(complaintPricing.bit_price);
        builder.storeCoins(complaintPricing._cell_price);
    });
}
exports.storeComplaintPricing = storeComplaintPricing;
/*
block_grams_created#6b masterchain_block_fee:Grams basechain_block_fee:Grams
  = BlockCreateFees;
*/
function loadBlockCreateFees(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x6b))) {
        slice.loadUint(8);
        let masterchain_block_fee = slice.loadCoins();
        let basechain_block_fee = slice.loadCoins();
        return {
            kind: 'BlockCreateFees',
            masterchain_block_fee: masterchain_block_fee,
            basechain_block_fee: basechain_block_fee,
        };
    }
    throw new Error('Expected one of "BlockCreateFees" in loading "BlockCreateFees", but data does not satisfy any constructor');
}
exports.loadBlockCreateFees = loadBlockCreateFees;
function storeBlockCreateFees(blockCreateFees) {
    return ((builder) => {
        builder.storeUint(0x6b, 8);
        builder.storeCoins(blockCreateFees.masterchain_block_fee);
        builder.storeCoins(blockCreateFees.basechain_block_fee);
    });
}
exports.storeBlockCreateFees = storeBlockCreateFees;
/*
_#cc utime_since:uint32 bit_price_ps:uint64 cell_price_ps:uint64
  mc_bit_price_ps:uint64 mc_cell_price_ps:uint64 = StoragePrices;
*/
function loadStoragePrices(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xcc))) {
        slice.loadUint(8);
        let utime_since = slice.loadUint(32);
        let bit_price_ps = slice.loadUintBig(64);
        let _cell_price_ps = slice.loadUintBig(64);
        let mc_bit_price_ps = slice.loadUintBig(64);
        let mc_cell_price_ps = slice.loadUintBig(64);
        return {
            kind: 'StoragePrices',
            utime_since: utime_since,
            bit_price_ps: bit_price_ps,
            _cell_price_ps: _cell_price_ps,
            mc_bit_price_ps: mc_bit_price_ps,
            mc_cell_price_ps: mc_cell_price_ps,
        };
    }
    throw new Error('Expected one of "StoragePrices" in loading "StoragePrices", but data does not satisfy any constructor');
}
exports.loadStoragePrices = loadStoragePrices;
function storeStoragePrices(storagePrices) {
    return ((builder) => {
        builder.storeUint(0xcc, 8);
        builder.storeUint(storagePrices.utime_since, 32);
        builder.storeUint(storagePrices.bit_price_ps, 64);
        builder.storeUint(storagePrices._cell_price_ps, 64);
        builder.storeUint(storagePrices.mc_bit_price_ps, 64);
        builder.storeUint(storagePrices.mc_cell_price_ps, 64);
    });
}
exports.storeStoragePrices = storeStoragePrices;
/*
gas_prices#dd gas_price:uint64 gas_limit:uint64 gas_credit:uint64
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64
  = GasLimitsPrices;
*/
/*
gas_prices_ext#de gas_price:uint64 gas_limit:uint64 special_gas_limit:uint64 gas_credit:uint64
  block_gas_limit:uint64 freeze_due_limit:uint64 delete_due_limit:uint64
  = GasLimitsPrices;
*/
/*
gas_flat_pfx#d1 flat_gas_limit:uint64 flat_gas_price:uint64 other:GasLimitsPrices
  = GasLimitsPrices;
*/
function loadGasLimitsPrices(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xdd))) {
        slice.loadUint(8);
        let gas_price = slice.loadUintBig(64);
        let gas_limit = slice.loadUintBig(64);
        let gas_credit = slice.loadUintBig(64);
        let block_gas_limit = slice.loadUintBig(64);
        let freeze_due_limit = slice.loadUintBig(64);
        let delete_due_limit = slice.loadUintBig(64);
        return {
            kind: 'GasLimitsPrices_gas_prices',
            gas_price: gas_price,
            gas_limit: gas_limit,
            gas_credit: gas_credit,
            block_gas_limit: block_gas_limit,
            freeze_due_limit: freeze_due_limit,
            delete_due_limit: delete_due_limit,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xde))) {
        slice.loadUint(8);
        let gas_price = slice.loadUintBig(64);
        let gas_limit = slice.loadUintBig(64);
        let special_gas_limit = slice.loadUintBig(64);
        let gas_credit = slice.loadUintBig(64);
        let block_gas_limit = slice.loadUintBig(64);
        let freeze_due_limit = slice.loadUintBig(64);
        let delete_due_limit = slice.loadUintBig(64);
        return {
            kind: 'GasLimitsPrices_gas_prices_ext',
            gas_price: gas_price,
            gas_limit: gas_limit,
            special_gas_limit: special_gas_limit,
            gas_credit: gas_credit,
            block_gas_limit: block_gas_limit,
            freeze_due_limit: freeze_due_limit,
            delete_due_limit: delete_due_limit,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xd1))) {
        slice.loadUint(8);
        let flat_gas_limit = slice.loadUintBig(64);
        let flat_gas_price = slice.loadUintBig(64);
        let other = loadGasLimitsPrices(slice);
        return {
            kind: 'GasLimitsPrices_gas_flat_pfx',
            flat_gas_limit: flat_gas_limit,
            flat_gas_price: flat_gas_price,
            other: other,
        };
    }
    throw new Error('Expected one of "GasLimitsPrices_gas_prices", "GasLimitsPrices_gas_prices_ext", "GasLimitsPrices_gas_flat_pfx" in loading "GasLimitsPrices", but data does not satisfy any constructor');
}
exports.loadGasLimitsPrices = loadGasLimitsPrices;
function storeGasLimitsPrices(gasLimitsPrices) {
    if ((gasLimitsPrices.kind == 'GasLimitsPrices_gas_prices')) {
        return ((builder) => {
            builder.storeUint(0xdd, 8);
            builder.storeUint(gasLimitsPrices.gas_price, 64);
            builder.storeUint(gasLimitsPrices.gas_limit, 64);
            builder.storeUint(gasLimitsPrices.gas_credit, 64);
            builder.storeUint(gasLimitsPrices.block_gas_limit, 64);
            builder.storeUint(gasLimitsPrices.freeze_due_limit, 64);
            builder.storeUint(gasLimitsPrices.delete_due_limit, 64);
        });
    }
    if ((gasLimitsPrices.kind == 'GasLimitsPrices_gas_prices_ext')) {
        return ((builder) => {
            builder.storeUint(0xde, 8);
            builder.storeUint(gasLimitsPrices.gas_price, 64);
            builder.storeUint(gasLimitsPrices.gas_limit, 64);
            builder.storeUint(gasLimitsPrices.special_gas_limit, 64);
            builder.storeUint(gasLimitsPrices.gas_credit, 64);
            builder.storeUint(gasLimitsPrices.block_gas_limit, 64);
            builder.storeUint(gasLimitsPrices.freeze_due_limit, 64);
            builder.storeUint(gasLimitsPrices.delete_due_limit, 64);
        });
    }
    if ((gasLimitsPrices.kind == 'GasLimitsPrices_gas_flat_pfx')) {
        return ((builder) => {
            builder.storeUint(0xd1, 8);
            builder.storeUint(gasLimitsPrices.flat_gas_limit, 64);
            builder.storeUint(gasLimitsPrices.flat_gas_price, 64);
            storeGasLimitsPrices(gasLimitsPrices.other)(builder);
        });
    }
    throw new Error('Expected one of "GasLimitsPrices_gas_prices", "GasLimitsPrices_gas_prices_ext", "GasLimitsPrices_gas_flat_pfx" in loading "GasLimitsPrices", but data does not satisfy any constructor');
}
exports.storeGasLimitsPrices = storeGasLimitsPrices;
/*
param_limits#c3 underload:# soft_limit:# { underload <= soft_limit }
  hard_limit:# { soft_limit <= hard_limit } = ParamLimits;
*/
function loadParamLimits(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xc3))) {
        slice.loadUint(8);
        let underload = slice.loadUint(32);
        let soft_limit = slice.loadUint(32);
        let hard_limit = slice.loadUint(32);
        if ((!(underload <= soft_limit))) {
            throw new Error('Condition (underload <= soft_limit) is not satisfied while loading "ParamLimits" for type "ParamLimits"');
        }
        if ((!(soft_limit <= hard_limit))) {
            throw new Error('Condition (soft_limit <= hard_limit) is not satisfied while loading "ParamLimits" for type "ParamLimits"');
        }
        return {
            kind: 'ParamLimits',
            underload: underload,
            soft_limit: soft_limit,
            hard_limit: hard_limit,
        };
    }
    throw new Error('Expected one of "ParamLimits" in loading "ParamLimits", but data does not satisfy any constructor');
}
exports.loadParamLimits = loadParamLimits;
function storeParamLimits(paramLimits) {
    return ((builder) => {
        builder.storeUint(0xc3, 8);
        builder.storeUint(paramLimits.underload, 32);
        builder.storeUint(paramLimits.soft_limit, 32);
        builder.storeUint(paramLimits.hard_limit, 32);
        if ((!(paramLimits.underload <= paramLimits.soft_limit))) {
            throw new Error('Condition (paramLimits.underload <= paramLimits.soft_limit) is not satisfied while loading "ParamLimits" for type "ParamLimits"');
        }
        if ((!(paramLimits.soft_limit <= paramLimits.hard_limit))) {
            throw new Error('Condition (paramLimits.soft_limit <= paramLimits.hard_limit) is not satisfied while loading "ParamLimits" for type "ParamLimits"');
        }
    });
}
exports.storeParamLimits = storeParamLimits;
/*
block_limits#5d bytes:ParamLimits gas:ParamLimits lt_delta:ParamLimits
  = BlockLimits;
*/
function loadBlockLimits(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x5d))) {
        slice.loadUint(8);
        let bytes = loadParamLimits(slice);
        let gas = loadParamLimits(slice);
        let lt_delta = loadParamLimits(slice);
        return {
            kind: 'BlockLimits',
            bytes: bytes,
            gas: gas,
            lt_delta: lt_delta,
        };
    }
    throw new Error('Expected one of "BlockLimits" in loading "BlockLimits", but data does not satisfy any constructor');
}
exports.loadBlockLimits = loadBlockLimits;
function storeBlockLimits(blockLimits) {
    return ((builder) => {
        builder.storeUint(0x5d, 8);
        storeParamLimits(blockLimits.bytes)(builder);
        storeParamLimits(blockLimits.gas)(builder);
        storeParamLimits(blockLimits.lt_delta)(builder);
    });
}
exports.storeBlockLimits = storeBlockLimits;
/*
msg_forward_prices#ea lump_price:uint64 bit_price:uint64 cell_price:uint64
  ihr_price_factor:uint32 first_frac:uint16 next_frac:uint16 = MsgForwardPrices;
*/
function loadMsgForwardPrices(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xea))) {
        slice.loadUint(8);
        let lump_price = slice.loadUintBig(64);
        let bit_price = slice.loadUintBig(64);
        let _cell_price = slice.loadUintBig(64);
        let ihr_price_factor = slice.loadUint(32);
        let first_frac = slice.loadUint(16);
        let next_frac = slice.loadUint(16);
        return {
            kind: 'MsgForwardPrices',
            lump_price: lump_price,
            bit_price: bit_price,
            _cell_price: _cell_price,
            ihr_price_factor: ihr_price_factor,
            first_frac: first_frac,
            next_frac: next_frac,
        };
    }
    throw new Error('Expected one of "MsgForwardPrices" in loading "MsgForwardPrices", but data does not satisfy any constructor');
}
exports.loadMsgForwardPrices = loadMsgForwardPrices;
function storeMsgForwardPrices(msgForwardPrices) {
    return ((builder) => {
        builder.storeUint(0xea, 8);
        builder.storeUint(msgForwardPrices.lump_price, 64);
        builder.storeUint(msgForwardPrices.bit_price, 64);
        builder.storeUint(msgForwardPrices._cell_price, 64);
        builder.storeUint(msgForwardPrices.ihr_price_factor, 32);
        builder.storeUint(msgForwardPrices.first_frac, 16);
        builder.storeUint(msgForwardPrices.next_frac, 16);
    });
}
exports.storeMsgForwardPrices = storeMsgForwardPrices;
/*
catchain_config#c1 mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;
*/
/*
catchain_config_new#c2 flags:(## 7) { flags = 0 } shuffle_mc_validators:Bool
  mc_catchain_lifetime:uint32 shard_catchain_lifetime:uint32
  shard_validators_lifetime:uint32 shard_validators_num:uint32 = CatchainConfig;
*/
function loadCatchainConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xc1))) {
        slice.loadUint(8);
        let mc_catchain_lifetime = slice.loadUint(32);
        let shard_catchain_lifetime = slice.loadUint(32);
        let shard_validators_lifetime = slice.loadUint(32);
        let shard_validators_num = slice.loadUint(32);
        return {
            kind: 'CatchainConfig_catchain_config',
            mc_catchain_lifetime: mc_catchain_lifetime,
            shard_catchain_lifetime: shard_catchain_lifetime,
            shard_validators_lifetime: shard_validators_lifetime,
            shard_validators_num: shard_validators_num,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xc2))) {
        slice.loadUint(8);
        let flags = slice.loadUint(7);
        let shuffle_mc_validators = loadBool(slice);
        let mc_catchain_lifetime = slice.loadUint(32);
        let shard_catchain_lifetime = slice.loadUint(32);
        let shard_validators_lifetime = slice.loadUint(32);
        let shard_validators_num = slice.loadUint(32);
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "CatchainConfig_catchain_config_new" for type "CatchainConfig"');
        }
        return {
            kind: 'CatchainConfig_catchain_config_new',
            flags: flags,
            shuffle_mc_validators: shuffle_mc_validators,
            mc_catchain_lifetime: mc_catchain_lifetime,
            shard_catchain_lifetime: shard_catchain_lifetime,
            shard_validators_lifetime: shard_validators_lifetime,
            shard_validators_num: shard_validators_num,
        };
    }
    throw new Error('Expected one of "CatchainConfig_catchain_config", "CatchainConfig_catchain_config_new" in loading "CatchainConfig", but data does not satisfy any constructor');
}
exports.loadCatchainConfig = loadCatchainConfig;
function storeCatchainConfig(catchainConfig) {
    if ((catchainConfig.kind == 'CatchainConfig_catchain_config')) {
        return ((builder) => {
            builder.storeUint(0xc1, 8);
            builder.storeUint(catchainConfig.mc_catchain_lifetime, 32);
            builder.storeUint(catchainConfig.shard_catchain_lifetime, 32);
            builder.storeUint(catchainConfig.shard_validators_lifetime, 32);
            builder.storeUint(catchainConfig.shard_validators_num, 32);
        });
    }
    if ((catchainConfig.kind == 'CatchainConfig_catchain_config_new')) {
        return ((builder) => {
            builder.storeUint(0xc2, 8);
            builder.storeUint(catchainConfig.flags, 7);
            storeBool(catchainConfig.shuffle_mc_validators)(builder);
            builder.storeUint(catchainConfig.mc_catchain_lifetime, 32);
            builder.storeUint(catchainConfig.shard_catchain_lifetime, 32);
            builder.storeUint(catchainConfig.shard_validators_lifetime, 32);
            builder.storeUint(catchainConfig.shard_validators_num, 32);
            if ((!(catchainConfig.flags == 0))) {
                throw new Error('Condition (catchainConfig.flags == 0) is not satisfied while loading "CatchainConfig_catchain_config_new" for type "CatchainConfig"');
            }
        });
    }
    throw new Error('Expected one of "CatchainConfig_catchain_config", "CatchainConfig_catchain_config_new" in loading "CatchainConfig", but data does not satisfy any constructor');
}
exports.storeCatchainConfig = storeCatchainConfig;
/*
consensus_config#d6 round_candidates:# { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;
*/
/*
consensus_config_new#d7 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32 = ConsensusConfig;
*/
/*
consensus_config_v3#d8 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32
  proto_version:uint16 = ConsensusConfig;
*/
/*
consensus_config_v4#d9 flags:(## 7) { flags = 0 } new_catchain_ids:Bool
  round_candidates:(## 8) { round_candidates >= 1 }
  next_candidate_delay_ms:uint32 consensus_timeout_ms:uint32
  fast_attempts:uint32 attempt_duration:uint32 catchain_max_deps:uint32
  max_block_bytes:uint32 max_collated_bytes:uint32
  proto_version:uint16 catchain_max_blocks_coeff:uint32 = ConsensusConfig;
*/
function loadConsensusConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xd6))) {
        slice.loadUint(8);
        let round_candidates = slice.loadUint(32);
        let next_candidate_delay_ms = slice.loadUint(32);
        let consensus_timeout_ms = slice.loadUint(32);
        let fast_attempts = slice.loadUint(32);
        let attempt_duration = slice.loadUint(32);
        let catchain_max_deps = slice.loadUint(32);
        let max_block_bytes = slice.loadUint(32);
        let max_collated_bytes = slice.loadUint(32);
        if ((!(round_candidates >= 1))) {
            throw new Error('Condition (round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config" for type "ConsensusConfig"');
        }
        return {
            kind: 'ConsensusConfig_consensus_config',
            round_candidates: round_candidates,
            next_candidate_delay_ms: next_candidate_delay_ms,
            consensus_timeout_ms: consensus_timeout_ms,
            fast_attempts: fast_attempts,
            attempt_duration: attempt_duration,
            catchain_max_deps: catchain_max_deps,
            max_block_bytes: max_block_bytes,
            max_collated_bytes: max_collated_bytes,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xd7))) {
        slice.loadUint(8);
        let flags = slice.loadUint(7);
        let new_catchain_ids = loadBool(slice);
        let round_candidates = slice.loadUint(8);
        let next_candidate_delay_ms = slice.loadUint(32);
        let consensus_timeout_ms = slice.loadUint(32);
        let fast_attempts = slice.loadUint(32);
        let attempt_duration = slice.loadUint(32);
        let catchain_max_deps = slice.loadUint(32);
        let max_block_bytes = slice.loadUint(32);
        let max_collated_bytes = slice.loadUint(32);
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_new" for type "ConsensusConfig"');
        }
        if ((!(round_candidates >= 1))) {
            throw new Error('Condition (round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_new" for type "ConsensusConfig"');
        }
        return {
            kind: 'ConsensusConfig_consensus_config_new',
            flags: flags,
            new_catchain_ids: new_catchain_ids,
            round_candidates: round_candidates,
            next_candidate_delay_ms: next_candidate_delay_ms,
            consensus_timeout_ms: consensus_timeout_ms,
            fast_attempts: fast_attempts,
            attempt_duration: attempt_duration,
            catchain_max_deps: catchain_max_deps,
            max_block_bytes: max_block_bytes,
            max_collated_bytes: max_collated_bytes,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xd8))) {
        slice.loadUint(8);
        let flags = slice.loadUint(7);
        let new_catchain_ids = loadBool(slice);
        let round_candidates = slice.loadUint(8);
        let next_candidate_delay_ms = slice.loadUint(32);
        let consensus_timeout_ms = slice.loadUint(32);
        let fast_attempts = slice.loadUint(32);
        let attempt_duration = slice.loadUint(32);
        let catchain_max_deps = slice.loadUint(32);
        let max_block_bytes = slice.loadUint(32);
        let max_collated_bytes = slice.loadUint(32);
        let proto_version = slice.loadUint(16);
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_v3" for type "ConsensusConfig"');
        }
        if ((!(round_candidates >= 1))) {
            throw new Error('Condition (round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_v3" for type "ConsensusConfig"');
        }
        return {
            kind: 'ConsensusConfig_consensus_config_v3',
            flags: flags,
            new_catchain_ids: new_catchain_ids,
            round_candidates: round_candidates,
            next_candidate_delay_ms: next_candidate_delay_ms,
            consensus_timeout_ms: consensus_timeout_ms,
            fast_attempts: fast_attempts,
            attempt_duration: attempt_duration,
            catchain_max_deps: catchain_max_deps,
            max_block_bytes: max_block_bytes,
            max_collated_bytes: max_collated_bytes,
            proto_version: proto_version,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xd9))) {
        slice.loadUint(8);
        let flags = slice.loadUint(7);
        let new_catchain_ids = loadBool(slice);
        let round_candidates = slice.loadUint(8);
        let next_candidate_delay_ms = slice.loadUint(32);
        let consensus_timeout_ms = slice.loadUint(32);
        let fast_attempts = slice.loadUint(32);
        let attempt_duration = slice.loadUint(32);
        let catchain_max_deps = slice.loadUint(32);
        let max_block_bytes = slice.loadUint(32);
        let max_collated_bytes = slice.loadUint(32);
        let proto_version = slice.loadUint(16);
        let catchain_max_blocks_coeff = slice.loadUint(32);
        if ((!(flags == 0))) {
            throw new Error('Condition (flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_v4" for type "ConsensusConfig"');
        }
        if ((!(round_candidates >= 1))) {
            throw new Error('Condition (round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_v4" for type "ConsensusConfig"');
        }
        return {
            kind: 'ConsensusConfig_consensus_config_v4',
            flags: flags,
            new_catchain_ids: new_catchain_ids,
            round_candidates: round_candidates,
            next_candidate_delay_ms: next_candidate_delay_ms,
            consensus_timeout_ms: consensus_timeout_ms,
            fast_attempts: fast_attempts,
            attempt_duration: attempt_duration,
            catchain_max_deps: catchain_max_deps,
            max_block_bytes: max_block_bytes,
            max_collated_bytes: max_collated_bytes,
            proto_version: proto_version,
            catchain_max_blocks_coeff: catchain_max_blocks_coeff,
        };
    }
    throw new Error('Expected one of "ConsensusConfig_consensus_config", "ConsensusConfig_consensus_config_new", "ConsensusConfig_consensus_config_v3", "ConsensusConfig_consensus_config_v4" in loading "ConsensusConfig", but data does not satisfy any constructor');
}
exports.loadConsensusConfig = loadConsensusConfig;
function storeConsensusConfig(consensusConfig) {
    if ((consensusConfig.kind == 'ConsensusConfig_consensus_config')) {
        return ((builder) => {
            builder.storeUint(0xd6, 8);
            builder.storeUint(consensusConfig.round_candidates, 32);
            builder.storeUint(consensusConfig.next_candidate_delay_ms, 32);
            builder.storeUint(consensusConfig.consensus_timeout_ms, 32);
            builder.storeUint(consensusConfig.fast_attempts, 32);
            builder.storeUint(consensusConfig.attempt_duration, 32);
            builder.storeUint(consensusConfig.catchain_max_deps, 32);
            builder.storeUint(consensusConfig.max_block_bytes, 32);
            builder.storeUint(consensusConfig.max_collated_bytes, 32);
            if ((!(consensusConfig.round_candidates >= 1))) {
                throw new Error('Condition (consensusConfig.round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config" for type "ConsensusConfig"');
            }
        });
    }
    if ((consensusConfig.kind == 'ConsensusConfig_consensus_config_new')) {
        return ((builder) => {
            builder.storeUint(0xd7, 8);
            builder.storeUint(consensusConfig.flags, 7);
            storeBool(consensusConfig.new_catchain_ids)(builder);
            builder.storeUint(consensusConfig.round_candidates, 8);
            builder.storeUint(consensusConfig.next_candidate_delay_ms, 32);
            builder.storeUint(consensusConfig.consensus_timeout_ms, 32);
            builder.storeUint(consensusConfig.fast_attempts, 32);
            builder.storeUint(consensusConfig.attempt_duration, 32);
            builder.storeUint(consensusConfig.catchain_max_deps, 32);
            builder.storeUint(consensusConfig.max_block_bytes, 32);
            builder.storeUint(consensusConfig.max_collated_bytes, 32);
            if ((!(consensusConfig.flags == 0))) {
                throw new Error('Condition (consensusConfig.flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_new" for type "ConsensusConfig"');
            }
            if ((!(consensusConfig.round_candidates >= 1))) {
                throw new Error('Condition (consensusConfig.round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_new" for type "ConsensusConfig"');
            }
        });
    }
    if ((consensusConfig.kind == 'ConsensusConfig_consensus_config_v3')) {
        return ((builder) => {
            builder.storeUint(0xd8, 8);
            builder.storeUint(consensusConfig.flags, 7);
            storeBool(consensusConfig.new_catchain_ids)(builder);
            builder.storeUint(consensusConfig.round_candidates, 8);
            builder.storeUint(consensusConfig.next_candidate_delay_ms, 32);
            builder.storeUint(consensusConfig.consensus_timeout_ms, 32);
            builder.storeUint(consensusConfig.fast_attempts, 32);
            builder.storeUint(consensusConfig.attempt_duration, 32);
            builder.storeUint(consensusConfig.catchain_max_deps, 32);
            builder.storeUint(consensusConfig.max_block_bytes, 32);
            builder.storeUint(consensusConfig.max_collated_bytes, 32);
            builder.storeUint(consensusConfig.proto_version, 16);
            if ((!(consensusConfig.flags == 0))) {
                throw new Error('Condition (consensusConfig.flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_v3" for type "ConsensusConfig"');
            }
            if ((!(consensusConfig.round_candidates >= 1))) {
                throw new Error('Condition (consensusConfig.round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_v3" for type "ConsensusConfig"');
            }
        });
    }
    if ((consensusConfig.kind == 'ConsensusConfig_consensus_config_v4')) {
        return ((builder) => {
            builder.storeUint(0xd9, 8);
            builder.storeUint(consensusConfig.flags, 7);
            storeBool(consensusConfig.new_catchain_ids)(builder);
            builder.storeUint(consensusConfig.round_candidates, 8);
            builder.storeUint(consensusConfig.next_candidate_delay_ms, 32);
            builder.storeUint(consensusConfig.consensus_timeout_ms, 32);
            builder.storeUint(consensusConfig.fast_attempts, 32);
            builder.storeUint(consensusConfig.attempt_duration, 32);
            builder.storeUint(consensusConfig.catchain_max_deps, 32);
            builder.storeUint(consensusConfig.max_block_bytes, 32);
            builder.storeUint(consensusConfig.max_collated_bytes, 32);
            builder.storeUint(consensusConfig.proto_version, 16);
            builder.storeUint(consensusConfig.catchain_max_blocks_coeff, 32);
            if ((!(consensusConfig.flags == 0))) {
                throw new Error('Condition (consensusConfig.flags == 0) is not satisfied while loading "ConsensusConfig_consensus_config_v4" for type "ConsensusConfig"');
            }
            if ((!(consensusConfig.round_candidates >= 1))) {
                throw new Error('Condition (consensusConfig.round_candidates >= 1) is not satisfied while loading "ConsensusConfig_consensus_config_v4" for type "ConsensusConfig"');
            }
        });
    }
    throw new Error('Expected one of "ConsensusConfig_consensus_config", "ConsensusConfig_consensus_config_new", "ConsensusConfig_consensus_config_v3", "ConsensusConfig_consensus_config_v4" in loading "ConsensusConfig", but data does not satisfy any constructor');
}
exports.storeConsensusConfig = storeConsensusConfig;
// validator_temp_key#3 adnl_addr:bits256 temp_public_key:SigPubKey seqno:# valid_until:uint32 = ValidatorTempKey;
function loadValidatorTempKey(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0x3))) {
        slice.loadUint(4);
        let adnl_addr = slice.loadBuffer((256 / 8));
        let temp_public_key = loadSigPubKey(slice);
        let seqno = slice.loadUint(32);
        let valid_until = slice.loadUint(32);
        return {
            kind: 'ValidatorTempKey',
            adnl_addr: adnl_addr,
            temp_public_key: temp_public_key,
            seqno: seqno,
            valid_until: valid_until,
        };
    }
    throw new Error('Expected one of "ValidatorTempKey" in loading "ValidatorTempKey", but data does not satisfy any constructor');
}
exports.loadValidatorTempKey = loadValidatorTempKey;
function storeValidatorTempKey(validatorTempKey) {
    return ((builder) => {
        builder.storeUint(0x3, 4);
        builder.storeBuffer(validatorTempKey.adnl_addr, (256 / 8));
        storeSigPubKey(validatorTempKey.temp_public_key)(builder);
        builder.storeUint(validatorTempKey.seqno, 32);
        builder.storeUint(validatorTempKey.valid_until, 32);
    });
}
exports.storeValidatorTempKey = storeValidatorTempKey;
// signed_temp_key#4 key:^ValidatorTempKey signature:CryptoSignature = ValidatorSignedTempKey;
function loadValidatorSignedTempKey(slice) {
    if (((slice.remainingBits >= 4) && (slice.preloadUint(4) == 0x4))) {
        slice.loadUint(4);
        let slice1 = slice.loadRef().beginParse(true);
        let key = loadValidatorTempKey(slice1);
        let signature = loadCryptoSignature(slice);
        return {
            kind: 'ValidatorSignedTempKey',
            key: key,
            signature: signature,
        };
    }
    throw new Error('Expected one of "ValidatorSignedTempKey" in loading "ValidatorSignedTempKey", but data does not satisfy any constructor');
}
exports.loadValidatorSignedTempKey = loadValidatorSignedTempKey;
function storeValidatorSignedTempKey(validatorSignedTempKey) {
    return ((builder) => {
        builder.storeUint(0x4, 4);
        let cell1 = (0, core_1.beginCell)();
        storeValidatorTempKey(validatorSignedTempKey.key)(cell1);
        builder.storeRef(cell1);
        storeCryptoSignature(validatorSignedTempKey.signature)(builder);
    });
}
exports.storeValidatorSignedTempKey = storeValidatorSignedTempKey;
/*
misbehaviour_punishment_config_v1#01
  default_flat_fine:Grams default_proportional_fine:uint32
  severity_flat_mult:uint16 severity_proportional_mult:uint16
  unpunishable_interval:uint16
  long_interval:uint16 long_flat_mult:uint16 long_proportional_mult:uint16
  medium_interval:uint16 medium_flat_mult:uint16 medium_proportional_mult:uint16
   = MisbehaviourPunishmentConfig;
*/
function loadMisbehaviourPunishmentConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x01))) {
        slice.loadUint(8);
        let default_flat_fine = slice.loadCoins();
        let default_proportional_fine = slice.loadUint(32);
        let severity_flat_mult = slice.loadUint(16);
        let severity_proportional_mult = slice.loadUint(16);
        let unpunishable_interval = slice.loadUint(16);
        let long_interval = slice.loadUint(16);
        let long_flat_mult = slice.loadUint(16);
        let long_proportional_mult = slice.loadUint(16);
        let medium_interval = slice.loadUint(16);
        let medium_flat_mult = slice.loadUint(16);
        let medium_proportional_mult = slice.loadUint(16);
        return {
            kind: 'MisbehaviourPunishmentConfig',
            default_flat_fine: default_flat_fine,
            default_proportional_fine: default_proportional_fine,
            severity_flat_mult: severity_flat_mult,
            severity_proportional_mult: severity_proportional_mult,
            unpunishable_interval: unpunishable_interval,
            long_interval: long_interval,
            long_flat_mult: long_flat_mult,
            long_proportional_mult: long_proportional_mult,
            medium_interval: medium_interval,
            medium_flat_mult: medium_flat_mult,
            medium_proportional_mult: medium_proportional_mult,
        };
    }
    throw new Error('Expected one of "MisbehaviourPunishmentConfig" in loading "MisbehaviourPunishmentConfig", but data does not satisfy any constructor');
}
exports.loadMisbehaviourPunishmentConfig = loadMisbehaviourPunishmentConfig;
function storeMisbehaviourPunishmentConfig(misbehaviourPunishmentConfig) {
    return ((builder) => {
        builder.storeUint(0x01, 8);
        builder.storeCoins(misbehaviourPunishmentConfig.default_flat_fine);
        builder.storeUint(misbehaviourPunishmentConfig.default_proportional_fine, 32);
        builder.storeUint(misbehaviourPunishmentConfig.severity_flat_mult, 16);
        builder.storeUint(misbehaviourPunishmentConfig.severity_proportional_mult, 16);
        builder.storeUint(misbehaviourPunishmentConfig.unpunishable_interval, 16);
        builder.storeUint(misbehaviourPunishmentConfig.long_interval, 16);
        builder.storeUint(misbehaviourPunishmentConfig.long_flat_mult, 16);
        builder.storeUint(misbehaviourPunishmentConfig.long_proportional_mult, 16);
        builder.storeUint(misbehaviourPunishmentConfig.medium_interval, 16);
        builder.storeUint(misbehaviourPunishmentConfig.medium_flat_mult, 16);
        builder.storeUint(misbehaviourPunishmentConfig.medium_proportional_mult, 16);
    });
}
exports.storeMisbehaviourPunishmentConfig = storeMisbehaviourPunishmentConfig;
/*
size_limits_config#01 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 = SizeLimitsConfig;
*/
/*
size_limits_config_v2#02 max_msg_bits:uint32 max_msg_cells:uint32 max_library_cells:uint32 max_vm_data_depth:uint16
  max_ext_msg_size:uint32 max_ext_msg_depth:uint16 max_acc_state_cells:uint32 max_acc_state_bits:uint32
  max_acc_public_libraries:uint32 defer_out_queue_size_limit:uint32 max_msg_extra_currencies:uint32
  max_acc_fixed_prefix_length:uint8 = SizeLimitsConfig;
*/
function loadSizeLimitsConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x01))) {
        slice.loadUint(8);
        let max_msg_bits = slice.loadUint(32);
        let max_msg_cells = slice.loadUint(32);
        let max_library_cells = slice.loadUint(32);
        let max_vm_data_depth = slice.loadUint(16);
        let max_ext_msg_size = slice.loadUint(32);
        let max_ext_msg_depth = slice.loadUint(16);
        return {
            kind: 'SizeLimitsConfig_size_limits_config',
            max_msg_bits: max_msg_bits,
            max_msg_cells: max_msg_cells,
            max_library_cells: max_library_cells,
            max_vm_data_depth: max_vm_data_depth,
            max_ext_msg_size: max_ext_msg_size,
            max_ext_msg_depth: max_ext_msg_depth,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x02))) {
        slice.loadUint(8);
        let max_msg_bits = slice.loadUint(32);
        let max_msg_cells = slice.loadUint(32);
        let max_library_cells = slice.loadUint(32);
        let max_vm_data_depth = slice.loadUint(16);
        let max_ext_msg_size = slice.loadUint(32);
        let max_ext_msg_depth = slice.loadUint(16);
        let max_acc_state_cells = slice.loadUint(32);
        let max_acc_state_bits = slice.loadUint(32);
        let max_acc_public_libraries = slice.loadUint(32);
        let defer_out_queue_size_limit = slice.loadUint(32);
        let max_msg_extra_currencies = slice.loadUint(32);
        let max_acc_fixed_prefix_length = slice.loadUint(8);
        return {
            kind: 'SizeLimitsConfig_size_limits_config_v2',
            max_msg_bits: max_msg_bits,
            max_msg_cells: max_msg_cells,
            max_library_cells: max_library_cells,
            max_vm_data_depth: max_vm_data_depth,
            max_ext_msg_size: max_ext_msg_size,
            max_ext_msg_depth: max_ext_msg_depth,
            max_acc_state_cells: max_acc_state_cells,
            max_acc_state_bits: max_acc_state_bits,
            max_acc_public_libraries: max_acc_public_libraries,
            defer_out_queue_size_limit: defer_out_queue_size_limit,
            max_msg_extra_currencies: max_msg_extra_currencies,
            max_acc_fixed_prefix_length: max_acc_fixed_prefix_length,
        };
    }
    throw new Error('Expected one of "SizeLimitsConfig_size_limits_config", "SizeLimitsConfig_size_limits_config_v2" in loading "SizeLimitsConfig", but data does not satisfy any constructor');
}
exports.loadSizeLimitsConfig = loadSizeLimitsConfig;
function storeSizeLimitsConfig(sizeLimitsConfig) {
    if ((sizeLimitsConfig.kind == 'SizeLimitsConfig_size_limits_config')) {
        return ((builder) => {
            builder.storeUint(0x01, 8);
            builder.storeUint(sizeLimitsConfig.max_msg_bits, 32);
            builder.storeUint(sizeLimitsConfig.max_msg_cells, 32);
            builder.storeUint(sizeLimitsConfig.max_library_cells, 32);
            builder.storeUint(sizeLimitsConfig.max_vm_data_depth, 16);
            builder.storeUint(sizeLimitsConfig.max_ext_msg_size, 32);
            builder.storeUint(sizeLimitsConfig.max_ext_msg_depth, 16);
        });
    }
    if ((sizeLimitsConfig.kind == 'SizeLimitsConfig_size_limits_config_v2')) {
        return ((builder) => {
            builder.storeUint(0x02, 8);
            builder.storeUint(sizeLimitsConfig.max_msg_bits, 32);
            builder.storeUint(sizeLimitsConfig.max_msg_cells, 32);
            builder.storeUint(sizeLimitsConfig.max_library_cells, 32);
            builder.storeUint(sizeLimitsConfig.max_vm_data_depth, 16);
            builder.storeUint(sizeLimitsConfig.max_ext_msg_size, 32);
            builder.storeUint(sizeLimitsConfig.max_ext_msg_depth, 16);
            builder.storeUint(sizeLimitsConfig.max_acc_state_cells, 32);
            builder.storeUint(sizeLimitsConfig.max_acc_state_bits, 32);
            builder.storeUint(sizeLimitsConfig.max_acc_public_libraries, 32);
            builder.storeUint(sizeLimitsConfig.defer_out_queue_size_limit, 32);
            builder.storeUint(sizeLimitsConfig.max_msg_extra_currencies, 32);
            builder.storeUint(sizeLimitsConfig.max_acc_fixed_prefix_length, 8);
        });
    }
    throw new Error('Expected one of "SizeLimitsConfig_size_limits_config", "SizeLimitsConfig_size_limits_config_v2" in loading "SizeLimitsConfig", but data does not satisfy any constructor');
}
exports.storeSizeLimitsConfig = storeSizeLimitsConfig;
// suspended_address_list#00 addresses:(HashmapE 288 Unit) suspended_until:uint32 = SuspendedAddressList;
function loadSuspendedAddressList(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x00))) {
        slice.loadUint(8);
        let addresses = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(288), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadUnit,
        }, slice);
        let suspended_until = slice.loadUint(32);
        return {
            kind: 'SuspendedAddressList',
            addresses: addresses,
            suspended_until: suspended_until,
        };
    }
    throw new Error('Expected one of "SuspendedAddressList" in loading "SuspendedAddressList", but data does not satisfy any constructor');
}
exports.loadSuspendedAddressList = loadSuspendedAddressList;
function storeSuspendedAddressList(suspendedAddressList) {
    return ((builder) => {
        builder.storeUint(0x00, 8);
        builder.storeDict(suspendedAddressList.addresses, core_2.Dictionary.Keys.BigUint(288), {
            serialize: ((arg, builder) => {
                storeUnit(arg)(builder);
            }),
            parse: () => { throw new Error('Not implemented'); },
        });
        builder.storeUint(suspendedAddressList.suspended_until, 32);
    });
}
exports.storeSuspendedAddressList = storeSuspendedAddressList;
// precompiled_smc#b0 gas_usage:uint64 = PrecompiledSmc;
function loadPrecompiledSmc(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xb0))) {
        slice.loadUint(8);
        let gas_usage = slice.loadUintBig(64);
        return {
            kind: 'PrecompiledSmc',
            gas_usage: gas_usage,
        };
    }
    throw new Error('Expected one of "PrecompiledSmc" in loading "PrecompiledSmc", but data does not satisfy any constructor');
}
exports.loadPrecompiledSmc = loadPrecompiledSmc;
function storePrecompiledSmc(precompiledSmc) {
    return ((builder) => {
        builder.storeUint(0xb0, 8);
        builder.storeUint(precompiledSmc.gas_usage, 64);
    });
}
exports.storePrecompiledSmc = storePrecompiledSmc;
// precompiled_contracts_config#c0 list:(HashmapE 256 PrecompiledSmc) = PrecompiledContractsConfig;
function loadPrecompiledContractsConfig(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0xc0))) {
        slice.loadUint(8);
        let list = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: loadPrecompiledSmc,
        }, slice);
        return {
            kind: 'PrecompiledContractsConfig',
            list: list,
        };
    }
    throw new Error('Expected one of "PrecompiledContractsConfig" in loading "PrecompiledContractsConfig", but data does not satisfy any constructor');
}
exports.loadPrecompiledContractsConfig = loadPrecompiledContractsConfig;
function storePrecompiledContractsConfig(precompiledContractsConfig) {
    return ((builder) => {
        builder.storeUint(0xc0, 8);
        builder.storeDict(precompiledContractsConfig.list, core_2.Dictionary.Keys.BigUint(256), {
            serialize: ((arg, builder) => {
                storePrecompiledSmc(arg)(builder);
            }),
            parse: () => { throw new Error('Not implemented'); },
        });
    });
}
exports.storePrecompiledContractsConfig = storePrecompiledContractsConfig;
// oracle_bridge_params#_ bridge_address:bits256 oracle_mutlisig_address:bits256 oracles:(HashmapE 256 uint256) external_chain_address:bits256 = OracleBridgeParams;
function loadOracleBridgeParams(slice) {
    let bridge_address = slice.loadBuffer((256 / 8));
    let oracle_mutlisig_address = slice.loadBuffer((256 / 8));
    let oracles = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
        serialize: () => { throw new Error('Not implemented'); },
        parse: ((slice) => {
            return slice.loadUintBig(256);
        }),
    }, slice);
    let external_chain_address = slice.loadBuffer((256 / 8));
    return {
        kind: 'OracleBridgeParams',
        bridge_address: bridge_address,
        oracle_mutlisig_address: oracle_mutlisig_address,
        oracles: oracles,
        external_chain_address: external_chain_address,
    };
}
exports.loadOracleBridgeParams = loadOracleBridgeParams;
function storeOracleBridgeParams(oracleBridgeParams) {
    return ((builder) => {
        builder.storeBuffer(oracleBridgeParams.bridge_address, (256 / 8));
        builder.storeBuffer(oracleBridgeParams.oracle_mutlisig_address, (256 / 8));
        builder.storeDict(oracleBridgeParams.oracles, core_2.Dictionary.Keys.BigUint(256), {
            serialize: ((arg, builder) => {
                ((arg) => {
                    return ((builder) => {
                        builder.storeUint(arg, 256);
                    });
                })(arg)(builder);
            }),
            parse: () => { throw new Error('Not implemented'); },
        });
        builder.storeBuffer(oracleBridgeParams.external_chain_address, (256 / 8));
    });
}
exports.storeOracleBridgeParams = storeOracleBridgeParams;
/*
jetton_bridge_prices#_ bridge_burn_fee:Coins bridge_mint_fee:Coins
                       wallet_min_tons_for_storage:Coins
                       wallet_gas_consumption:Coins
                       minter_min_tons_for_storage:Coins
                       discover_gas_consumption:Coins = JettonBridgePrices;
*/
function loadJettonBridgePrices(slice) {
    let bridge_burn_fee = slice.loadCoins();
    let bridge_mint_fee = slice.loadCoins();
    let wallet_min_tons_for_storage = slice.loadCoins();
    let wallet_gas_consumption = slice.loadCoins();
    let minter_min_tons_for_storage = slice.loadCoins();
    let discover_gas_consumption = slice.loadCoins();
    return {
        kind: 'JettonBridgePrices',
        bridge_burn_fee: bridge_burn_fee,
        bridge_mint_fee: bridge_mint_fee,
        wallet_min_tons_for_storage: wallet_min_tons_for_storage,
        wallet_gas_consumption: wallet_gas_consumption,
        minter_min_tons_for_storage: minter_min_tons_for_storage,
        discover_gas_consumption: discover_gas_consumption,
    };
}
exports.loadJettonBridgePrices = loadJettonBridgePrices;
function storeJettonBridgePrices(jettonBridgePrices) {
    return ((builder) => {
        builder.storeCoins(jettonBridgePrices.bridge_burn_fee);
        builder.storeCoins(jettonBridgePrices.bridge_mint_fee);
        builder.storeCoins(jettonBridgePrices.wallet_min_tons_for_storage);
        builder.storeCoins(jettonBridgePrices.wallet_gas_consumption);
        builder.storeCoins(jettonBridgePrices.minter_min_tons_for_storage);
        builder.storeCoins(jettonBridgePrices.discover_gas_consumption);
    });
}
exports.storeJettonBridgePrices = storeJettonBridgePrices;
// jetton_bridge_params_v0#00 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 burn_bridge_fee:Coins = JettonBridgeParams;
// jetton_bridge_params_v1#01 bridge_address:bits256 oracles_address:bits256 oracles:(HashmapE 256 uint256) state_flags:uint8 prices:^JettonBridgePrices external_chain_address:bits256 = JettonBridgeParams;
function loadJettonBridgeParams(slice) {
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x00))) {
        slice.loadUint(8);
        let bridge_address = slice.loadBuffer((256 / 8));
        let oracles_address = slice.loadBuffer((256 / 8));
        let oracles = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: ((slice) => {
                return slice.loadUintBig(256);
            }),
        }, slice);
        let state_flags = slice.loadUint(8);
        let burn_bridge_fee = slice.loadCoins();
        return {
            kind: 'JettonBridgeParams_jetton_bridge_params_v0',
            bridge_address: bridge_address,
            oracles_address: oracles_address,
            oracles: oracles,
            state_flags: state_flags,
            burn_bridge_fee: burn_bridge_fee,
        };
    }
    if (((slice.remainingBits >= 8) && (slice.preloadUint(8) == 0x01))) {
        slice.loadUint(8);
        let bridge_address = slice.loadBuffer((256 / 8));
        let oracles_address = slice.loadBuffer((256 / 8));
        let oracles = core_2.Dictionary.load(core_2.Dictionary.Keys.BigUint(256), {
            serialize: () => { throw new Error('Not implemented'); },
            parse: ((slice) => {
                return slice.loadUintBig(256);
            }),
        }, slice);
        let state_flags = slice.loadUint(8);
        let slice1 = slice.loadRef().beginParse(true);
        let prices = loadJettonBridgePrices(slice1);
        let external_chain_address = slice.loadBuffer((256 / 8));
        return {
            kind: 'JettonBridgeParams_jetton_bridge_params_v1',
            bridge_address: bridge_address,
            oracles_address: oracles_address,
            oracles: oracles,
            state_flags: state_flags,
            prices: prices,
            external_chain_address: external_chain_address,
        };
    }
    throw new Error('Expected one of "JettonBridgeParams_jetton_bridge_params_v0", "JettonBridgeParams_jetton_bridge_params_v1" in loading "JettonBridgeParams", but data does not satisfy any constructor');
}
exports.loadJettonBridgeParams = loadJettonBridgeParams;
function storeJettonBridgeParams(jettonBridgeParams) {
    if ((jettonBridgeParams.kind == 'JettonBridgeParams_jetton_bridge_params_v0')) {
        return ((builder) => {
            builder.storeUint(0x00, 8);
            builder.storeBuffer(jettonBridgeParams.bridge_address, (256 / 8));
            builder.storeBuffer(jettonBridgeParams.oracles_address, (256 / 8));
            builder.storeDict(jettonBridgeParams.oracles, core_2.Dictionary.Keys.BigUint(256), {
                serialize: ((arg, builder) => {
                    ((arg) => {
                        return ((builder) => {
                            builder.storeUint(arg, 256);
                        });
                    })(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
            builder.storeUint(jettonBridgeParams.state_flags, 8);
            builder.storeCoins(jettonBridgeParams.burn_bridge_fee);
        });
    }
    if ((jettonBridgeParams.kind == 'JettonBridgeParams_jetton_bridge_params_v1')) {
        return ((builder) => {
            builder.storeUint(0x01, 8);
            builder.storeBuffer(jettonBridgeParams.bridge_address, (256 / 8));
            builder.storeBuffer(jettonBridgeParams.oracles_address, (256 / 8));
            builder.storeDict(jettonBridgeParams.oracles, core_2.Dictionary.Keys.BigUint(256), {
                serialize: ((arg, builder) => {
                    ((arg) => {
                        return ((builder) => {
                            builder.storeUint(arg, 256);
                        });
                    })(arg)(builder);
                }),
                parse: () => { throw new Error('Not implemented'); },
            });
            builder.storeUint(jettonBridgeParams.state_flags, 8);
            let cell1 = (0, core_1.beginCell)();
            storeJettonBridgePrices(jettonBridgeParams.prices)(cell1);
            builder.storeRef(cell1);
            builder.storeBuffer(jettonBridgeParams.external_chain_address, (256 / 8));
        });
    }
    throw new Error('Expected one of "JettonBridgeParams_jetton_bridge_params_v0", "JettonBridgeParams_jetton_bridge_params_v1" in loading "JettonBridgeParams", but data does not satisfy any constructor');
}
exports.storeJettonBridgeParams = storeJettonBridgeParams;
