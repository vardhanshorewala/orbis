"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDatabase = void 0;
const collectMetric_1 = require("./collectMetric");
class ContractDatabase {
    constructor(abiList, codeHashMatch) {
        this.list = abiList;
        this.match = codeHashMatch;
    }
    static from(data) {
        const list = new Map();
        const match = new Map();
        Object.entries(data).forEach(([key, value]) => {
            if (((0, collectMetric_1.isCodeHash)(key) && typeof value === 'string') || ((0, collectMetric_1.isCodeHash)(value) && typeof key === 'string')) {
                match.set(key, value);
            }
            else if (!(0, collectMetric_1.isCodeHash)(value) && typeof value !== 'string') {
                list.set(key, value);
            }
        });
        return new ContractDatabase(list, match);
    }
    get data() {
        const out = {};
        for (const [key, value] of this.match) {
            out[key] = value;
        }
        for (const [key, value] of this.list) {
            out[key] = value;
        }
        return out;
    }
    origin(needle) {
        return this.match.get(needle) || needle;
    }
    get(needle) {
        return this.list.get(this.origin(needle));
    }
    extract(metric) {
        const abiKeyNeedle = metric.contractName || metric.codeHash;
        if (!abiKeyNeedle) {
            return;
        }
        const codeHash = metric.codeHash;
        if ((0, collectMetric_1.isCodeHash)(codeHash) && abiKeyNeedle !== codeHash) {
            this.match.set(codeHash, abiKeyNeedle);
        }
        const abiKey = this.origin(abiKeyNeedle);
        const abi = this.list.get(abiKey) || {};
        if (!abi.receivers) {
            abi.receivers = [];
        }
        if (!abi.types) {
            abi.types = [];
        }
        const find = this.by(metric);
        if (!find.methodName) {
            if (!abi.name) {
                abi.name = metric.contractName || metric.codeHash;
            }
            if (metric.opCode !== '0x0') {
                abi.types.push({
                    name: metric.methodName || metric.opCode,
                    header: Number(metric.opCode),
                });
                abi.receivers.push({
                    receiver: metric.receiver == 'internal' ? 'internal' : 'external',
                    message: {
                        kind: 'typed',
                        type: metric.methodName || metric.opCode,
                    },
                });
            }
        }
        this.list.set(abiKey, abi);
    }
    by(where) {
        if (!where.codeHash) {
            return {};
        }
        const abi = this.get(where.codeHash);
        if (!abi) {
            return {};
        }
        const out = {};
        out.contractName = abi.name ? abi.name : undefined;
        let abiType;
        if (where.opCode) {
            for (const item of abi.types || []) {
                if (item.header && item.header === Number(where.opCode)) {
                    abiType = item;
                    break;
                }
            }
        }
        if (abiType) {
            const receiver = where.receiver ? (where.receiver == 'internal' ? 'internal' : 'external') : undefined;
            for (const item of abi.receivers || []) {
                if (receiver && receiver !== item.receiver) {
                    continue;
                }
                if (item.message.kind === 'typed' && item.message.type == abiType.name) {
                    out.methodName = item.message.type;
                    break;
                }
            }
        }
        return out;
    }
}
exports.ContractDatabase = ContractDatabase;
