import { Cell, Contract, Message } from '@ton/core';
import { Dictionary, DictionaryKeyTypes, TransactionComputePhase } from '@ton/core';
import { Maybe } from '@ton/core/src/utils/maybe';
import { Blockchain, SendMessageResult } from '../blockchain/Blockchain';
import { ContractDatabase } from './ContractDatabase';
export type MetricContext<T extends Contract> = {
    contract: T;
    methodName: string;
};
type StateShort = {
    code: Cell;
    data: Cell;
};
export type CellMetric = {
    cells: number;
    bits: number;
};
export type ComputePhaseMetric = {
    type: string;
    success?: boolean;
    gasUsed?: number;
    exitCode?: number;
    vmSteps?: number;
};
export type ActionPhaseMetric = {
    success: boolean;
    totalActions: number;
    skippedActions: number;
    resultCode: number;
    totalFwdFees?: number;
    totalActionFees: number;
    totalMessageSize: CellMetric;
};
export type AddressFriendly = string;
export declare function isAddressFriendly(value: unknown): value is AddressFriendly;
export type ContractName = string;
export type ContractMethodName = string;
export type CodeHash = `0x${string}`;
export type OpCode = `0x${string}`;
export declare function isCodeHash(value: unknown): value is CodeHash;
export type StateMetric = {
    code: CellMetric;
    data: CellMetric;
};
export type Metric = {
    testName?: string;
    address: AddressFriendly;
    codeHash?: CodeHash;
    state: StateMetric;
    contractName?: ContractName;
    methodName?: ContractMethodName;
    receiver?: 'internal' | 'external-in' | 'external-out';
    opCode: OpCode;
    execute: {
        compute: ComputePhaseMetric;
        action?: ActionPhaseMetric;
    };
    message: {
        in: CellMetric;
        out: CellMetric;
    };
};
export type SnapshotMetric = {
    label: string;
    createdAt: Date;
    items: Metric[];
};
interface HasCreatedAt {
    createdAt: Date;
}
export declare function sortByCreatedAt(reverse?: boolean): (a: HasCreatedAt, b: HasCreatedAt) => number;
export type SnapshotMetricFile = {
    name: string;
    content: SnapshotMetric;
};
export type SnapshotMetricList = Record<string, SnapshotMetricFile>;
export type SnapshotMetricConfig = {
    label: string;
    contractExcludes: ContractName[];
    contractDatabase: ContractDatabase;
};
export declare function makeSnapshotMetric(store: Metric[], config?: Partial<SnapshotMetricConfig>): SnapshotMetric;
export declare function getMetricStore(context?: any): Array<Metric> | undefined;
export declare function createMetricStore(context?: any): Array<Metric>;
export declare function resetMetricStore(context?: any): Array<Metric>;
export declare function calcMessageSize(msg: Maybe<Message>): {
    cells: number;
    bits: number;
};
export declare function calcDictSize<K extends DictionaryKeyTypes, V>(dict: Dictionary<K, V>): {
    cells: number;
    bits: number;
};
export declare function calcCellSize(root: Cell, visited?: Set<string>): {
    cells: number;
    bits: number;
};
export declare function calcStateSize(state: StateShort): StateMetric;
export declare function calcComputePhase(phase: TransactionComputePhase): ComputePhaseMetric;
export declare enum OpCodeReserved {
    send = 0,
    notSupported = 4294967295,
    notAllowed = 4294967294
}
export declare function collectMetric<T extends Contract>(blockchain: Blockchain, ctx: MetricContext<T>, result: SendMessageResult): Promise<void>;
export {};
