"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pack = void 0;
const child_process_1 = require("child_process");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const arg_1 = __importDefault(require("arg"));
const constants_1 = require("./constants");
const build_1 = require("../build");
const paths_1 = require("../paths");
const utils_1 = require("../utils");
const compile_1 = require("../compile/compile");
const CompilerConfig_1 = require("../compile/CompilerConfig");
const compile_tact_1 = require("../compile/tact/compile.tact");
async function correctTsConfig() {
    if (!(0, fs_1.existsSync)(paths_1.TYPESCRIPT_CONFIG)) {
        throw new Error('TypeScript config does not exist. Ensure the command runs in the correct environment.');
    }
    const tsConfig = JSON.parse(await fs_1.promises.readFile(paths_1.TYPESCRIPT_CONFIG, 'utf-8'));
    const newConfig = {
        ...tsConfig,
        compilerOptions: {
            ...tsConfig.compilerOptions,
            outDir: 'dist',
            declaration: true,
            esModuleInterop: true,
        },
        include: (0, utils_1.distinct)([...(tsConfig.include ?? []), 'package.ts']),
    };
    await fs_1.promises.writeFile(paths_1.TYPESCRIPT_CONFIG, JSON.stringify(newConfig, null, 2), 'utf8');
}
async function getContractWrapperPath(contract) {
    const config = await (0, compile_1.getCompilerConfigForContract)(contract);
    if ((0, CompilerConfig_1.isCompilableConfig)(config)) {
        return `./wrappers/${contract}`;
    }
    else {
        const contractConfig = (0, compile_tact_1.extractContractConfig)(config, contract);
        return `./${contractConfig.output}/${contract}_${contract}`;
    }
}
async function generatePackageEntryPoint() {
    const contracts = await (0, utils_1.findContracts)();
    let entryPoint = 'import { Cell } from "@ton/core"\n';
    for (const contract of contracts) {
        const wrapperPath = await getContractWrapperPath(contract);
        entryPoint += `import * as ${contract} from '${wrapperPath}';\n`;
        entryPoint += `export { ${contract} };\n`;
        const buildArtifactPath = path_1.default.join(paths_1.BUILD_DIR, `${contract}.compiled.json`);
        const buildArtifact = JSON.parse(await fs_1.promises.readFile(buildArtifactPath, 'utf8'));
        entryPoint += `export const ${contract}Code = Cell.fromHex("${buildArtifact.hex}");\n`;
    }
    await fs_1.promises.writeFile(paths_1.PACKAGE_ENTRY_POINT, entryPoint, 'utf8');
}
async function correctPackageJson() {
    const packageJson = JSON.parse(await fs_1.promises.readFile(paths_1.PACKAGE_JSON, 'utf8'));
    const newPackageJson = {
        ...packageJson,
        main: 'dist/package.js',
        files: ['dist/**/*'],
    };
    await fs_1.promises.writeFile(paths_1.PACKAGE_JSON, JSON.stringify(newPackageJson, null, 2));
}
const pack = async (_args, ui, _context) => {
    const localArgs = (0, arg_1.default)({
        '--no-warn': Boolean,
        '-n': '--no-warn',
        ...constants_1.helpArgs,
    });
    if (localArgs['--help']) {
        ui.write(constants_1.helpMessages['pack']);
        return;
    }
    if (!localArgs['--no-warn']) {
        ui.write('ğŸš¨ WARNING: This command may modify tsconfig.json, package.json, and remove the dist directory. Make sure these files are committed to your repository. If you wish to ignore this warning, use the -n or --no-warn flag.');
        const answer = await ui.input('Are you sure you want to continue? (y/N)');
        if (answer.toLowerCase() !== 'y') {
            ui.write('Aborting...');
            return;
        }
    }
    ui.write('ğŸ”¨ Building contracts... Please wait...');
    await (0, build_1.buildAll)(ui);
    ui.write('ğŸ“¦ Generating package entry point...');
    await generatePackageEntryPoint();
    ui.write('ğŸ› ï¸ Updating tsconfig.json...');
    await correctTsConfig();
    ui.write('ğŸ—ï¸ Building package...');
    await fs_1.promises.rm(path_1.default.join(process.cwd(), 'dist'), {
        recursive: true,
        force: true,
    });
    (0, child_process_1.execSync)(`tsc`, { stdio: 'inherit' });
    ui.write('ğŸ“ Updating package.json...');
    await correctPackageJson();
    ui.write('ğŸ‰ Package is ready and packed successfully! You can now publish it ğŸš€');
};
exports.pack = pack;
