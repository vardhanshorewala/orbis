"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rename = void 0;
exports.renameExactIfRequired = renameExactIfRequired;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const arg_1 = __importDefault(require("arg"));
const paths_1 = require("../paths");
const Runner_1 = require("./Runner");
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const build_1 = require("./build");
function renameExactIfRequired(str, replaces) {
    let renamedString = str;
    let isRenamed = false;
    for (const [oldValue, newValue] of Object.entries(replaces)) {
        const regex = new RegExp(`\\b${oldValue}\\b`, 'g');
        if (regex.test(renamedString)) {
            isRenamed = true;
            renamedString = renamedString.replace(regex, newValue);
        }
    }
    return { isRenamed, newValue: renamedString };
}
// Introduced this class to prevent fails in the middle of renaming, when the part is renamed and part is not
class RenameContext {
    constructor(replaces) {
        this.replaces = replaces;
        this.effects = [];
    }
    async prepareRenameExactOccurrencesInDirectory(directory) {
        if (!(0, fs_1.existsSync)(directory)) {
            return;
        }
        const dir = await fs_1.promises.readdir(directory, {
            recursive: true,
            withFileTypes: true,
        });
        await Promise.all(dir
            .filter((dir) => dir.isFile())
            .map(utils_1.extractFile)
            .map(async (dir) => {
            const filePath = path_1.default.join(dir.path, dir.name);
            await this.prepareRenameContentInFile(filePath);
            const pathRenameResult = renameExactIfRequired(dir.name, this.replaces);
            if (pathRenameResult.isRenamed) {
                this.effects.push(() => fs_1.promises.rename(path_1.default.join(dir.path, dir.name), path_1.default.join(dir.path, pathRenameResult.newValue)));
            }
        }));
    }
    async prepareRenameContentInFile(filePath) {
        const content = await fs_1.promises.readFile(filePath, 'utf8');
        const { isRenamed, newValue } = renameExactIfRequired(content, this.replaces);
        if (isRenamed) {
            this.effects.push(() => fs_1.promises.writeFile(filePath, newValue, 'utf8'));
        }
    }
    async applyEffects() {
        for (const effect of this.effects) {
            await effect();
        }
    }
}
const rename = async (_args, ui, _context) => {
    const localArgs = (0, arg_1.default)(constants_1.helpArgs);
    if (localArgs['--help']) {
        ui.write(constants_1.helpMessages['rename']);
        return;
    }
    const oldName = await (0, build_1.selectContract)(ui, (0, Runner_1.extractFirstArg)(localArgs));
    const newName = (0, Runner_1.extractSecondArg)(localArgs) ?? (await ui.input('New contract name (PascalCase)'));
    (0, utils_1.assertValidContractName)(newName);
    const contracts = await (0, utils_1.findContracts)();
    if (contracts.includes(newName)) {
        ui.write(`Contract with name ${newName} already exists.`);
        process.exit(1);
    }
    const modifiers = [
        (name) => name,
        utils_1.toSnakeCase,
        utils_1.toLowerCase,
        (name) => `deploy${name}`,
        (name) => `${name}_${name}`,
        (name) => `increment${name}`,
        (name) => `${(0, utils_1.toLowerCase)(name)}ConfigToCell`,
        (name) => `${name}Config`,
    ];
    const replaces = Object.fromEntries(modifiers.map((modifier) => [modifier(oldName), modifier(newName)]));
    ui.setActionPrompt('Renaming in progress...');
    const renameContext = new RenameContext(replaces);
    for (const directory of [paths_1.SCRIPTS_DIR, paths_1.WRAPPERS_DIR, paths_1.CONTRACTS_DIR, paths_1.TESTS_DIR, paths_1.COMPILABLES_DIR]) {
        await renameContext.prepareRenameExactOccurrencesInDirectory(directory);
    }
    if ((0, fs_1.existsSync)(paths_1.TACT_ROOT_CONFIG)) {
        await renameContext.prepareRenameContentInFile(paths_1.TACT_ROOT_CONFIG);
    }
    await renameContext.applyEffects();
    ui.clearActionPrompt();
    ui.write('Contract successfully renamed!');
};
exports.rename = rename;
