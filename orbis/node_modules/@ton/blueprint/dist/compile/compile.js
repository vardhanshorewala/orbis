"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.COMPILE_END = void 0;
exports.getCompilablesDirectory = getCompilablesDirectory;
exports.extractCompilableConfig = extractCompilableConfig;
exports.getCompilerConfigForContract = getCompilerConfigForContract;
exports.getCompilerOptions = getCompilerOptions;
exports.doCompile = doCompile;
exports.compile = compile;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const paths_1 = require("../paths");
const CompilerConfig_1 = require("./CompilerConfig");
const utils_1 = require("../config/utils");
const compile_func_1 = require("./func/compile.func");
const compile_tact_1 = require("./tact/compile.tact");
const compile_tolk_1 = require("./tolk/compile.tolk");
const utils_2 = require("../utils");
async function getCompilablesDirectory() {
    const config = await (0, utils_1.getConfig)();
    if (config?.separateCompilables) {
        return paths_1.COMPILABLES_DIR;
    }
    return paths_1.WRAPPERS_DIR;
}
function extractCompilableConfig(path) {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const mod = require(path);
    if (typeof mod.compile !== 'object') {
        throw new Error(`Object 'compile' is missing`);
    }
    mod.compile.lang ??= 'func';
    return mod.compile;
}
exports.COMPILE_END = '.compile.ts';
/**
 * Retrieves the compiler configuration for a specific contract.
 *
 * This function checks if a Tact configuration exists for the given contract
 * `tact.config.json`. If found, it returns that configuration. Otherwise, it falls back
 * to loading and extracting the `.compile.ts` configuration file from the appropriate
 * compilables directory (`compilables/` or `wrappers/`).
 *
 * @param {string} name - The name of the contract
 *
 * @throws Error Throws if configuration is invalid or not found.
 *
 * @example
 * const config = await getCompilerConfigForContract('MyContract');
 * console.log('Compiler config:', config);
 */
async function getCompilerConfigForContract(name) {
    const tactConfig = (0, compile_tact_1.getTactConfigForContract)(name);
    if (tactConfig) {
        return tactConfig;
    }
    const compilablesDirectory = await getCompilablesDirectory();
    const compilables = await (0, utils_2.findCompiles)(compilablesDirectory);
    const compilable = compilables.find((c) => c.name === name);
    // Ensure compatibility with legacy usage like compile('subdirectory/ContractName')
    const pathToExtract = compilable?.path ?? path_1.default.join(compilablesDirectory, name + exports.COMPILE_END);
    return extractCompilableConfig(pathToExtract);
}
async function doCompileInner(name, config) {
    if ((0, CompilerConfig_1.isCompilableConfig)(config)) {
        if (config.lang === 'tact') {
            return await (0, compile_tact_1.doCompileTact)(config, name);
        }
        if (config.lang === 'tolk') {
            return await (0, compile_tolk_1.doCompileTolk)({
                entrypointFileName: config.entrypoint,
                fsReadCallback: (path) => (0, fs_1.readFileSync)(path).toString(),
                optimizationLevel: config.optimizationLevel,
                withStackComments: config.withStackComments,
                withSrcLineComments: config.withSrcLineComments,
                experimentalOptions: config.experimentalOptions,
            });
        }
        return await (0, compile_func_1.doCompileFunc)({
            targets: config.targets,
            sources: config.sources ?? ((path) => (0, fs_1.readFileSync)(path).toString()),
            optLevel: config.optLevel,
            debugInfo: config.debugInfo,
        });
    }
    return await (0, compile_tact_1.doCompileTact)(config, name);
}
function getCompilerName(config) {
    if ((0, CompilerConfig_1.isCompilableConfig)(config)) {
        return config.lang ?? 'func';
    }
    return 'tact';
}
async function getCompilerVersion(config) {
    if ((0, CompilerConfig_1.isCompilableConfig)(config)) {
        if (config.lang === 'tact') {
            return (0, compile_tact_1.getTactVersion)();
        }
        if (config.lang === 'tolk') {
            return (0, compile_tolk_1.getTolkVersion)();
        }
        return (0, compile_func_1.getFuncVersion)();
    }
    return (0, compile_tact_1.getTactVersion)();
}
async function getCompilerOptions(config) {
    return {
        lang: getCompilerName(config),
        version: await getCompilerVersion(config),
    };
}
async function doCompile(name, opts) {
    const config = await getCompilerConfigForContract(name);
    if (opts?.debugInfo && (0, CompilerConfig_1.isCompilableConfig)(config) && (config.lang === undefined || config.lang === 'func')) {
        config.debugInfo = true;
    }
    if ('preCompileHook' in config && config.preCompileHook !== undefined) {
        await config.preCompileHook({
            userData: opts?.hookUserData,
        });
    }
    const res = await doCompileInner(name, config);
    if ('postCompileHook' in config && config.postCompileHook !== undefined) {
        await config.postCompileHook(res.code, {
            userData: opts?.hookUserData,
        });
    }
    return res;
}
/**
 * Compiles a contract using the specified configuration for `tact`, `func`, or `tolk` languages.
 *
 * This function resolves the appropriate compiler configuration for a given contract name,
 * runs any defined pre-compile and post-compile hooks, and returns the resulting compiled code
 * as a [Cell]{@link Cell}.
 *
 * @param {string} name - The name of the contract to compile. This should correspond to a
 *                        file named `<name>.compile.ts` in the `compilables` or `wrappers` directory.
 * @param {CompileOpts} [opts] - Optional compilation options, including user data passed to hooks.
 *
 * @returns {Promise<Cell>} A promise that resolves to the compiled contract code as a `Cell`.
 *
 * @example
 * import { compile } from '@ton/blueprint';
 *
 * async function main() {
 *     const codeCell = await compile('Contract');
 *     console.log('Compiled code BOC:', codeCell.toBoc().toString('base64'));
 * }
 *
 * main();
 */
async function compile(name, opts) {
    const result = await doCompile(name, opts);
    return result.code;
}
