"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SendProviderSender_provider, _SendProviderSender_lastSendResult, _WrappedContractProvider_address, _WrappedContractProvider_provider, _WrappedContractProvider_init, _WrappedContractProvider_factory, _NetworkProviderImpl_tc, _NetworkProviderImpl_sender, _NetworkProviderImpl_network, _NetworkProviderImpl_explorer, _NetworkProviderImpl_ui;
Object.defineProperty(exports, "__esModule", { value: true });
exports.argSpec = void 0;
exports.createNetworkProvider = createNetworkProvider;
const path_1 = __importDefault(require("path"));
const core_1 = require("@ton/core");
const ton_1 = require("@ton/ton");
const ton_adapter_1 = require("@ton-api/ton-adapter");
const client_1 = require("@ton-api/client");
const crypto_1 = require("@ton/crypto");
const axios_1 = __importDefault(require("axios"));
const ton_lite_client_1 = require("ton-lite-client");
const utils_1 = require("../utils");
const DeeplinkProvider_1 = require("./send/DeeplinkProvider");
const TonConnectProvider_1 = require("./send/TonConnectProvider");
const FSStorage_1 = require("./storage/FSStorage");
const paths_1 = require("../paths");
const MnemonicProvider_1 = require("./send/MnemonicProvider");
const INITIAL_DELAY = 400;
const MAX_ATTEMPTS = 4;
const CONFIG_ADDRESS = core_1.Address.parse('-1:5555555555555555555555555555555555555555555555555555555555555555');
exports.argSpec = {
    '--mainnet': Boolean,
    '--testnet': Boolean,
    '--custom': String,
    '--custom-type': String,
    '--custom-version': String,
    '--custom-key': String,
    '--tonconnect': Boolean,
    '--deeplink': Boolean,
    '--mnemonic': Boolean,
    '--tonscan': Boolean,
    '--tonviewer': Boolean,
    '--toncx': Boolean,
    '--dton': Boolean,
};
class SendProviderSender {
    get lastSendResult() {
        return __classPrivateFieldGet(this, _SendProviderSender_lastSendResult, "f");
    }
    constructor(provider) {
        _SendProviderSender_provider.set(this, void 0);
        _SendProviderSender_lastSendResult.set(this, void 0);
        __classPrivateFieldSet(this, _SendProviderSender_provider, provider, "f");
        this.address = provider.address();
    }
    async send(args) {
        if (args.bounce !== undefined) {
            console.warn("Warning: blueprint's Sender does not support `bounce` flag, because it is ignored by all used Sender APIs");
            console.warn('To silence this warning, change your `bounce` flags passed to Senders to unset or undefined');
        }
        if (!(args.sendMode === undefined || args.sendMode === core_1.SendMode.PAY_GAS_SEPARATELY)) {
            throw new Error('Deployer sender does not support `sendMode` other than `PAY_GAS_SEPARATELY`');
        }
        __classPrivateFieldSet(this, _SendProviderSender_lastSendResult, await __classPrivateFieldGet(this, _SendProviderSender_provider, "f").sendTransaction(args.to, args.value, args.body ?? undefined, args.init ?? undefined), "f");
    }
}
_SendProviderSender_provider = new WeakMap(), _SendProviderSender_lastSendResult = new WeakMap();
class WrappedContractProvider {
    constructor(address, factory, init) {
        _WrappedContractProvider_address.set(this, void 0);
        _WrappedContractProvider_provider.set(this, void 0);
        _WrappedContractProvider_init.set(this, void 0);
        _WrappedContractProvider_factory.set(this, void 0);
        __classPrivateFieldSet(this, _WrappedContractProvider_address, address, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_provider, factory({ address, init }), "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_init, init, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_factory, factory, "f");
    }
    async getState() {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").getState();
    }
    async get(name, args) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").get(name, args);
    }
    async external(message) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").external(message);
    }
    async internal(via, args) {
        const init = __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") && (await this.getState()).state.type !== 'active' ? __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") : undefined;
        return await via.send({
            to: __classPrivateFieldGet(this, _WrappedContractProvider_address, "f"),
            value: typeof args.value === 'string' ? (0, core_1.toNano)(args.value) : args.value,
            sendMode: args.sendMode,
            bounce: args.bounce,
            init,
            body: typeof args.body === 'string' ? (0, core_1.comment)(args.body) : args.body,
        });
    }
    open(contract) {
        return (0, core_1.openContract)(contract, (params) => new WrappedContractProvider(params.address, __classPrivateFieldGet(this, _WrappedContractProvider_factory, "f"), params.init));
    }
    getTransactions(address, lt, hash, limit) {
        return __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").getTransactions(address, lt, hash, limit);
    }
}
_WrappedContractProvider_address = new WeakMap(), _WrappedContractProvider_provider = new WeakMap(), _WrappedContractProvider_init = new WeakMap(), _WrappedContractProvider_factory = new WeakMap();
class NetworkProviderImpl {
    constructor(tc, sender, network, explorer, ui) {
        _NetworkProviderImpl_tc.set(this, void 0);
        _NetworkProviderImpl_sender.set(this, void 0);
        _NetworkProviderImpl_network.set(this, void 0);
        _NetworkProviderImpl_explorer.set(this, void 0);
        _NetworkProviderImpl_ui.set(this, void 0);
        __classPrivateFieldSet(this, _NetworkProviderImpl_tc, tc, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_sender, sender, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_network, network, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_explorer, explorer, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_ui, ui, "f");
    }
    network() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f");
    }
    explorer() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f");
    }
    sender() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f");
    }
    api() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f");
    }
    provider(address, init) {
        const factory = (params) => __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(params.address, params.init && {
            ...params.init,
            data: params.init.data ?? undefined,
            code: params.init.code ?? undefined,
        });
        return new WrappedContractProvider(address, factory, init);
    }
    async isContractDeployed(address) {
        return (await __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(address).getState()).state.type === 'active';
    }
    async getConfig(address = CONFIG_ADDRESS) {
        const state = await this.getContractState(address);
        if (state.state.type !== 'active' || !state.state.data) {
            throw new Error('Configuration contract not active');
        }
        const paramsDict = core_1.Cell.fromBoc(state.state.data)[0]
            .beginParse()
            .loadRef()
            .beginParse()
            .loadDictDirect(core_1.Dictionary.Keys.Int(32), core_1.Dictionary.Values.Cell());
        const params = new Map();
        for (const [key, value] of paramsDict) {
            params.set(key, value.beginParse());
        }
        return (0, ton_1.parseFullConfig)(params);
    }
    async getContractState(address) {
        return await __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(address).getState();
    }
    async waitForDeploy(address, attempts = 20, sleepDuration = 2000) {
        if (attempts <= 0) {
            throw new Error('Attempt number must be positive');
        }
        for (let i = 1; i <= attempts; i++) {
            __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").setActionPrompt(`Awaiting contract deployment... [Attempt ${i}/${attempts}]`);
            const isDeployed = await this.isContractDeployed(address);
            if (isDeployed) {
                const formattedAddress = address.toString({ testOnly: __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f") === 'testnet' });
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`Contract deployed at address ${formattedAddress}`);
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`You can view it at ${(0, utils_1.getExplorerLink)(formattedAddress, __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f"), __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f"))}`);
                return;
            }
            await (0, utils_1.sleep)(sleepDuration);
        }
        __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
        throw new Error("Contract was not deployed. Check your wallet's transactions");
    }
    obtainInMessageHash() {
        const { lastSendResult } = __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f");
        if (typeof lastSendResult === 'object' &&
            lastSendResult !== null &&
            'boc' in lastSendResult &&
            typeof lastSendResult.boc === 'string') {
            const cell = core_1.Cell.fromBase64(lastSendResult.boc);
            const extMessage = (0, core_1.loadMessage)(cell.beginParse());
            return (0, utils_1.getNormalizedExtMessageHash)(extMessage);
        }
        throw new Error('Not implemented');
    }
    async getLastTransactions(address) {
        if (__classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f") instanceof ton_1.TonClient) {
            return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").getTransactions(address, { limit: 100, archival: true }); // without archival not working with tonclient
        }
        const provider = __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(address);
        const { last } = await provider.getState();
        if (!last) {
            return [];
        }
        return provider.getTransactions(address, last.lt, last.hash);
    }
    async isTransactionApplied(address, targetInMessageHash) {
        const provider = __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(address);
        const { last } = await provider.getState();
        if (!last) {
            return { isApplied: false };
        }
        let lastTxs;
        try {
            lastTxs = await this.getLastTransactions(address);
        }
        catch (_) {
            return { isApplied: false };
        }
        for (const transaction of lastTxs) {
            if (transaction.inMessage?.info.type !== 'external-in') {
                continue;
            }
            const inMessageHash = (0, utils_1.getNormalizedExtMessageHash)(transaction.inMessage);
            if (inMessageHash.equals(targetInMessageHash)) {
                return { isApplied: true, transaction };
            }
        }
        return { isApplied: false };
    }
    async waitForLastTransaction(waitAttempts = 20, sleepDuration = 2000) {
        let attempts = waitAttempts;
        if (attempts <= 0) {
            throw new Error('Attempt number must be positive');
        }
        if (!__classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").address) {
            throw new Error('Sender must have an address');
        }
        const inMessageHash = this.obtainInMessageHash();
        for (let i = 1; i <= attempts; i++) {
            __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").setActionPrompt(`Awaiting transaction... [Attempt ${i}/${attempts}]`);
            const result = await this.isTransactionApplied(__classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").address, inMessageHash);
            if (result.isApplied) {
                const { transaction } = result;
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`Transaction ${inMessageHash.toString('hex')} successfully applied!`);
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`You can view it at ${(0, utils_1.getTransactionLink)({
                    ...transaction,
                    hash: transaction.hash(),
                    address: __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").address,
                }, __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f"), __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f"))}`);
                return;
            }
            await (0, utils_1.sleep)(sleepDuration);
        }
        throw new Error("Transaction was not applied. Check your wallet's transactions");
    }
    /**
     * @deprecated
     *
     * Use your Contract's `sendDeploy` method (or similar) together with `waitForDeploy` instead.
     */
    async deploy(contract, value, body, waitAttempts = 10) {
        const isDeployed = await this.isContractDeployed(contract.address);
        if (isDeployed) {
            throw new Error('Contract is already deployed!');
        }
        if (!contract.init) {
            throw new Error('Contract has no init!');
        }
        await __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").send({
            to: contract.address,
            value,
            body,
            init: contract.init,
        });
        if (waitAttempts <= 0)
            return;
        await this.waitForDeploy(contract.address, waitAttempts);
    }
    open(contract) {
        return (0, core_1.openContract)(contract, (params) => this.provider(params.address, params.init ?? null));
    }
    ui() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f");
    }
}
_NetworkProviderImpl_tc = new WeakMap(), _NetworkProviderImpl_sender = new WeakMap(), _NetworkProviderImpl_network = new WeakMap(), _NetworkProviderImpl_explorer = new WeakMap(), _NetworkProviderImpl_ui = new WeakMap();
function getOptionalNumberEnv(envName) {
    const value = process.env[envName] ? Number(process.env[envName]) : undefined;
    if (value !== undefined && Number.isNaN(value)) {
        throw new Error(`Invalid ${envName} provided`);
    }
    return value;
}
async function createMnemonicProvider(client, network, ui) {
    const mnemonic = process.env.WALLET_MNEMONIC ?? '';
    const walletVersion = process.env.WALLET_VERSION ?? '';
    if (mnemonic.length === 0 || walletVersion.length === 0) {
        throw new Error('Mnemonic deployer was chosen, but env variables WALLET_MNEMONIC and WALLET_VERSION are not set');
    }
    const walletId = getOptionalNumberEnv('WALLET_ID');
    const subwalletNumber = getOptionalNumberEnv('SUBWALLET_NUMBER');
    const keyPair = await (0, crypto_1.mnemonicToPrivateKey)(mnemonic.split(' '));
    return new MnemonicProvider_1.MnemonicProvider({
        version: walletVersion.toLowerCase(),
        client,
        secretKey: keyPair.secretKey,
        ui,
        walletId,
        subwalletNumber,
        network,
    });
}
function intToIP(int) {
    const part1 = int & 255;
    const part2 = (int >> 8) & 255;
    const part3 = (int >> 16) & 255;
    const part4 = (int >> 24) & 255;
    return `${(part4 + 256) % 256}.${(part3 + 256) % 256}.${(part2 + 256) % 256}.${(part1 + 256) % 256}`;
}
async function buildLiteClient(configEndpoint) {
    const { data } = await axios_1.default.get(configEndpoint);
    if (!Array.isArray(data.liteservers)) {
        throw new Error(`Invalid liteclient configuration on ${configEndpoint}. Use https://ton.org/testnet-global.config.json for testnet or https://ton.org/global.config.json for mainnet.`);
    }
    const engines = data.liteservers.map((server) => {
        if (typeof server?.ip !== 'number' ||
            typeof server?.port !== 'number' ||
            typeof server?.id !== 'object' ||
            typeof server?.id?.key !== 'string') {
            throw new Error(`Invalid liteclient configuration on ${configEndpoint}`);
        }
        return new ton_lite_client_1.LiteSingleEngine({
            host: `tcp://${intToIP(server.ip)}:${server.port}`,
            publicKey: Buffer.from(server.id.key, 'base64'),
        });
    });
    const engine = new ton_lite_client_1.LiteRoundRobinEngine(engines);
    return new ton_lite_client_1.LiteClient({ engine });
}
class NetworkProviderBuilder {
    constructor(args, ui, config, allowCustom = true) {
        this.args = args;
        this.ui = ui;
        this.config = config;
        this.allowCustom = allowCustom;
    }
    async chooseNetwork() {
        let network = (0, utils_1.oneOrZeroOf)({
            mainnet: this.args['--mainnet'],
            testnet: this.args['--testnet'],
            custom: this.args['--custom'] !== undefined,
        });
        if (network !== undefined) {
            return network;
        }
        if (this.config?.network !== undefined) {
            return typeof this.config.network === 'string' ? this.config.network : 'custom';
        }
        network = await this.ui.choose('Which network do you want to use?', ['mainnet', 'testnet', 'custom'], (c) => c);
        if (network === 'custom') {
            const defaultCustomEndpoint = 'http://localhost:8081/';
            this.args['--custom'] = (await this.ui.input(`Provide a custom API v2 endpoint (default is ${defaultCustomEndpoint})`)).trim();
            if (this.args['--custom'] === '')
                this.args['--custom'] = defaultCustomEndpoint;
        }
        return network;
    }
    chooseExplorer() {
        return ((0, utils_1.oneOrZeroOf)({
            tonscan: this.args['--tonscan'],
            tonviewer: this.args['--tonviewer'],
            toncx: this.args['--toncx'],
            dton: this.args['--dton'],
        }) ?? 'tonscan');
    }
    async chooseSendProvider(network, client) {
        let deployUsing = (0, utils_1.oneOrZeroOf)({
            tonconnect: this.args['--tonconnect'],
            deeplink: this.args['--deeplink'],
            mnemonic: this.args['--mnemonic'],
        });
        if (!deployUsing) {
            deployUsing = (await this.ui.choose('Which wallet are you using?', [
                {
                    name: 'TON Connect compatible mobile wallet (example: Tonkeeper)',
                    value: 'tonconnect',
                },
                {
                    name: 'Create a ton:// deep link',
                    value: 'deeplink',
                },
                {
                    name: 'Mnemonic',
                    value: 'mnemonic',
                },
            ], (c) => c.name)).value;
        }
        const storagePath = path_1.default.join(paths_1.TEMP_DIR, network, deployUsing + '.json');
        let provider;
        switch (deployUsing) {
            case 'deeplink':
                provider = new DeeplinkProvider_1.DeeplinkProvider(network, this.ui);
                break;
            case 'tonconnect':
                if (network === 'custom')
                    throw new Error('Tonkeeper cannot work with custom network.');
                provider = new TonConnectProvider_1.TonConnectProvider(new FSStorage_1.FSStorage(storagePath), this.ui, network, this.config?.manifestUrl);
                break;
            case 'mnemonic':
                provider = await createMnemonicProvider(client, network, this.ui);
                break;
            default:
                throw new Error('Unknown deploy option');
        }
        return provider;
    }
    async build() {
        let network = await this.chooseNetwork();
        const explorer = this.chooseExplorer();
        if (network !== 'custom' &&
            (this.args['--custom-key'] !== undefined ||
                this.args['--custom-type'] !== undefined ||
                this.args['--custom-version'] !== undefined)) {
            throw new Error('Cannot use custom parameters with a non-custom network');
        }
        let tc;
        if (network === 'custom') {
            let configNetwork = undefined;
            if (this.config?.network !== undefined && typeof this.config.network !== 'string') {
                configNetwork = this.config.network;
            }
            if (this.args['--custom'] !== undefined) {
                const inputVer = this.args['--custom-version'];
                let version = undefined;
                if (inputVer !== undefined) {
                    version = inputVer.toLowerCase(); // checks come later
                }
                const inputType = this.args['--custom-type'];
                let type = undefined;
                if (inputType !== undefined) {
                    type = inputType; // checks come later
                }
                configNetwork = {
                    endpoint: this.args['--custom'],
                    version,
                    key: this.args['--custom-key'],
                    type,
                };
            }
            if (configNetwork === undefined) {
                throw new Error('Custom network is (somehow) undefined');
            }
            if (configNetwork.version === undefined || configNetwork.version === 'v2') {
                tc = new ton_1.TonClient({
                    endpoint: configNetwork.endpoint,
                    apiKey: configNetwork.key,
                });
            }
            else if (configNetwork.version === 'v4') {
                if (configNetwork.key !== undefined) {
                    throw new Error('Cannot use a custom API key with a v4 API');
                }
                tc = new ton_1.TonClient4({
                    endpoint: configNetwork.endpoint,
                });
            }
            else if (configNetwork.version === 'tonapi') {
                tc = new ton_adapter_1.ContractAdapter(new client_1.TonApiClient({
                    baseUrl: configNetwork.endpoint,
                    apiKey: configNetwork.key,
                }));
            }
            else if (configNetwork.version === 'liteclient') {
                tc = await buildLiteClient(configNetwork.endpoint);
            }
            else {
                throw new Error('Unknown API version: ' + configNetwork.version);
            }
            if (configNetwork.type !== undefined) {
                const ct = configNetwork.type.toLowerCase();
                if (!['mainnet', 'testnet', 'custom'].includes(ct)) {
                    throw new Error('Unknown network type: ' + ct);
                }
                network = ct;
            }
            else if (!this.allowCustom) {
                throw new Error('The usage of this network provider requires either mainnet or testnet');
            }
        }
        else {
            const httpAdapter = async (config) => {
                let r;
                let delay = INITIAL_DELAY;
                let attempts = 0;
                while (true) {
                    r = await (0, axios_1.default)({
                        ...config,
                        adapter: undefined,
                        validateStatus: (status) => (status >= 200 && status < 300) || status === 429,
                    });
                    if (r.status !== 429) {
                        return r;
                    }
                    await (0, utils_1.sleep)(delay);
                    delay *= 2;
                    attempts++;
                    if (attempts >= MAX_ATTEMPTS) {
                        throw new Error('Max attempts reached');
                    }
                }
            };
            tc = new ton_1.TonClient({
                timeout: this.config?.requestTimeout,
                endpoint: network === 'mainnet'
                    ? 'https://toncenter.com/api/v2/jsonRPC'
                    : 'https://testnet.toncenter.com/api/v2/jsonRPC',
                httpAdapter,
            });
        }
        const sendProvider = await this.chooseSendProvider(network, tc);
        try {
            await sendProvider.connect();
        }
        catch (_) {
            console.error('Unable to connect to wallet.');
            process.exit(1);
        }
        finally {
            this.ui.setActionPrompt('');
        }
        const sender = new SendProviderSender(sendProvider);
        return new NetworkProviderImpl(tc, sender, network, explorer, this.ui);
    }
}
async function createNetworkProvider(ui, args, config, allowCustom = true) {
    return await new NetworkProviderBuilder(args, ui, config, allowCustom).build();
}
