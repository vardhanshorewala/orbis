"use strict";
/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonApiClient = exports.ContentType = exports.PoolImplementationType = exports.TrustType = exports.JettonVerificationType = exports.BouncePhaseType = exports.ComputeSkipReason = exports.AccStatusChange = exports.TransactionType = exports.AccountStatus = void 0;
/** @example "active" */
var AccountStatus;
(function (AccountStatus) {
    AccountStatus["Nonexist"] = "nonexist";
    AccountStatus["Uninit"] = "uninit";
    AccountStatus["Active"] = "active";
    AccountStatus["Frozen"] = "frozen";
})(AccountStatus || (exports.AccountStatus = AccountStatus = {}));
/** @example "TransOrd" */
var TransactionType;
(function (TransactionType) {
    TransactionType["TransOrd"] = "TransOrd";
    TransactionType["TransTickTock"] = "TransTickTock";
    TransactionType["TransSplitPrepare"] = "TransSplitPrepare";
    TransactionType["TransSplitInstall"] = "TransSplitInstall";
    TransactionType["TransMergePrepare"] = "TransMergePrepare";
    TransactionType["TransMergeInstall"] = "TransMergeInstall";
    TransactionType["TransStorage"] = "TransStorage";
})(TransactionType || (exports.TransactionType = TransactionType = {}));
/** @example "acst_unchanged" */
var AccStatusChange;
(function (AccStatusChange) {
    AccStatusChange["AcstUnchanged"] = "acst_unchanged";
    AccStatusChange["AcstFrozen"] = "acst_frozen";
    AccStatusChange["AcstDeleted"] = "acst_deleted";
})(AccStatusChange || (exports.AccStatusChange = AccStatusChange = {}));
/** @example "cskip_no_state" */
var ComputeSkipReason;
(function (ComputeSkipReason) {
    ComputeSkipReason["CskipNoState"] = "cskip_no_state";
    ComputeSkipReason["CskipBadState"] = "cskip_bad_state";
    ComputeSkipReason["CskipNoGas"] = "cskip_no_gas";
})(ComputeSkipReason || (exports.ComputeSkipReason = ComputeSkipReason = {}));
/** @example "cskip_no_state" */
var BouncePhaseType;
(function (BouncePhaseType) {
    BouncePhaseType["TrPhaseBounceNegfunds"] = "TrPhaseBounceNegfunds";
    BouncePhaseType["TrPhaseBounceNofunds"] = "TrPhaseBounceNofunds";
    BouncePhaseType["TrPhaseBounceOk"] = "TrPhaseBounceOk";
})(BouncePhaseType || (exports.BouncePhaseType = BouncePhaseType = {}));
var JettonVerificationType;
(function (JettonVerificationType) {
    JettonVerificationType["Whitelist"] = "whitelist";
    JettonVerificationType["Blacklist"] = "blacklist";
    JettonVerificationType["None"] = "none";
})(JettonVerificationType || (exports.JettonVerificationType = JettonVerificationType = {}));
/** @example "whitelist" */
var TrustType;
(function (TrustType) {
    TrustType["Whitelist"] = "whitelist";
    TrustType["Graylist"] = "graylist";
    TrustType["Blacklist"] = "blacklist";
    TrustType["None"] = "none";
})(TrustType || (exports.TrustType = TrustType = {}));
var PoolImplementationType;
(function (PoolImplementationType) {
    PoolImplementationType["Whales"] = "whales";
    PoolImplementationType["Tf"] = "tf";
    PoolImplementationType["LiquidTF"] = "liquidTF";
})(PoolImplementationType || (exports.PoolImplementationType = PoolImplementationType = {}));
var ContentType;
(function (ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType || (exports.ContentType = ContentType = {}));
const core_1 = require("@ton/core");
// @ts-ignore
const parse_1 = __importDefault(require("core-js-pure/actual/json/parse"));
// @ts-ignore
const raw_json_1 = __importDefault(require("core-js-pure/actual/json/raw-json"));
// @ts-ignore
const stringify_1 = __importDefault(require("core-js-pure/actual/json/stringify"));
const JSONParse = (source) => (0, parse_1.default)(source, 
// @ts-ignore JSON bigint support from core-js
(_, value, context) => {
    if (typeof value === 'number') {
        const string = context.source;
        return Number.isSafeInteger(value)
            ? value
            : /[\.eE]/.test(string)
                ? value
                : BigInt(string);
    }
    return value;
});
const JSONStringify = (value) => (0, stringify_1.default)(value, 
// @ts-ignore JSON bigint support from core-js
(_, value) => {
    if (typeof value === 'bigint') {
        // @ts-ignore JSON rawJSON support from core-js
        return (0, raw_json_1.default)(value.toString());
    }
    return value;
});
class HttpClient {
    baseUrl = 'https://tonapi.io';
    abortControllers = new Map();
    providedFetch = null;
    customFetch = (...fetchParams) => this.providedFetch ? this.providedFetch(...fetchParams) : fetch(...fetchParams);
    baseApiParams = {
        credentials: 'same-origin',
        headers: {},
        redirect: 'follow',
        referrerPolicy: 'no-referrer'
    };
    constructor(apiConfig = {}) {
        const tonapi = typeof window !== 'undefined' && window && window.tonapi;
        const providedFetch = (tonapi && tonapi.fetch) ?? null;
        const baseApiParams = apiConfig.baseApiParams || {};
        const { apiKey, ...apiConfigWithoutApiKey } = apiConfig;
        const headers = {
            ...(baseApiParams.headers ?? {}),
            ...(apiKey ? { Authorization: `Bearer ${apiKey}` } : {}),
            'x-tonapi-client': `tonapi-js@0.2.0`
        };
        const preparedApiConfig = {
            ...apiConfigWithoutApiKey,
            providedFetch,
            baseApiParams: {
                ...baseApiParams,
                headers
            }
        };
        Object.assign(this, preparedApiConfig);
    }
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === 'number' ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v) => this.encodeQueryParam(key, v)).join('&');
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter(key => 'undefined' !== typeof query[key]);
        return keys
            .map(key => Array.isArray(query[key])
            ? this.addArrayQueryParam(query, key)
            : this.addQueryParam(query, key))
            .join('&');
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : '';
    }
    contentFormatters = {
        [ContentType.Json]: (input) => input !== null && (typeof input === 'object' || typeof input === 'string')
            ? JSONStringify(input)
            : input,
        [ContentType.Text]: (input) => input !== null && typeof input !== 'string' ? JSONStringify(input) : input,
        [ContentType.FormData]: (input) => Object.keys(input || {}).reduce((formData, key) => {
            const property = input[key];
            formData.append(key, property instanceof Blob
                ? property
                : typeof property === 'object' && property !== null
                    ? JSONStringify(property)
                    : `${property}`);
            return formData;
        }, new FormData()),
        [ContentType.UrlEncoded]: (input) => this.toQueryString(input)
    };
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...(params2 || {}),
            headers: {
                ...(this.baseApiParams.headers || {}),
                ...(params1.headers || {}),
                ...((params2 && params2.headers) || {})
            }
        };
    }
    createAbortSignal = (cancelToken) => {
        if (this.abortControllers.has(cancelToken)) {
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                return abortController.signal;
            }
            return void 0;
        }
        const abortController = new AbortController();
        this.abortControllers.set(cancelToken, abortController);
        return abortController.signal;
    };
    abortRequest = (cancelToken) => {
        const abortController = this.abortControllers.get(cancelToken);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(cancelToken);
        }
    };
    request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }) => {
        const requestParams = this.mergeRequestParams(params);
        const queryString = query && this.toQueryString(query);
        const contentType = type ?? ContentType.Json;
        const payloadFormatter = this.contentFormatters[contentType];
        const responseFormat = format || requestParams.format;
        return this.customFetch(`${baseUrl || this.baseUrl || ''}${path}${queryString ? `?${queryString}` : ''}`, {
            ...requestParams,
            headers: {
                ...(requestParams.headers || {}),
                ...(contentType && contentType !== ContentType.FormData
                    ? { 'Content-Type': contentType }
                    : {})
            },
            signal: (cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal) ||
                null,
            body: typeof body === 'undefined' || body === null ? null : payloadFormatter(body)
        }).then(async (response) => {
            const r = response.clone();
            r.data = null;
            r.error = null;
            const customResponseFormat = responseFormat === 'json' ? 'text' : responseFormat;
            const data = !customResponseFormat
                ? r
                : await response[customResponseFormat]()
                    .then(data => {
                    if (r.ok) {
                        r.data = responseFormat === 'json' ? JSONParse(data) : data;
                    }
                    else {
                        r.error = data;
                    }
                    return r;
                })
                    .catch(e => {
                    r.error = e;
                    return r;
                });
            if (cancelToken) {
                this.abortControllers.delete(cancelToken);
            }
            if (!response.ok)
                throw data;
            return data.data;
        });
    };
}
const components = {
    '#/components/schemas/Error': {
        type: 'object',
        required: ['error'],
        properties: { error: { type: 'string' } }
    },
    '#/components/schemas/AccountAddress': {
        type: 'object',
        required: ['address', 'is_scam', 'is_wallet'],
        properties: {
            address: { type: 'string', format: 'address' },
            name: { type: 'string' },
            is_scam: { type: 'boolean' },
            icon: { type: 'string' },
            is_wallet: { type: 'boolean' }
        }
    },
    '#/components/schemas/BlockCurrencyCollection': {
        type: 'object',
        required: ['grams', 'other'],
        properties: {
            grams: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            other: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['id', 'value'],
                    properties: {
                        id: { type: 'integer', format: 'int64' },
                        value: { type: 'string', 'x-js-format': 'bigint' }
                    }
                }
            }
        }
    },
    '#/components/schemas/BlockValueFlow': {
        type: 'object',
        required: [
            'from_prev_blk',
            'to_next_blk',
            'imported',
            'exported',
            'fees_collected',
            'fees_imported',
            'recovered',
            'created',
            'minted'
        ],
        properties: {
            from_prev_blk: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            to_next_blk: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            imported: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            exported: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            fees_collected: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            burned: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            fees_imported: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            recovered: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            created: { $ref: '#/components/schemas/BlockCurrencyCollection' },
            minted: { $ref: '#/components/schemas/BlockCurrencyCollection' }
        }
    },
    '#/components/schemas/ServiceStatus': {
        type: 'object',
        required: ['indexing_latency', 'rest_online', 'last_known_masterchain_seqno'],
        properties: {
            rest_online: { type: 'boolean', default: true },
            indexing_latency: { type: 'integer' },
            last_known_masterchain_seqno: { type: 'integer', format: 'int32' }
        }
    },
    '#/components/schemas/ReducedBlock': {
        type: 'object',
        required: [
            'workchain_id',
            'shard',
            'seqno',
            'tx_quantity',
            'utime',
            'shards_blocks',
            'parent'
        ],
        properties: {
            workchain_id: { type: 'integer', format: 'int32' },
            shard: { type: 'string' },
            seqno: { type: 'integer', format: 'int32' },
            master_ref: { type: 'string' },
            tx_quantity: { type: 'integer' },
            utime: { type: 'integer', format: 'int64' },
            shards_blocks: { type: 'array', items: { type: 'string' } },
            parent: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/BlockchainBlock': {
        type: 'object',
        required: [
            'workchain_id',
            'shard',
            'seqno',
            'root_hash',
            'file_hash',
            'global_id',
            'value_flow',
            'version',
            'after_merge',
            'before_split',
            'after_split',
            'want_split',
            'want_merge',
            'key_block',
            'gen_utime',
            'start_lt',
            'end_lt',
            'vert_seqno',
            'gen_catchain_seqno',
            'min_ref_mc_seqno',
            'prev_key_block_seqno',
            'prev_refs',
            'in_msg_descr_length',
            'out_msg_descr_length',
            'rand_seed',
            'created_by',
            'tx_quantity'
        ],
        properties: {
            tx_quantity: { type: 'integer' },
            value_flow: { $ref: '#/components/schemas/BlockValueFlow' },
            workchain_id: { type: 'integer', format: 'int32' },
            shard: { type: 'string' },
            seqno: { type: 'integer', format: 'int32' },
            root_hash: { type: 'string' },
            file_hash: { type: 'string' },
            global_id: { type: 'integer', format: 'int32' },
            version: { type: 'integer', format: 'int32' },
            after_merge: { type: 'boolean' },
            before_split: { type: 'boolean' },
            after_split: { type: 'boolean' },
            want_split: { type: 'boolean' },
            want_merge: { type: 'boolean' },
            key_block: { type: 'boolean' },
            gen_utime: { type: 'integer', format: 'int64' },
            start_lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            end_lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            vert_seqno: { type: 'integer', format: 'int32' },
            gen_catchain_seqno: { type: 'integer', format: 'int32' },
            min_ref_mc_seqno: { type: 'integer', format: 'int32' },
            prev_key_block_seqno: { type: 'integer', format: 'int32' },
            gen_software_version: { type: 'integer', format: 'int32' },
            gen_software_capabilities: { type: 'integer', format: 'int64' },
            master_ref: { type: 'string' },
            prev_refs: { type: 'array', items: { type: 'string' } },
            in_msg_descr_length: { type: 'integer', format: 'int64' },
            out_msg_descr_length: { type: 'integer', format: 'int64' },
            rand_seed: { type: 'string' },
            created_by: { type: 'string' }
        }
    },
    '#/components/schemas/BlockchainBlocks': {
        type: 'object',
        required: ['blocks'],
        properties: {
            blocks: { type: 'array', items: { $ref: '#/components/schemas/BlockchainBlock' } }
        }
    },
    '#/components/schemas/ReducedBlocks': {
        type: 'object',
        required: ['blocks'],
        properties: {
            blocks: { type: 'array', items: { $ref: '#/components/schemas/ReducedBlock' } }
        }
    },
    '#/components/schemas/BlockchainBlockShards': {
        type: 'object',
        required: ['shards'],
        properties: {
            shards: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['last_known_block_id', 'last_known_block'],
                    properties: {
                        last_known_block_id: { type: 'string' },
                        last_known_block: { $ref: '#/components/schemas/BlockchainBlock' }
                    }
                }
            }
        }
    },
    '#/components/schemas/AccountStatus': {
        type: 'string',
        enum: ['nonexist', 'uninit', 'active', 'frozen']
    },
    '#/components/schemas/StateInit': {
        type: 'object',
        required: ['boc', 'interfaces'],
        properties: {
            boc: { type: 'string', format: 'cell' },
            interfaces: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/Message': {
        type: 'object',
        required: [
            'msg_type',
            'created_lt',
            'ihr_disabled',
            'bounce',
            'bounced',
            'value',
            'fwd_fee',
            'ihr_fee',
            'import_fee',
            'created_at',
            'hash'
        ],
        properties: {
            msg_type: { type: 'string', enum: ['int_msg', 'ext_in_msg', 'ext_out_msg'] },
            created_lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            ihr_disabled: { type: 'boolean' },
            bounce: { type: 'boolean' },
            bounced: { type: 'boolean' },
            value: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            fwd_fee: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            ihr_fee: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            destination: { $ref: '#/components/schemas/AccountAddress' },
            source: { $ref: '#/components/schemas/AccountAddress' },
            import_fee: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            created_at: { type: 'integer', format: 'int64' },
            op_code: { type: 'string', 'x-js-format': 'bigint' },
            init: { $ref: '#/components/schemas/StateInit' },
            hash: { type: 'string' },
            raw_body: { type: 'string', format: 'cell' },
            decoded_op_name: { type: 'string' },
            decoded_body: {}
        }
    },
    '#/components/schemas/TransactionType': {
        type: 'string',
        enum: [
            'TransOrd',
            'TransTickTock',
            'TransSplitPrepare',
            'TransSplitInstall',
            'TransMergePrepare',
            'TransMergeInstall',
            'TransStorage'
        ]
    },
    '#/components/schemas/AccStatusChange': {
        type: 'string',
        enum: ['acst_unchanged', 'acst_frozen', 'acst_deleted']
    },
    '#/components/schemas/ComputeSkipReason': {
        type: 'string',
        enum: ['cskip_no_state', 'cskip_bad_state', 'cskip_no_gas']
    },
    '#/components/schemas/BouncePhaseType': {
        type: 'string',
        enum: ['TrPhaseBounceNegfunds', 'TrPhaseBounceNofunds', 'TrPhaseBounceOk']
    },
    '#/components/schemas/ComputePhase': {
        type: 'object',
        required: ['skipped'],
        properties: {
            skipped: { type: 'boolean' },
            skip_reason: { $ref: '#/components/schemas/ComputeSkipReason' },
            success: { type: 'boolean' },
            gas_fees: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            gas_used: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            vm_steps: { type: 'integer', format: 'int32' },
            exit_code: { type: 'integer', format: 'int32' },
            exit_code_description: { type: 'string' }
        }
    },
    '#/components/schemas/StoragePhase': {
        type: 'object',
        required: ['fees_collected', 'status_change'],
        properties: {
            fees_collected: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            fees_due: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            status_change: { $ref: '#/components/schemas/AccStatusChange' }
        }
    },
    '#/components/schemas/CreditPhase': {
        type: 'object',
        required: ['fees_collected', 'credit'],
        properties: {
            fees_collected: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            credit: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' }
        }
    },
    '#/components/schemas/ActionPhase': {
        type: 'object',
        required: [
            'success',
            'result_code',
            'total_actions',
            'skipped_actions',
            'fwd_fees',
            'total_fees'
        ],
        properties: {
            success: { type: 'boolean' },
            result_code: { type: 'integer', format: 'int32' },
            total_actions: { type: 'integer', format: 'int32' },
            skipped_actions: { type: 'integer', format: 'int32' },
            fwd_fees: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            total_fees: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            result_code_description: { type: 'string' }
        }
    },
    '#/components/schemas/Transaction': {
        type: 'object',
        required: [
            'hash',
            'lt',
            'account',
            'end_balance',
            'success',
            'utime',
            'orig_status',
            'end_status',
            'total_fees',
            'transaction_type',
            'state_update_old',
            'state_update_new',
            'out_msgs',
            'block',
            'aborted',
            'destroyed',
            'raw'
        ],
        properties: {
            hash: { type: 'string' },
            lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            account: { $ref: '#/components/schemas/AccountAddress' },
            success: { type: 'boolean' },
            utime: { type: 'integer', format: 'int64' },
            orig_status: { $ref: '#/components/schemas/AccountStatus' },
            end_status: { $ref: '#/components/schemas/AccountStatus' },
            total_fees: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            end_balance: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            transaction_type: { $ref: '#/components/schemas/TransactionType' },
            state_update_old: { type: 'string' },
            state_update_new: { type: 'string' },
            in_msg: { $ref: '#/components/schemas/Message' },
            out_msgs: { type: 'array', items: { $ref: '#/components/schemas/Message' } },
            block: { type: 'string' },
            prev_trans_hash: { type: 'string' },
            prev_trans_lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            compute_phase: { $ref: '#/components/schemas/ComputePhase' },
            storage_phase: { $ref: '#/components/schemas/StoragePhase' },
            credit_phase: { $ref: '#/components/schemas/CreditPhase' },
            action_phase: { $ref: '#/components/schemas/ActionPhase' },
            bounce_phase: { $ref: '#/components/schemas/BouncePhaseType' },
            aborted: { type: 'boolean' },
            destroyed: { type: 'boolean' },
            raw: { type: 'string', format: 'cell' }
        }
    },
    '#/components/schemas/Transactions': {
        type: 'object',
        required: ['transactions'],
        properties: {
            transactions: { type: 'array', items: { $ref: '#/components/schemas/Transaction' } }
        }
    },
    '#/components/schemas/ConfigProposalSetup': {
        type: 'object',
        required: [
            'min_tot_rounds',
            'max_tot_rounds',
            'min_wins',
            'max_losses',
            'min_store_sec',
            'max_store_sec',
            'bit_price',
            'cell_price'
        ],
        properties: {
            min_tot_rounds: { type: 'integer' },
            max_tot_rounds: { type: 'integer' },
            min_wins: { type: 'integer' },
            max_losses: { type: 'integer' },
            min_store_sec: { type: 'integer', format: 'int64' },
            max_store_sec: { type: 'integer', format: 'int64' },
            bit_price: { type: 'integer', format: 'int64' },
            cell_price: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/GasLimitPrices': {
        type: 'object',
        required: [
            'gas_price',
            'gas_limit',
            'gas_credit',
            'block_gas_limit',
            'freeze_due_limit',
            'delete_due_limit'
        ],
        properties: {
            special_gas_limit: { type: 'integer', format: 'int64' },
            flat_gas_limit: { type: 'integer', format: 'int64' },
            flat_gas_price: { type: 'integer', format: 'int64' },
            gas_price: { type: 'integer', format: 'int64' },
            gas_limit: { type: 'integer', format: 'int64' },
            gas_credit: { type: 'integer', format: 'int64' },
            block_gas_limit: { type: 'integer', format: 'int64' },
            freeze_due_limit: { type: 'integer', format: 'int64' },
            delete_due_limit: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/BlockParamLimits': {
        type: 'object',
        required: ['underload', 'soft_limit', 'hard_limit'],
        properties: {
            underload: { type: 'integer', format: 'int64' },
            soft_limit: { type: 'integer', format: 'int64' },
            hard_limit: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/BlockLimits': {
        type: 'object',
        required: ['bytes', 'gas', 'lt_delta'],
        properties: {
            bytes: { $ref: '#/components/schemas/BlockParamLimits' },
            gas: { $ref: '#/components/schemas/BlockParamLimits' },
            lt_delta: { $ref: '#/components/schemas/BlockParamLimits' }
        }
    },
    '#/components/schemas/MsgForwardPrices': {
        type: 'object',
        required: [
            'lump_price',
            'bit_price',
            'cell_price',
            'ihr_price_factor',
            'first_frac',
            'next_frac'
        ],
        properties: {
            lump_price: { type: 'integer', format: 'int64' },
            bit_price: { type: 'integer', format: 'int64' },
            cell_price: { type: 'integer', format: 'int64' },
            ihr_price_factor: { type: 'integer', format: 'int64' },
            first_frac: { type: 'integer', format: 'int64' },
            next_frac: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/WorkchainDescr': {
        type: 'object',
        required: [
            'workchain',
            'enabled_since',
            'actual_min_split',
            'min_split',
            'max_split',
            'basic',
            'active',
            'accept_msgs',
            'flags',
            'zerostate_root_hash',
            'zerostate_file_hash',
            'version'
        ],
        properties: {
            workchain: { type: 'integer', format: 'int' },
            enabled_since: { type: 'integer', format: 'int64' },
            actual_min_split: { type: 'integer', format: 'int' },
            min_split: { type: 'integer', format: 'int' },
            max_split: { type: 'integer', format: 'int' },
            basic: { type: 'integer' },
            active: { type: 'boolean' },
            accept_msgs: { type: 'boolean' },
            flags: { type: 'integer', format: 'int' },
            zerostate_root_hash: { type: 'string' },
            zerostate_file_hash: { type: 'string' },
            version: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/MisbehaviourPunishmentConfig': {
        type: 'object',
        required: [
            'default_flat_fine',
            'default_proportional_fine',
            'severity_flat_mult',
            'severity_proportional_mult',
            'unpunishable_interval',
            'long_interval',
            'long_flat_mult',
            'long_proportional_mult',
            'medium_interval',
            'medium_flat_mult',
            'medium_proportional_mult'
        ],
        properties: {
            default_flat_fine: { type: 'integer', format: 'int64' },
            default_proportional_fine: { type: 'integer', format: 'int64' },
            severity_flat_mult: { type: 'integer' },
            severity_proportional_mult: { type: 'integer' },
            unpunishable_interval: { type: 'integer' },
            long_interval: { type: 'integer' },
            long_flat_mult: { type: 'integer' },
            long_proportional_mult: { type: 'integer' },
            medium_interval: { type: 'integer' },
            medium_flat_mult: { type: 'integer' },
            medium_proportional_mult: { type: 'integer' }
        }
    },
    '#/components/schemas/SizeLimitsConfig': {
        type: 'object',
        required: [
            'max_msg_bits',
            'max_msg_cells',
            'max_library_cells',
            'max_vm_data_depth',
            'max_ext_msg_size',
            'max_ext_msg_depth'
        ],
        properties: {
            max_msg_bits: { type: 'integer', format: 'int64' },
            max_msg_cells: { type: 'integer', format: 'int64' },
            max_library_cells: { type: 'integer', format: 'int64' },
            max_vm_data_depth: { type: 'integer', format: 'int' },
            max_ext_msg_size: { type: 'integer', format: 'int64' },
            max_ext_msg_depth: { type: 'integer', format: 'int' },
            max_acc_state_cells: { type: 'integer', format: 'int64' },
            max_acc_state_bits: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/ValidatorsSet': {
        type: 'object',
        required: ['utime_since', 'utime_until', 'total', 'main', 'list'],
        properties: {
            utime_since: { type: 'integer' },
            utime_until: { type: 'integer' },
            total: { type: 'integer' },
            main: { type: 'integer' },
            total_weight: { type: 'string', 'x-js-format': 'bigint' },
            list: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['public_key', 'weight'],
                    properties: {
                        public_key: { type: 'string' },
                        weight: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
                        adnl_addr: { type: 'string' }
                    }
                }
            }
        }
    },
    '#/components/schemas/Oracle': {
        type: 'object',
        required: ['address', 'secp_pubkey'],
        properties: {
            address: { type: 'string', format: 'address' },
            secp_pubkey: { type: 'string' }
        }
    },
    '#/components/schemas/OracleBridgeParams': {
        type: 'object',
        required: ['bridge_addr', 'oracle_multisig_address', 'external_chain_address', 'oracles'],
        properties: {
            bridge_addr: { type: 'string', format: 'address' },
            oracle_multisig_address: { type: 'string', format: 'address' },
            external_chain_address: { type: 'string' },
            oracles: { type: 'array', items: { $ref: '#/components/schemas/Oracle' } }
        }
    },
    '#/components/schemas/JettonBridgePrices': {
        type: 'object',
        required: [
            'bridge_burn_fee',
            'bridge_mint_fee',
            'wallet_min_tons_for_storage',
            'wallet_gas_consumption',
            'minter_min_tons_for_storage',
            'discover_gas_consumption'
        ],
        properties: {
            bridge_burn_fee: { type: 'integer', format: 'int64' },
            bridge_mint_fee: { type: 'integer', format: 'int64' },
            wallet_min_tons_for_storage: { type: 'integer', format: 'int64' },
            wallet_gas_consumption: { type: 'integer', format: 'int64' },
            minter_min_tons_for_storage: { type: 'integer', format: 'int64' },
            discover_gas_consumption: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/JettonBridgeParams': {
        type: 'object',
        required: ['bridge_address', 'oracles_address', 'state_flags', 'oracles'],
        properties: {
            bridge_address: { type: 'string', format: 'address' },
            oracles_address: { type: 'string', format: 'address' },
            state_flags: { type: 'integer' },
            burn_bridge_fee: { type: 'integer', format: 'int64' },
            oracles: { type: 'array', items: { $ref: '#/components/schemas/Oracle' } },
            external_chain_address: { type: 'string' },
            prices: { $ref: '#/components/schemas/JettonBridgePrices' }
        }
    },
    '#/components/schemas/Validator': {
        type: 'object',
        required: ['address', 'adnl_address', 'stake', 'max_factor'],
        properties: {
            address: { type: 'string', format: 'address' },
            adnl_address: { type: 'string' },
            stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            max_factor: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/Validators': {
        type: 'object',
        required: ['validators', 'elect_at', 'elect_close', 'min_stake', 'total_stake'],
        properties: {
            elect_at: { type: 'integer', format: 'int64' },
            elect_close: { type: 'integer', format: 'int64' },
            min_stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            total_stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            validators: { type: 'array', items: { $ref: '#/components/schemas/Validator' } }
        }
    },
    '#/components/schemas/AccountStorageInfo': {
        type: 'object',
        required: ['used_cells', 'used_bits', 'used_public_cells', 'last_paid', 'due_payment'],
        properties: {
            used_cells: { type: 'integer', format: 'int64' },
            used_bits: { type: 'integer', format: 'int64' },
            used_public_cells: { type: 'integer', format: 'int64' },
            last_paid: { type: 'integer', format: 'int64' },
            due_payment: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' }
        }
    },
    '#/components/schemas/BlockchainRawAccount': {
        type: 'object',
        required: ['address', 'balance', 'status', 'last_transaction_lt', 'storage'],
        properties: {
            address: { type: 'string', format: 'address' },
            balance: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            extra_balance: { type: 'object', additionalProperties: { type: 'string' } },
            code: { type: 'string', format: 'cell' },
            data: { type: 'string', format: 'cell' },
            last_transaction_lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            last_transaction_hash: { type: 'string' },
            frozen_hash: { type: 'string' },
            status: { $ref: '#/components/schemas/AccountStatus' },
            storage: { $ref: '#/components/schemas/AccountStorageInfo' },
            libraries: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['public', 'root'],
                    properties: {
                        public: { type: 'boolean' },
                        root: { type: 'string', format: 'cell' }
                    }
                }
            }
        }
    },
    '#/components/schemas/Account': {
        type: 'object',
        required: ['address', 'balance', 'status', 'last_activity', 'get_methods', 'is_wallet'],
        properties: {
            address: { type: 'string', format: 'address' },
            balance: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            currencies_balance: { type: 'object', additionalProperties: true },
            last_activity: { type: 'integer', format: 'int64' },
            status: { $ref: '#/components/schemas/AccountStatus' },
            interfaces: { type: 'array', items: { type: 'string' } },
            name: { type: 'string' },
            is_scam: { type: 'boolean' },
            icon: { type: 'string' },
            memo_required: { type: 'boolean' },
            get_methods: { type: 'array', items: { type: 'string' } },
            is_suspended: { type: 'boolean' },
            is_wallet: { type: 'boolean' }
        }
    },
    '#/components/schemas/Accounts': {
        type: 'object',
        required: ['accounts'],
        properties: { accounts: { type: 'array', items: { $ref: '#/components/schemas/Account' } } }
    },
    '#/components/schemas/GaslessConfig': {
        type: 'object',
        required: ['gas_jettons', 'relay_address'],
        properties: {
            relay_address: { type: 'string', format: 'address' },
            gas_jettons: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['master_id'],
                    properties: { master_id: { type: 'string', format: 'address' } }
                }
            }
        }
    },
    '#/components/schemas/SignRawMessage': {
        type: 'object',
        required: ['address', 'amount'],
        properties: {
            address: { type: 'string', format: 'address' },
            amount: { type: 'string' },
            payload: { type: 'string', format: 'cell' },
            stateInit: { type: 'string', format: 'cell' }
        }
    },
    '#/components/schemas/SignRawParams': {
        type: 'object',
        required: ['messages', 'relay_address', 'commission', 'from', 'valid_until'],
        properties: {
            relay_address: { type: 'string', format: 'address' },
            commission: { type: 'string', 'x-js-format': 'bigint' },
            from: { type: 'string', format: 'address' },
            valid_until: { type: 'integer', format: 'int64' },
            messages: { type: 'array', items: { $ref: '#/components/schemas/SignRawMessage' } }
        }
    },
    '#/components/schemas/MethodExecutionResult': {
        type: 'object',
        required: ['success', 'exit_code', 'stack'],
        properties: {
            success: { type: 'boolean' },
            exit_code: { type: 'integer' },
            stack: { type: 'array', items: { $ref: '#/components/schemas/TvmStackRecord' } },
            decoded: {}
        }
    },
    '#/components/schemas/TvmStackRecord': {
        type: 'object',
        format: 'tuple-item',
        required: ['type'],
        properties: {
            type: { type: 'string', enum: ['cell', 'num', 'nan', 'null', 'tuple'] },
            cell: { type: 'string', format: 'cell' },
            slice: { type: 'string', format: 'cell' },
            num: { type: 'string' },
            tuple: { type: 'array', items: { $ref: '#/components/schemas/TvmStackRecord' } }
        }
    },
    '#/components/schemas/RawBlockchainConfig': {
        type: 'object',
        required: ['config'],
        properties: { config: { type: 'object', additionalProperties: true } }
    },
    '#/components/schemas/BlockchainConfig': {
        type: 'object',
        required: ['raw', '0', '1', '2', '4', '44'],
        properties: {
            '0': { type: 'string', format: 'address' },
            '1': { type: 'string', format: 'address' },
            '2': { type: 'string', format: 'address' },
            '3': { type: 'string', format: 'address' },
            '4': { type: 'string', format: 'address' },
            '5': {
                type: 'object',
                required: ['fee_burn_nom', 'fee_burn_denom'],
                properties: {
                    blackhole_addr: { type: 'string', format: 'address' },
                    fee_burn_nom: { type: 'integer', format: 'int64' },
                    fee_burn_denom: { type: 'integer', format: 'int64' }
                }
            },
            '6': {
                type: 'object',
                required: ['mint_new_price', 'mint_add_price'],
                properties: {
                    mint_new_price: { type: 'integer', format: 'int64' },
                    mint_add_price: { type: 'integer', format: 'int64' }
                }
            },
            '7': {
                type: 'object',
                required: ['currencies'],
                properties: {
                    currencies: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['currency_id', 'amount'],
                            properties: {
                                currency_id: { type: 'integer', format: 'int64' },
                                amount: { type: 'string' }
                            }
                        }
                    }
                }
            },
            '8': {
                type: 'object',
                required: ['version', 'capabilities'],
                properties: {
                    version: { type: 'integer', format: 'int64' },
                    capabilities: { type: 'integer', format: 'int64' }
                }
            },
            '9': {
                type: 'object',
                required: ['mandatory_params'],
                properties: {
                    mandatory_params: { type: 'array', items: { type: 'integer', format: 'int32' } }
                }
            },
            '10': {
                type: 'object',
                required: ['critical_params'],
                properties: {
                    critical_params: { type: 'array', items: { type: 'integer', format: 'int32' } }
                }
            },
            '11': {
                type: 'object',
                required: ['normal_params', 'critical_params'],
                properties: {
                    normal_params: { $ref: '#/components/schemas/ConfigProposalSetup' },
                    critical_params: { $ref: '#/components/schemas/ConfigProposalSetup' }
                }
            },
            '12': {
                type: 'object',
                required: ['workchains'],
                properties: {
                    workchains: {
                        type: 'array',
                        items: { $ref: '#/components/schemas/WorkchainDescr' }
                    }
                }
            },
            '13': {
                type: 'object',
                required: ['deposit', 'bit_price', 'cell_price'],
                properties: {
                    deposit: { type: 'integer', format: 'int64' },
                    bit_price: { type: 'integer', format: 'int64' },
                    cell_price: { type: 'integer', format: 'int64' }
                }
            },
            '14': {
                type: 'object',
                required: ['masterchain_block_fee', 'basechain_block_fee'],
                properties: {
                    masterchain_block_fee: { type: 'integer', format: 'int64' },
                    basechain_block_fee: { type: 'integer', format: 'int64' }
                }
            },
            '15': {
                type: 'object',
                required: [
                    'validators_elected_for',
                    'elections_start_before',
                    'elections_end_before',
                    'stake_held_for'
                ],
                properties: {
                    validators_elected_for: { type: 'integer', format: 'int64' },
                    elections_start_before: { type: 'integer', format: 'int64' },
                    elections_end_before: { type: 'integer', format: 'int64' },
                    stake_held_for: { type: 'integer', format: 'int64' }
                }
            },
            '16': {
                type: 'object',
                required: ['max_validators', 'max_main_validators', 'min_validators'],
                properties: {
                    max_validators: { type: 'integer' },
                    max_main_validators: { type: 'integer' },
                    min_validators: { type: 'integer' }
                }
            },
            '17': {
                type: 'object',
                required: ['min_stake', 'max_stake', 'min_total_stake', 'max_stake_factor'],
                properties: {
                    min_stake: { type: 'string' },
                    max_stake: { type: 'string' },
                    min_total_stake: { type: 'string' },
                    max_stake_factor: { type: 'integer', format: 'int64' }
                }
            },
            '18': {
                type: 'object',
                required: ['storage_prices'],
                properties: {
                    storage_prices: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: [
                                'utime_since',
                                'bit_price_ps',
                                'cell_price_ps',
                                'mc_bit_price_ps',
                                'mc_cell_price_ps'
                            ],
                            properties: {
                                utime_since: { type: 'integer', format: 'int64' },
                                bit_price_ps: { type: 'integer', format: 'int64' },
                                cell_price_ps: { type: 'integer', format: 'int64' },
                                mc_bit_price_ps: { type: 'integer', format: 'int64' },
                                mc_cell_price_ps: { type: 'integer', format: 'int64' }
                            }
                        }
                    }
                }
            },
            '20': {
                type: 'object',
                required: ['gas_limits_prices'],
                properties: { gas_limits_prices: { $ref: '#/components/schemas/GasLimitPrices' } }
            },
            '21': {
                type: 'object',
                required: ['gas_limits_prices'],
                properties: { gas_limits_prices: { $ref: '#/components/schemas/GasLimitPrices' } }
            },
            '22': {
                type: 'object',
                required: ['block_limits'],
                properties: { block_limits: { $ref: '#/components/schemas/BlockLimits' } }
            },
            '23': {
                type: 'object',
                required: ['block_limits'],
                properties: { block_limits: { $ref: '#/components/schemas/BlockLimits' } }
            },
            '24': {
                type: 'object',
                required: ['msg_forward_prices'],
                properties: {
                    msg_forward_prices: { $ref: '#/components/schemas/MsgForwardPrices' }
                }
            },
            '25': {
                type: 'object',
                required: ['msg_forward_prices'],
                properties: {
                    msg_forward_prices: { $ref: '#/components/schemas/MsgForwardPrices' }
                }
            },
            '28': {
                type: 'object',
                required: [
                    'mc_catchain_lifetime',
                    'shard_catchain_lifetime',
                    'shard_validators_lifetime',
                    'shard_validators_num'
                ],
                properties: {
                    mc_catchain_lifetime: { type: 'integer', format: 'int64' },
                    shard_catchain_lifetime: { type: 'integer', format: 'int64' },
                    shard_validators_lifetime: { type: 'integer', format: 'int64' },
                    shard_validators_num: { type: 'integer', format: 'int64' },
                    flags: { type: 'integer', format: 'int' },
                    shuffle_mc_validators: { type: 'boolean' }
                }
            },
            '29': {
                type: 'object',
                required: [
                    'round_candidates',
                    'next_candidate_delay_ms',
                    'consensus_timeout_ms',
                    'fast_attempts',
                    'attempt_duration',
                    'catchain_max_deps',
                    'max_block_bytes',
                    'max_collated_bytes'
                ],
                properties: {
                    flags: { type: 'integer', format: 'int' },
                    new_catchain_ids: { type: 'boolean' },
                    round_candidates: { type: 'integer', format: 'int64' },
                    next_candidate_delay_ms: { type: 'integer', format: 'int64' },
                    consensus_timeout_ms: { type: 'integer', format: 'int64' },
                    fast_attempts: { type: 'integer', format: 'int64' },
                    attempt_duration: { type: 'integer', format: 'int64' },
                    catchain_max_deps: { type: 'integer', format: 'int64' },
                    max_block_bytes: { type: 'integer', format: 'int64' },
                    max_collated_bytes: { type: 'integer', format: 'int64' },
                    proto_version: { type: 'integer', format: 'int64' },
                    catchain_max_blocks_coeff: { type: 'integer', format: 'int64' }
                }
            },
            '31': {
                type: 'object',
                required: ['fundamental_smc_addr'],
                properties: {
                    fundamental_smc_addr: {
                        type: 'array',
                        items: { type: 'string', format: 'address' }
                    }
                }
            },
            '32': { $ref: '#/components/schemas/ValidatorsSet' },
            '33': { $ref: '#/components/schemas/ValidatorsSet' },
            '34': { $ref: '#/components/schemas/ValidatorsSet' },
            '35': { $ref: '#/components/schemas/ValidatorsSet' },
            '36': { $ref: '#/components/schemas/ValidatorsSet' },
            '37': { $ref: '#/components/schemas/ValidatorsSet' },
            '40': {
                type: 'object',
                required: ['misbehaviour_punishment_config'],
                properties: {
                    misbehaviour_punishment_config: {
                        $ref: '#/components/schemas/MisbehaviourPunishmentConfig'
                    }
                }
            },
            '43': {
                type: 'object',
                required: ['size_limits_config'],
                properties: {
                    size_limits_config: { $ref: '#/components/schemas/SizeLimitsConfig' }
                }
            },
            '44': {
                type: 'object',
                required: ['accounts', 'suspended_until'],
                properties: {
                    accounts: { type: 'array', items: { type: 'string', format: 'address' } },
                    suspended_until: { type: 'integer' }
                }
            },
            '71': {
                type: 'object',
                required: ['oracle_bridge_params'],
                properties: {
                    oracle_bridge_params: { $ref: '#/components/schemas/OracleBridgeParams' }
                }
            },
            '72': {
                type: 'object',
                required: ['oracle_bridge_params'],
                properties: {
                    oracle_bridge_params: { $ref: '#/components/schemas/OracleBridgeParams' }
                }
            },
            '73': {
                type: 'object',
                required: ['oracle_bridge_params'],
                properties: {
                    oracle_bridge_params: { $ref: '#/components/schemas/OracleBridgeParams' }
                }
            },
            '79': {
                type: 'object',
                required: ['jetton_bridge_params'],
                properties: {
                    jetton_bridge_params: { $ref: '#/components/schemas/JettonBridgeParams' }
                }
            },
            '81': {
                type: 'object',
                required: ['jetton_bridge_params'],
                properties: {
                    jetton_bridge_params: { $ref: '#/components/schemas/JettonBridgeParams' }
                }
            },
            '82': {
                type: 'object',
                required: ['jetton_bridge_params'],
                properties: {
                    jetton_bridge_params: { $ref: '#/components/schemas/JettonBridgeParams' }
                }
            },
            raw: { type: 'string', format: 'cell' }
        }
    },
    '#/components/schemas/DomainNames': {
        type: 'object',
        required: ['domains'],
        properties: { domains: { type: 'array', items: { type: 'string' } } }
    },
    '#/components/schemas/DomainBid': {
        type: 'object',
        required: ['success', 'value', 'txTime', 'bidder', 'txHash'],
        properties: {
            success: { type: 'boolean', default: false },
            value: { type: 'integer', format: 'int64' },
            txTime: { type: 'integer', format: 'int64' },
            txHash: { type: 'string' },
            bidder: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/DomainBids': {
        type: 'object',
        required: ['data'],
        properties: { data: { type: 'array', items: { $ref: '#/components/schemas/DomainBid' } } }
    },
    '#/components/schemas/JettonVerificationType': {
        type: 'string',
        enum: ['whitelist', 'blacklist', 'none']
    },
    '#/components/schemas/JettonPreview': {
        type: 'object',
        required: ['address', 'name', 'symbol', 'decimals', 'verification', 'image'],
        properties: {
            address: { type: 'string', format: 'address' },
            name: { type: 'string' },
            symbol: { type: 'string' },
            decimals: { type: 'integer' },
            image: { type: 'string' },
            verification: { $ref: '#/components/schemas/JettonVerificationType' },
            custom_payload_api_uri: { type: 'string' }
        }
    },
    '#/components/schemas/JettonBalance': {
        type: 'object',
        required: ['balance', 'wallet_address', 'jetton'],
        properties: {
            balance: { type: 'string', 'x-js-format': 'bigint' },
            price: { $ref: '#/components/schemas/TokenRates' },
            wallet_address: { $ref: '#/components/schemas/AccountAddress' },
            jetton: { $ref: '#/components/schemas/JettonPreview' },
            extensions: { type: 'array', items: { type: 'string' } },
            lock: {
                type: 'object',
                required: ['amount', 'till'],
                properties: {
                    amount: { type: 'string', 'x-js-format': 'bigint' },
                    till: { type: 'integer', format: 'int64' }
                }
            }
        }
    },
    '#/components/schemas/JettonsBalances': {
        type: 'object',
        required: ['balances'],
        properties: {
            balances: { type: 'array', items: { $ref: '#/components/schemas/JettonBalance' } }
        }
    },
    '#/components/schemas/Price': {
        type: 'object',
        required: ['value', 'token_name'],
        properties: {
            value: { type: 'string', 'x-js-format': 'bigint' },
            token_name: { type: 'string' }
        }
    },
    '#/components/schemas/ImagePreview': {
        type: 'object',
        required: ['resolution', 'url'],
        properties: { resolution: { type: 'string' }, url: { type: 'string' } }
    },
    '#/components/schemas/NftApprovedBy': {
        type: 'array',
        items: { type: 'string', enum: ['getgems', 'tonkeeper', 'ton.diamonds'] }
    },
    '#/components/schemas/TrustType': {
        type: 'string',
        enum: ['whitelist', 'graylist', 'blacklist', 'none']
    },
    '#/components/schemas/Sale': {
        type: 'object',
        required: ['address', 'market', 'price'],
        properties: {
            address: { type: 'string', format: 'address' },
            market: { $ref: '#/components/schemas/AccountAddress' },
            owner: { $ref: '#/components/schemas/AccountAddress' },
            price: { $ref: '#/components/schemas/Price' }
        }
    },
    '#/components/schemas/NftItem': {
        type: 'object',
        required: ['address', 'index', 'verified', 'metadata', 'approved_by', 'trust'],
        properties: {
            address: { type: 'string', format: 'address' },
            index: { type: 'integer', format: 'int64' },
            owner: { $ref: '#/components/schemas/AccountAddress' },
            collection: {
                type: 'object',
                required: ['address', 'name', 'description'],
                properties: {
                    address: { type: 'string', format: 'address' },
                    name: { type: 'string' },
                    description: { type: 'string' }
                }
            },
            verified: { type: 'boolean' },
            metadata: { type: 'object', additionalProperties: true },
            sale: { $ref: '#/components/schemas/Sale' },
            previews: { type: 'array', items: { $ref: '#/components/schemas/ImagePreview' } },
            dns: { type: 'string' },
            approved_by: {
                deprecated: true,
                description: 'please use trust field',
                $ref: '#/components/schemas/NftApprovedBy'
            },
            include_cnft: { type: 'boolean' },
            trust: { $ref: '#/components/schemas/TrustType' }
        }
    },
    '#/components/schemas/NftItems': {
        type: 'object',
        required: ['nft_items'],
        properties: {
            nft_items: { type: 'array', items: { $ref: '#/components/schemas/NftItem' } }
        }
    },
    '#/components/schemas/Multisigs': {
        type: 'object',
        required: ['multisigs'],
        properties: {
            multisigs: { type: 'array', items: { $ref: '#/components/schemas/Multisig' } }
        }
    },
    '#/components/schemas/Multisig': {
        type: 'object',
        required: ['address', 'seqno', 'threshold', 'signers', 'proposers', 'orders'],
        properties: {
            address: { type: 'string', format: 'address' },
            seqno: { type: 'integer', format: 'int64' },
            threshold: { type: 'integer', format: 'int32' },
            signers: { type: 'array', items: { type: 'string', format: 'address' } },
            proposers: { type: 'array', items: { type: 'string', format: 'address' } },
            orders: { type: 'array', items: { $ref: '#/components/schemas/MultisigOrder' } }
        }
    },
    '#/components/schemas/MultisigOrder': {
        type: 'object',
        required: [
            'address',
            'order_seqno',
            'threshold',
            'sent_for_execution',
            'signers',
            'approvals_num',
            'expiration_date',
            'risk',
            'creation_date',
            'signed_by'
        ],
        properties: {
            address: { type: 'string', format: 'address' },
            order_seqno: { type: 'integer', format: 'int64' },
            threshold: { type: 'integer', format: 'int32' },
            sent_for_execution: { type: 'boolean' },
            signers: { type: 'array', items: { type: 'string', format: 'address' } },
            approvals_num: { type: 'integer', format: 'int32' },
            expiration_date: { type: 'integer', format: 'int64' },
            risk: { $ref: '#/components/schemas/Risk' },
            creation_date: { type: 'integer', format: 'int64' },
            signed_by: { type: 'array', items: { type: 'string', format: 'address' } }
        }
    },
    '#/components/schemas/Refund': {
        type: 'object',
        required: ['type', 'origin'],
        properties: {
            type: { type: 'string', enum: ['DNS.ton', 'DNS.tg', 'GetGems'] },
            origin: { type: 'string' }
        }
    },
    '#/components/schemas/ValueFlow': {
        type: 'object',
        required: ['account', 'ton', 'fees'],
        properties: {
            account: { $ref: '#/components/schemas/AccountAddress' },
            ton: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            fees: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            jettons: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['account', 'quantity', 'jetton'],
                    properties: {
                        account: { $ref: '#/components/schemas/AccountAddress' },
                        jetton: { $ref: '#/components/schemas/JettonPreview' },
                        quantity: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' }
                    }
                }
            }
        }
    },
    '#/components/schemas/Action': {
        type: 'object',
        required: ['type', 'status', 'simple_preview', 'base_transactions'],
        properties: {
            type: {
                type: 'string',
                enum: [
                    'TonTransfer',
                    'JettonTransfer',
                    'JettonBurn',
                    'JettonMint',
                    'NftItemTransfer',
                    'ContractDeploy',
                    'Subscribe',
                    'UnSubscribe',
                    'AuctionBid',
                    'NftPurchase',
                    'DepositStake',
                    'WithdrawStake',
                    'WithdrawStakeRequest',
                    'JettonSwap',
                    'SmartContractExec',
                    'ElectionsRecoverStake',
                    'ElectionsDepositStake',
                    'DomainRenew',
                    'InscriptionTransfer',
                    'InscriptionMint',
                    'Unknown'
                ]
            },
            status: { type: 'string', enum: ['ok', 'failed'] },
            TonTransfer: { $ref: '#/components/schemas/TonTransferAction' },
            ContractDeploy: { $ref: '#/components/schemas/ContractDeployAction' },
            JettonTransfer: { $ref: '#/components/schemas/JettonTransferAction' },
            JettonBurn: { $ref: '#/components/schemas/JettonBurnAction' },
            JettonMint: { $ref: '#/components/schemas/JettonMintAction' },
            NftItemTransfer: { $ref: '#/components/schemas/NftItemTransferAction' },
            Subscribe: { $ref: '#/components/schemas/SubscriptionAction' },
            UnSubscribe: { $ref: '#/components/schemas/UnSubscriptionAction' },
            AuctionBid: { $ref: '#/components/schemas/AuctionBidAction' },
            NftPurchase: { $ref: '#/components/schemas/NftPurchaseAction' },
            DepositStake: { $ref: '#/components/schemas/DepositStakeAction' },
            WithdrawStake: { $ref: '#/components/schemas/WithdrawStakeAction' },
            WithdrawStakeRequest: { $ref: '#/components/schemas/WithdrawStakeRequestAction' },
            ElectionsDepositStake: { $ref: '#/components/schemas/ElectionsDepositStakeAction' },
            ElectionsRecoverStake: { $ref: '#/components/schemas/ElectionsRecoverStakeAction' },
            JettonSwap: { $ref: '#/components/schemas/JettonSwapAction' },
            SmartContractExec: { $ref: '#/components/schemas/SmartContractAction' },
            DomainRenew: { $ref: '#/components/schemas/DomainRenewAction' },
            InscriptionTransfer: { $ref: '#/components/schemas/InscriptionTransferAction' },
            InscriptionMint: { $ref: '#/components/schemas/InscriptionMintAction' },
            simple_preview: { $ref: '#/components/schemas/ActionSimplePreview' },
            base_transactions: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/TonTransferAction': {
        type: 'object',
        required: ['sender', 'recipient', 'amount'],
        properties: {
            sender: { $ref: '#/components/schemas/AccountAddress' },
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            comment: { type: 'string' },
            encrypted_comment: { $ref: '#/components/schemas/EncryptedComment' },
            refund: { $ref: '#/components/schemas/Refund' }
        }
    },
    '#/components/schemas/SmartContractAction': {
        type: 'object',
        required: ['executor', 'contract', 'ton_attached', 'operation'],
        properties: {
            executor: { $ref: '#/components/schemas/AccountAddress' },
            contract: { $ref: '#/components/schemas/AccountAddress' },
            ton_attached: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            operation: { type: 'string' },
            payload: { type: 'string' },
            refund: { $ref: '#/components/schemas/Refund' }
        }
    },
    '#/components/schemas/DomainRenewAction': {
        type: 'object',
        required: ['domain', 'contract_address', 'renewer'],
        properties: {
            domain: { type: 'string' },
            contract_address: { type: 'string', format: 'address' },
            renewer: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/InscriptionMintAction': {
        type: 'object',
        required: ['type', 'ticker', 'recipient', 'amount', 'decimals'],
        properties: {
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            amount: { type: 'string', 'x-js-format': 'bigint' },
            type: { type: 'string', enum: ['ton20', 'gram20'] },
            ticker: { type: 'string' },
            decimals: { type: 'integer' }
        }
    },
    '#/components/schemas/InscriptionTransferAction': {
        type: 'object',
        required: ['sender', 'recipient', 'amount', 'type', 'ticker', 'decimals'],
        properties: {
            sender: { $ref: '#/components/schemas/AccountAddress' },
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            amount: { type: 'string', 'x-js-format': 'bigint' },
            comment: { type: 'string' },
            type: { type: 'string', enum: ['ton20', 'gram20'] },
            ticker: { type: 'string' },
            decimals: { type: 'integer' }
        }
    },
    '#/components/schemas/NftItemTransferAction': {
        type: 'object',
        required: ['nft'],
        properties: {
            sender: { $ref: '#/components/schemas/AccountAddress' },
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            nft: { type: 'string' },
            comment: { type: 'string' },
            encrypted_comment: { $ref: '#/components/schemas/EncryptedComment' },
            payload: { type: 'string' },
            refund: { $ref: '#/components/schemas/Refund' }
        }
    },
    '#/components/schemas/JettonTransferAction': {
        type: 'object',
        required: ['amount', 'jetton', 'senders_wallet', 'recipients_wallet'],
        properties: {
            sender: { $ref: '#/components/schemas/AccountAddress' },
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            senders_wallet: { type: 'string', format: 'address' },
            recipients_wallet: { type: 'string', format: 'address' },
            amount: { type: 'string', 'x-js-format': 'bigint' },
            comment: { type: 'string' },
            encrypted_comment: { $ref: '#/components/schemas/EncryptedComment' },
            refund: { $ref: '#/components/schemas/Refund' },
            jetton: { $ref: '#/components/schemas/JettonPreview' }
        }
    },
    '#/components/schemas/JettonBurnAction': {
        type: 'object',
        required: ['amount', 'jetton', 'sender', 'senders_wallet'],
        properties: {
            sender: { $ref: '#/components/schemas/AccountAddress' },
            senders_wallet: { type: 'string', format: 'address' },
            amount: { type: 'string', 'x-js-format': 'bigint' },
            jetton: { $ref: '#/components/schemas/JettonPreview' }
        }
    },
    '#/components/schemas/JettonMintAction': {
        type: 'object',
        required: ['amount', 'jetton', 'recipient', 'recipients_wallet'],
        properties: {
            recipient: { $ref: '#/components/schemas/AccountAddress' },
            recipients_wallet: { type: 'string', format: 'address' },
            amount: { type: 'string', 'x-js-format': 'bigint' },
            jetton: { $ref: '#/components/schemas/JettonPreview' }
        }
    },
    '#/components/schemas/ContractDeployAction': {
        type: 'object',
        required: ['address', 'interfaces'],
        properties: {
            address: { type: 'string', format: 'address' },
            interfaces: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/SubscriptionAction': {
        type: 'object',
        required: ['subscriber', 'subscription', 'beneficiary', 'amount', 'initial'],
        properties: {
            subscriber: { $ref: '#/components/schemas/AccountAddress' },
            subscription: { type: 'string', format: 'address' },
            beneficiary: { $ref: '#/components/schemas/AccountAddress' },
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            initial: { type: 'boolean' }
        }
    },
    '#/components/schemas/UnSubscriptionAction': {
        type: 'object',
        required: ['subscriber', 'subscription', 'beneficiary'],
        properties: {
            subscriber: { $ref: '#/components/schemas/AccountAddress' },
            subscription: { type: 'string', format: 'address' },
            beneficiary: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/AuctionBidAction': {
        type: 'object',
        required: ['amount', 'bidder', 'auction', 'auction_type'],
        properties: {
            auction_type: { type: 'string', enum: ['DNS.ton', 'DNS.tg', 'NUMBER.tg', 'getgems'] },
            amount: { $ref: '#/components/schemas/Price' },
            nft: { $ref: '#/components/schemas/NftItem' },
            bidder: { $ref: '#/components/schemas/AccountAddress' },
            auction: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/DepositStakeAction': {
        type: 'object',
        required: ['amount', 'staker', 'pool', 'implementation'],
        properties: {
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            staker: { $ref: '#/components/schemas/AccountAddress' },
            pool: { $ref: '#/components/schemas/AccountAddress' },
            implementation: { $ref: '#/components/schemas/PoolImplementationType' }
        }
    },
    '#/components/schemas/WithdrawStakeAction': {
        type: 'object',
        required: ['amount', 'staker', 'pool', 'implementation'],
        properties: {
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            staker: { $ref: '#/components/schemas/AccountAddress' },
            pool: { $ref: '#/components/schemas/AccountAddress' },
            implementation: { $ref: '#/components/schemas/PoolImplementationType' }
        }
    },
    '#/components/schemas/WithdrawStakeRequestAction': {
        type: 'object',
        required: ['staker', 'pool', 'implementation'],
        properties: {
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            staker: { $ref: '#/components/schemas/AccountAddress' },
            pool: { $ref: '#/components/schemas/AccountAddress' },
            implementation: { $ref: '#/components/schemas/PoolImplementationType' }
        }
    },
    '#/components/schemas/ElectionsRecoverStakeAction': {
        type: 'object',
        required: ['amount', 'staker'],
        properties: {
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            staker: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/ElectionsDepositStakeAction': {
        type: 'object',
        required: ['amount', 'staker'],
        properties: {
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            staker: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/JettonSwapAction': {
        type: 'object',
        required: ['dex', 'amount_in', 'amount_out', 'user_wallet', 'router'],
        properties: {
            dex: { type: 'string', enum: ['stonfi', 'dedust', 'megatonfi'] },
            amount_in: { type: 'string', 'x-js-format': 'bigint' },
            amount_out: { type: 'string', 'x-js-format': 'bigint' },
            ton_in: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            ton_out: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            user_wallet: { $ref: '#/components/schemas/AccountAddress' },
            router: { $ref: '#/components/schemas/AccountAddress' },
            jetton_master_in: { $ref: '#/components/schemas/JettonPreview' },
            jetton_master_out: { $ref: '#/components/schemas/JettonPreview' }
        }
    },
    '#/components/schemas/NftPurchaseAction': {
        type: 'object',
        required: ['amount', 'seller', 'buyer', 'auction_type', 'nft'],
        properties: {
            auction_type: { type: 'string', enum: ['DNS.ton', 'DNS.tg', 'NUMBER.tg', 'getgems'] },
            amount: { $ref: '#/components/schemas/Price' },
            nft: { $ref: '#/components/schemas/NftItem' },
            seller: { $ref: '#/components/schemas/AccountAddress' },
            buyer: { $ref: '#/components/schemas/AccountAddress' }
        }
    },
    '#/components/schemas/ActionSimplePreview': {
        type: 'object',
        required: ['name', 'description', 'accounts'],
        properties: {
            name: { type: 'string' },
            description: { type: 'string' },
            action_image: { type: 'string' },
            value: { type: 'string' },
            value_image: { type: 'string' },
            accounts: { type: 'array', items: { $ref: '#/components/schemas/AccountAddress' } }
        }
    },
    '#/components/schemas/AccountEvent': {
        type: 'object',
        required: [
            'event_id',
            'timestamp',
            'actions',
            'account',
            'is_scam',
            'lt',
            'in_progress',
            'extra'
        ],
        properties: {
            event_id: { type: 'string' },
            account: { $ref: '#/components/schemas/AccountAddress' },
            timestamp: { type: 'integer', format: 'int64' },
            actions: { type: 'array', items: { $ref: '#/components/schemas/Action' } },
            is_scam: { type: 'boolean' },
            lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            in_progress: { type: 'boolean' },
            extra: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/AccountEvents': {
        type: 'object',
        required: ['events', 'next_from'],
        properties: {
            events: { type: 'array', items: { $ref: '#/components/schemas/AccountEvent' } },
            next_from: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/TraceID': {
        type: 'object',
        required: ['id', 'utime'],
        properties: { id: { type: 'string' }, utime: { type: 'integer', format: 'int64' } }
    },
    '#/components/schemas/TraceIDs': {
        type: 'object',
        required: ['traces'],
        properties: { traces: { type: 'array', items: { $ref: '#/components/schemas/TraceID' } } }
    },
    '#/components/schemas/ApyHistory': {
        type: 'object',
        required: ['apy', 'time'],
        properties: { apy: { type: 'number' }, time: { type: 'integer' } }
    },
    '#/components/schemas/Subscription': {
        type: 'object',
        required: [
            'address',
            'wallet_address',
            'beneficiary_address',
            'amount',
            'period',
            'start_time',
            'timeout',
            'last_payment_time',
            'last_request_time',
            'subscription_id',
            'failed_attempts'
        ],
        properties: {
            address: { type: 'string', format: 'address' },
            wallet_address: { type: 'string', format: 'address' },
            beneficiary_address: { type: 'string', format: 'address' },
            amount: { type: 'integer', format: 'int64' },
            period: { type: 'integer', format: 'int64' },
            start_time: { type: 'integer', format: 'int64' },
            timeout: { type: 'integer', format: 'int64' },
            last_payment_time: { type: 'integer', format: 'int64' },
            last_request_time: { type: 'integer', format: 'int64' },
            subscription_id: { type: 'integer', format: 'int64' },
            failed_attempts: { type: 'integer', format: 'int32' }
        }
    },
    '#/components/schemas/Subscriptions': {
        type: 'object',
        required: ['subscriptions'],
        properties: {
            subscriptions: { type: 'array', items: { $ref: '#/components/schemas/Subscription' } }
        }
    },
    '#/components/schemas/Auction': {
        type: 'object',
        required: ['domain', 'owner', 'price', 'bids', 'date'],
        properties: {
            domain: { type: 'string' },
            owner: { type: 'string', format: 'address' },
            price: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            bids: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            date: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/Auctions': {
        type: 'object',
        required: ['data', 'total'],
        properties: {
            data: { type: 'array', items: { $ref: '#/components/schemas/Auction' } },
            total: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/WalletDNS': {
        type: 'object',
        required: [
            'address',
            'is_wallet',
            'has_method_pubkey',
            'has_method_seqno',
            'names',
            'account'
        ],
        properties: {
            address: { type: 'string', format: 'address' },
            account: { $ref: '#/components/schemas/AccountAddress' },
            is_wallet: { type: 'boolean' },
            has_method_pubkey: { type: 'boolean' },
            has_method_seqno: { type: 'boolean' },
            names: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/DomainInfo': {
        type: 'object',
        required: ['name'],
        properties: {
            name: { type: 'string' },
            expiring_at: { type: 'integer', format: 'int64' },
            item: { $ref: '#/components/schemas/NftItem' }
        }
    },
    '#/components/schemas/DnsRecord': {
        type: 'object',
        required: ['sites'],
        properties: {
            wallet: { $ref: '#/components/schemas/WalletDNS' },
            next_resolver: { type: 'string', format: 'address' },
            sites: { type: 'array', items: { type: 'string' } },
            storage: { type: 'string' }
        }
    },
    '#/components/schemas/NftCollection': {
        type: 'object',
        required: ['address', 'next_item_index', 'raw_collection_content', 'approved_by'],
        properties: {
            address: { type: 'string', format: 'address' },
            next_item_index: { type: 'integer', format: 'int64' },
            owner: { $ref: '#/components/schemas/AccountAddress' },
            raw_collection_content: { type: 'string', format: 'cell' },
            metadata: { type: 'object', additionalProperties: true },
            previews: { type: 'array', items: { $ref: '#/components/schemas/ImagePreview' } },
            approved_by: { $ref: '#/components/schemas/NftApprovedBy' }
        }
    },
    '#/components/schemas/NftCollections': {
        type: 'object',
        required: ['nft_collections'],
        properties: {
            nft_collections: {
                type: 'array',
                items: { $ref: '#/components/schemas/NftCollection' }
            }
        }
    },
    '#/components/schemas/Trace': {
        type: 'object',
        required: ['transaction', 'interfaces'],
        properties: {
            transaction: { $ref: '#/components/schemas/Transaction' },
            interfaces: { type: 'array', items: { type: 'string' } },
            children: { type: 'array', items: { $ref: '#/components/schemas/Trace' } },
            emulated: { type: 'boolean' }
        }
    },
    '#/components/schemas/MessageConsequences': {
        type: 'object',
        required: ['trace', 'risk', 'event'],
        properties: {
            trace: { $ref: '#/components/schemas/Trace' },
            risk: { $ref: '#/components/schemas/Risk' },
            event: { $ref: '#/components/schemas/AccountEvent' }
        }
    },
    '#/components/schemas/Risk': {
        type: 'object',
        required: ['transfer_all_remaining_balance', 'ton', 'jettons', 'nfts'],
        properties: {
            transfer_all_remaining_balance: { type: 'boolean' },
            ton: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            jettons: { type: 'array', items: { $ref: '#/components/schemas/JettonQuantity' } },
            nfts: { type: 'array', items: { $ref: '#/components/schemas/NftItem' } }
        }
    },
    '#/components/schemas/JettonQuantity': {
        type: 'object',
        required: ['quantity', 'wallet_address', 'jetton'],
        properties: {
            quantity: { type: 'string', 'x-js-format': 'bigint' },
            wallet_address: { $ref: '#/components/schemas/AccountAddress' },
            jetton: { $ref: '#/components/schemas/JettonPreview' }
        }
    },
    '#/components/schemas/DecodedMessage': {
        type: 'object',
        required: ['destination', 'destination_wallet_version'],
        properties: {
            destination: { $ref: '#/components/schemas/AccountAddress' },
            destination_wallet_version: { type: 'string' },
            ext_in_msg_decoded: {
                type: 'object',
                properties: {
                    wallet_v3: {
                        type: 'object',
                        required: ['subwallet_id', 'valid_until', 'seqno', 'op', 'raw_messages'],
                        properties: {
                            subwallet_id: { type: 'integer', format: 'int64' },
                            valid_until: { type: 'integer', format: 'int64' },
                            seqno: { type: 'integer', format: 'int64' },
                            raw_messages: {
                                type: 'array',
                                items: { $ref: '#/components/schemas/DecodedRawMessage' }
                            }
                        }
                    },
                    wallet_v4: {
                        type: 'object',
                        required: ['subwallet_id', 'valid_until', 'seqno', 'op', 'raw_messages'],
                        properties: {
                            subwallet_id: { type: 'integer', format: 'int64' },
                            valid_until: { type: 'integer', format: 'int64' },
                            seqno: { type: 'integer', format: 'int64' },
                            op: { type: 'integer', format: 'int32' },
                            raw_messages: {
                                type: 'array',
                                items: { $ref: '#/components/schemas/DecodedRawMessage' }
                            }
                        }
                    },
                    wallet_highload_v2: {
                        type: 'object',
                        required: ['subwallet_id', 'bounded_query_id', 'raw_messages'],
                        properties: {
                            subwallet_id: { type: 'integer', format: 'int64' },
                            bounded_query_id: { type: 'string' },
                            raw_messages: {
                                type: 'array',
                                items: { $ref: '#/components/schemas/DecodedRawMessage' }
                            }
                        }
                    }
                }
            }
        }
    },
    '#/components/schemas/DecodedRawMessage': {
        type: 'object',
        required: ['message', 'mode'],
        properties: {
            message: {
                type: 'object',
                required: ['boc'],
                properties: {
                    boc: { type: 'string', format: 'cell' },
                    decoded_op_name: { type: 'string' },
                    op_code: { type: 'string', 'x-js-format': 'bigint' },
                    decoded_body: {}
                }
            },
            mode: { type: 'integer' }
        }
    },
    '#/components/schemas/Event': {
        type: 'object',
        required: [
            'event_id',
            'timestamp',
            'actions',
            'value_flow',
            'is_scam',
            'lt',
            'in_progress'
        ],
        properties: {
            event_id: { type: 'string' },
            timestamp: { type: 'integer', format: 'int64' },
            actions: { type: 'array', items: { $ref: '#/components/schemas/Action' } },
            value_flow: { type: 'array', items: { $ref: '#/components/schemas/ValueFlow' } },
            is_scam: { type: 'boolean' },
            lt: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            in_progress: { type: 'boolean' }
        }
    },
    '#/components/schemas/JettonMetadata': {
        type: 'object',
        required: ['address', 'name', 'symbol', 'decimals'],
        properties: {
            address: { type: 'string', format: 'address' },
            name: { type: 'string' },
            symbol: { type: 'string' },
            decimals: { type: 'string' },
            image: { type: 'string' },
            description: { type: 'string' },
            social: { type: 'array', items: { type: 'string' } },
            websites: { type: 'array', items: { type: 'string' } },
            catalogs: { type: 'array', items: { type: 'string' } },
            custom_payload_api_uri: { type: 'string' }
        }
    },
    '#/components/schemas/InscriptionBalances': {
        type: 'object',
        required: ['inscriptions'],
        properties: {
            inscriptions: {
                type: 'array',
                items: { $ref: '#/components/schemas/InscriptionBalance' }
            }
        }
    },
    '#/components/schemas/InscriptionBalance': {
        type: 'object',
        required: ['type', 'ticker', 'balance', 'decimals'],
        properties: {
            type: { type: 'string', enum: ['ton20', 'gram20'] },
            ticker: { type: 'string' },
            balance: { type: 'string', 'x-js-format': 'bigint' },
            decimals: { type: 'integer' }
        }
    },
    '#/components/schemas/Jettons': {
        type: 'object',
        required: ['jettons'],
        properties: {
            jettons: { type: 'array', items: { $ref: '#/components/schemas/JettonInfo' } }
        }
    },
    '#/components/schemas/JettonInfo': {
        type: 'object',
        required: ['mintable', 'total_supply', 'metadata', 'verification', 'holders_count'],
        properties: {
            mintable: { type: 'boolean' },
            total_supply: { type: 'string', 'x-js-format': 'bigint' },
            admin: { $ref: '#/components/schemas/AccountAddress' },
            metadata: { $ref: '#/components/schemas/JettonMetadata' },
            verification: { $ref: '#/components/schemas/JettonVerificationType' },
            holders_count: { type: 'integer', format: 'int32' }
        }
    },
    '#/components/schemas/JettonHolders': {
        type: 'object',
        required: ['addresses', 'total'],
        properties: {
            addresses: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['address', 'owner', 'balance'],
                    properties: {
                        address: { type: 'string', format: 'address' },
                        owner: { $ref: '#/components/schemas/AccountAddress' },
                        balance: { type: 'string', 'x-js-format': 'bigint' }
                    }
                }
            },
            total: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/JettonTransferPayload': {
        type: 'object',
        required: ['payload'],
        properties: { custom_payload: { type: 'string' }, state_init: { type: 'string' } }
    },
    '#/components/schemas/AccountStaking': {
        type: 'object',
        required: ['pools'],
        properties: {
            pools: { type: 'array', items: { $ref: '#/components/schemas/AccountStakingInfo' } }
        }
    },
    '#/components/schemas/AccountStakingInfo': {
        type: 'object',
        required: ['pool', 'amount', 'pending_deposit', 'pending_withdraw', 'ready_withdraw'],
        properties: {
            pool: { type: 'string' },
            amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            pending_deposit: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            pending_withdraw: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            ready_withdraw: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' }
        }
    },
    '#/components/schemas/PoolInfo': {
        type: 'object',
        required: [
            'address',
            'total_amount',
            'implementation',
            'apy',
            'name',
            'min_stake',
            'cycle_start',
            'cycle_end',
            'verified',
            'current_nominators',
            'max_nominators',
            'nominators_stake',
            'validator_stake'
        ],
        properties: {
            address: { type: 'string', format: 'address' },
            name: { type: 'string' },
            total_amount: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            implementation: { $ref: '#/components/schemas/PoolImplementationType' },
            apy: { type: 'number' },
            min_stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            cycle_start: { type: 'integer', format: 'int64' },
            cycle_end: { type: 'integer', format: 'int64' },
            verified: { type: 'boolean' },
            current_nominators: { type: 'integer' },
            max_nominators: { type: 'integer' },
            liquid_jetton_master: { type: 'string', format: 'address' },
            nominators_stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            validator_stake: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            cycle_length: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/PoolImplementation': {
        type: 'object',
        required: ['name', 'description', 'url', 'socials'],
        properties: {
            name: { type: 'string' },
            description: { type: 'string' },
            url: { type: 'string' },
            socials: { type: 'array', items: { type: 'string' } }
        }
    },
    '#/components/schemas/StorageProvider': {
        type: 'object',
        required: [
            'address',
            'accept_new_contracts',
            'rate_per_mb_day',
            'max_span',
            'minimal_file_size',
            'maximal_file_size'
        ],
        properties: {
            address: { type: 'string', format: 'address' },
            accept_new_contracts: { type: 'boolean' },
            rate_per_mb_day: { type: 'integer', format: 'int64', 'x-js-format': 'bigint' },
            max_span: { type: 'integer', format: 'int64' },
            minimal_file_size: { type: 'integer', format: 'int64' },
            maximal_file_size: { type: 'integer', format: 'int64' }
        }
    },
    '#/components/schemas/FoundAccounts': {
        type: 'object',
        required: ['addresses'],
        properties: {
            addresses: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['address', 'name', 'preview'],
                    properties: {
                        address: { type: 'string', format: 'address' },
                        name: { type: 'string' },
                        preview: { type: 'string' }
                    }
                }
            }
        }
    },
    '#/components/schemas/DnsExpiring': {
        type: 'object',
        required: ['items'],
        properties: {
            items: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['expiring_at', 'name'],
                    properties: {
                        expiring_at: { type: 'integer', format: 'int64' },
                        name: { type: 'string' },
                        dns_item: { $ref: '#/components/schemas/NftItem' }
                    }
                }
            }
        }
    },
    '#/components/schemas/ChartPoints': {
        type: 'array',
        additionalItems: false,
        items: { '0': { type: 'integer', format: 'int64' }, '1': { type: 'number' } }
    },
    '#/components/schemas/AccountInfoByStateInit': {
        type: 'object',
        required: ['public_key', 'address'],
        properties: {
            public_key: { type: 'string' },
            address: { type: 'string', format: 'address' }
        }
    },
    '#/components/schemas/Seqno': {
        type: 'object',
        required: ['seqno'],
        properties: { seqno: { type: 'integer', format: 'int32' } }
    },
    '#/components/schemas/BlockRaw': {
        type: 'object',
        required: ['workchain', 'shard', 'seqno', 'root_hash', 'file_hash'],
        properties: {
            workchain: { type: 'integer', format: 'int32' },
            shard: { type: 'string' },
            seqno: { type: 'integer', format: 'int32' },
            root_hash: { type: 'string' },
            file_hash: { type: 'string' }
        }
    },
    '#/components/schemas/InitStateRaw': {
        type: 'object',
        required: ['workchain', 'root_hash', 'file_hash'],
        properties: {
            workchain: { type: 'integer', format: 'int32' },
            root_hash: { type: 'string' },
            file_hash: { type: 'string' }
        }
    },
    '#/components/schemas/EncryptedComment': {
        type: 'object',
        required: ['encryption_type', 'cipher_text'],
        properties: { encryption_type: { type: 'string' }, cipher_text: { type: 'string' } }
    },
    '#/components/schemas/BlockchainAccountInspect': {
        type: 'object',
        required: ['code', 'code_hash', 'methods'],
        properties: {
            code: { type: 'string', format: 'cell' },
            code_hash: { type: 'string' },
            methods: {
                type: 'array',
                items: {
                    type: 'object',
                    required: ['id', 'method'],
                    properties: {
                        id: { type: 'integer', format: 'int64' },
                        method: { type: 'string' }
                    }
                }
            },
            compiler: { type: 'string', enum: ['func'] }
        }
    },
    '#/components/schemas/PoolImplementationType': {
        type: 'string',
        enum: ['whales', 'tf', 'liquidTF']
    },
    '#/components/schemas/TokenRates': {
        type: 'object',
        properties: {
            prices: { type: 'object', additionalProperties: { type: 'number' } },
            diff_24h: { type: 'object', additionalProperties: { type: 'string' } },
            diff_7d: { type: 'object', additionalProperties: { type: 'string' } },
            diff_30d: { type: 'object', additionalProperties: { type: 'string' } }
        }
    },
    '#/components/schemas/MarketTonRates': {
        type: 'object',
        required: ['market', 'usd_price', 'last_date_update'],
        properties: {
            market: { type: 'string' },
            usd_price: { type: 'number' },
            last_date_update: { type: 'integer', format: 'int64' }
        }
    }
};
function snakeToCamel(snakeCaseString) {
    return snakeCaseString.replace(/(_\w)/g, match => match[1]?.toUpperCase() ?? '');
}
function camelToSnake(camel) {
    return camel.replace(/([A-Z])/g, match => `_${match.toLowerCase()}`);
}
function cellParse(src) {
    return core_1.Cell.fromHex(src);
}
function parseHexToBigInt(str) {
    return str.startsWith('-') ? BigInt(str.slice(1)) * -1n : BigInt(str);
}
async function prepareResponse(promise, orSchema) {
    return await promise
        .then(obj => prepareResponseData(obj, orSchema))
        .catch(async (error) => {
        const errorJson = await error.json();
        const errorMessage = typeof errorJson === 'string' ? errorJson : errorJson?.error;
        throw new Error(errorMessage, { cause: error });
    });
}
function prepareResponseData(obj, orSchema) {
    const ref = (orSchema && orSchema.$ref);
    const schema = ref ? components[ref] : orSchema;
    if (Array.isArray(obj)) {
        const itemSchema = schema && schema.items;
        return obj.map(item => prepareResponseData(item, itemSchema));
    }
    else if (schema) {
        if (schema.type === 'string') {
            if (schema.format === 'address') {
                return core_1.Address.parse(obj);
            }
            if (schema.format === 'cell') {
                return obj && cellParse(obj);
            }
            if (schema['x-js-format'] === 'bigint') {
                return BigInt(obj);
            }
            // maybe not used
            if (schema.format === 'cell-base64') {
                return obj && core_1.Cell.fromBase64(obj);
            }
        }
        if (schema.type === 'integer') {
            if (schema['x-js-format'] === 'bigint') {
                return BigInt(obj);
            }
            return Number(obj);
        }
        if (schema.type === 'object') {
            if (schema.format === 'tuple-item') {
                switch (obj.type) {
                    case 'tuple':
                        const itemSchema = schema.properties.tuple.items;
                        return {
                            type: 'tuple',
                            items: obj.tuple.map((item) => prepareResponseData(item, itemSchema))
                        };
                    case 'num':
                        return {
                            type: 'int',
                            value: parseHexToBigInt(obj.num)
                        };
                    case 'cell':
                        return {
                            type: 'cell',
                            cell: cellParse(obj.cell)
                        };
                    case 'slice':
                        return {
                            type: 'slice',
                            slice: cellParse(obj.slice)
                        };
                    case 'null':
                        return {
                            type: 'null'
                        };
                    case 'nan':
                        return {
                            type: 'nan'
                        };
                    default:
                        throw new Error(`Unknown tuple item type: ${obj.type}`);
                }
            }
        }
    }
    // case of non tuple-item object
    if (obj !== null && typeof obj === 'object') {
        return Object.keys(obj).reduce((acc, key) => {
            const objSchema = schema?.properties && schema.properties[key];
            const camelCaseKey = snakeToCamel(key);
            acc[camelCaseKey] = prepareResponseData(obj[key], objSchema);
            return acc;
        }, {});
    }
    return obj;
}
function prepareRequestData(data, orSchema) {
    const ref = (orSchema && orSchema.$ref);
    const schema = ref ? components[ref] : orSchema;
    if (Array.isArray(data)) {
        const itemSchema = schema && schema.items;
        return data.map(item => prepareRequestData(item, itemSchema));
    }
    else if (schema) {
        if (schema.type === 'string') {
            if (schema.format === 'address') {
                return data.toRawString();
            }
            if (schema.format === 'cell') {
                return data.toBoc().toString('hex');
            }
            if (schema.format === 'cell-base64') {
                return data.toBoc().toString('base64');
            }
            if (schema['x-js-format'] === 'bigint') {
                return data.toString();
            }
        }
    }
    if (data !== null && typeof data === 'object') {
        return Object.keys(data).reduce((acc, key) => {
            const objSchema = schema?.properties && schema.properties[key];
            const snakeCaseKey = camelToSnake(key);
            acc[snakeCaseKey] = prepareRequestData(data[key], objSchema);
            return acc;
        }, {});
    }
    return data;
}
/**
 * @title REST api to TON blockchain explorer
 * @version 2.0.0
 * @baseUrl https://tonapi.io
 * @contact Support <support@tonkeeper.com>
 *
 * Provide access to indexed TON blockchain
 */
class TonApiClient {
    http;
    constructor(apiConfig = {}) {
        this.http = new HttpClient(apiConfig);
    }
    utilities = {
        /**
         * @description Status
         *
         * @tags Utilities
         * @name Status
         * @request GET:/v2/status
         */
        status: (params = {}) => {
            const req = this.http.request({
                path: `/v2/status`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/ServiceStatus'
            });
        },
        /**
         * @description parse address and display in all formats
         *
         * @tags Utilities
         * @name AddressParse
         * @request GET:/v2/address/{account_id}/parse
         */
        addressParse: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/address/${accountId}/parse`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['raw_form', 'bounceable', 'non_bounceable', 'given_type', 'test_only'],
                properties: {
                    raw_form: { type: 'string', format: 'address' },
                    bounceable: {
                        required: ['b64', 'b64url'],
                        type: 'object',
                        properties: { b64: { type: 'string' }, b64url: { type: 'string' } }
                    },
                    non_bounceable: {
                        required: ['b64', 'b64url'],
                        type: 'object',
                        properties: { b64: { type: 'string' }, b64url: { type: 'string' } }
                    },
                    given_type: { type: 'string' },
                    test_only: { type: 'boolean' }
                }
            });
        }
    };
    blockchain = {
        /**
         * @description Get reduced blockchain blocks data
         *
         * @tags Blockchain
         * @name GetReducedBlockchainBlocks
         * @request GET:/v2/blockchain/reduced/blocks
         */
        getReducedBlockchainBlocks: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/reduced/blocks`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/ReducedBlocks'
            });
        },
        /**
         * @description Get blockchain block data
         *
         * @tags Blockchain
         * @name GetBlockchainBlock
         * @request GET:/v2/blockchain/blocks/{block_id}
         */
        getBlockchainBlock: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/blocks/${blockId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainBlock'
            });
        },
        /**
         * @description Get blockchain block shards
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainShards
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/shards
         */
        getBlockchainMasterchainShards: (masterchainSeqno, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain/${masterchainSeqno}/shards`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainBlockShards'
            });
        },
        /**
         * @description Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainBlocks
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/blocks
         */
        getBlockchainMasterchainBlocks: (masterchainSeqno, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain/${masterchainSeqno}/blocks`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainBlocks'
            });
        },
        /**
         * @description Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainTransactions
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/transactions
         */
        getBlockchainMasterchainTransactions: (masterchainSeqno, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain/${masterchainSeqno}/transactions`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/Transactions'
            });
        },
        /**
         * @description Get blockchain config from a specific block, if present.
         *
         * @tags Blockchain
         * @name GetBlockchainConfigFromBlock
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/config
         */
        getBlockchainConfigFromBlock: (masterchainSeqno, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain/${masterchainSeqno}/config`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainConfig'
            });
        },
        /**
         * @description Get raw blockchain config from a specific block, if present.
         *
         * @tags Blockchain
         * @name GetRawBlockchainConfigFromBlock
         * @request GET:/v2/blockchain/masterchain/{masterchain_seqno}/config/raw
         */
        getRawBlockchainConfigFromBlock: (masterchainSeqno, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain/${masterchainSeqno}/config/raw`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/RawBlockchainConfig'
            });
        },
        /**
         * @description Get transactions from block
         *
         * @tags Blockchain
         * @name GetBlockchainBlockTransactions
         * @request GET:/v2/blockchain/blocks/{block_id}/transactions
         */
        getBlockchainBlockTransactions: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/blocks/${blockId}/transactions`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/Transactions'
            });
        },
        /**
         * @description Get transaction data
         *
         * @tags Blockchain
         * @name GetBlockchainTransaction
         * @request GET:/v2/blockchain/transactions/{transaction_id}
         */
        getBlockchainTransaction: (transactionId, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/transactions/${transactionId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Transaction' });
        },
        /**
         * @description Get transaction data by message hash
         *
         * @tags Blockchain
         * @name GetBlockchainTransactionByMessageHash
         * @request GET:/v2/blockchain/messages/{msg_id}/transaction
         */
        getBlockchainTransactionByMessageHash: (msgId, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/messages/${msgId}/transaction`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Transaction' });
        },
        /**
         * @description Get blockchain validators
         *
         * @tags Blockchain
         * @name GetBlockchainValidators
         * @request GET:/v2/blockchain/validators
         */
        getBlockchainValidators: (params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/validators`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Validators' });
        },
        /**
         * @description Get last known masterchain block
         *
         * @tags Blockchain
         * @name GetBlockchainMasterchainHead
         * @request GET:/v2/blockchain/masterchain-head
         */
        getBlockchainMasterchainHead: (params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/masterchain-head`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainBlock'
            });
        },
        /**
         * @description Get low-level information about an account taken directly from the blockchain.
         *
         * @tags Blockchain
         * @name GetBlockchainRawAccount
         * @request GET:/v2/blockchain/accounts/{account_id}
         */
        getBlockchainRawAccount: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/blockchain/accounts/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainRawAccount'
            });
        },
        /**
         * @description Get account transactions
         *
         * @tags Blockchain
         * @name GetBlockchainAccountTransactions
         * @request GET:/v2/blockchain/accounts/{account_id}/transactions
         */
        getBlockchainAccountTransactions: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/blockchain/accounts/${accountId}/transactions`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/Transactions'
            });
        },
        /**
         * @description Execute get method for account
         *
         * @tags Blockchain
         * @name ExecGetMethodForBlockchainAccount
         * @request GET:/v2/blockchain/accounts/{account_id}/methods/{method_name}
         */
        execGetMethodForBlockchainAccount: (accountId_Address, methodName, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/blockchain/accounts/${accountId}/methods/${methodName}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/MethodExecutionResult'
            });
        },
        /**
         * @description Send message to blockchain
         *
         * @tags Blockchain
         * @name SendBlockchainMessage
         * @request POST:/v2/blockchain/message
         */
        sendBlockchainMessage: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/message`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    properties: {
                        boc: { type: 'string', format: 'cell' },
                        batch: {
                            type: 'array',
                            maxItems: 10,
                            items: { type: 'string', format: 'cell' }
                        }
                    }
                }),
                ...params
            });
            return prepareResponse(req);
        },
        /**
         * @description Get blockchain config
         *
         * @tags Blockchain
         * @name GetBlockchainConfig
         * @request GET:/v2/blockchain/config
         */
        getBlockchainConfig: (params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/config`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainConfig'
            });
        },
        /**
         * @description Get raw blockchain config
         *
         * @tags Blockchain
         * @name GetRawBlockchainConfig
         * @request GET:/v2/blockchain/config/raw
         */
        getRawBlockchainConfig: (params = {}) => {
            const req = this.http.request({
                path: `/v2/blockchain/config/raw`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/RawBlockchainConfig'
            });
        },
        /**
         * @description Blockchain account inspect
         *
         * @tags Blockchain
         * @name BlockchainAccountInspect
         * @request GET:/v2/blockchain/accounts/{account_id}/inspect
         */
        blockchainAccountInspect: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/blockchain/accounts/${accountId}/inspect`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/BlockchainAccountInspect'
            });
        },
        /**
         * @description Status
         *
         * @tags Utilities
         * @name Status
         * @request GET:/v2/status
         * @deprecated
         */
        status: (requestParams = {}) => {
            const req = this.http.request({
                path: `/v2/status`,
                method: 'GET',
                format: 'json',
                ...requestParams
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/ServiceStatus'
            });
        }
    };
    accounts = {
        /**
         * @description Get human-friendly information about several accounts without low-level details.
         *
         * @tags Accounts
         * @name GetAccounts
         * @request POST:/v2/accounts/_bulk
         */
        getAccounts: (data, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/accounts/_bulk`,
                method: 'POST',
                query: query,
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['accountIds'],
                    properties: {
                        accountIds: { type: 'array', items: { type: 'string', format: 'address' } }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Accounts' });
        },
        /**
         * @description Get human-friendly information about an account without low-level details.
         *
         * @tags Accounts
         * @name GetAccount
         * @request GET:/v2/accounts/{account_id}
         */
        getAccount: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Account' });
        },
        /**
         * @description Get account's domains
         *
         * @tags Accounts
         * @name AccountDnsBackResolve
         * @request GET:/v2/accounts/{account_id}/dns/backresolve
         */
        accountDnsBackResolve: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/dns/backresolve`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/DomainNames' });
        },
        /**
         * @description Get all Jettons balances by owner address
         *
         * @tags Accounts
         * @name GetAccountJettonsBalances
         * @request GET:/v2/accounts/{account_id}/jettons
         */
        getAccountJettonsBalances: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/jettons`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/JettonsBalances'
            });
        },
        /**
         * @description Get Jetton balance by owner address
         *
         * @tags Accounts
         * @name GetAccountJettonBalance
         * @request GET:/v2/accounts/{account_id}/jettons/{jetton_id}
         */
        getAccountJettonBalance: (accountId_Address, jettonId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const jettonId = jettonId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/jettons/${jettonId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/JettonBalance'
            });
        },
        /**
         * @description Get the transfer jettons history for account
         *
         * @tags Accounts
         * @name GetAccountJettonsHistory
         * @request GET:/v2/accounts/{account_id}/jettons/history
         */
        getAccountJettonsHistory: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/jettons/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description Get the transfer jetton history for account and jetton
         *
         * @tags Accounts
         * @name GetAccountJettonHistoryById
         * @request GET:/v2/accounts/{account_id}/jettons/{jetton_id}/history
         */
        getAccountJettonHistoryById: (accountId_Address, jettonId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const jettonId = jettonId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/jettons/${jettonId}/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description Get all NFT items by owner address
         *
         * @tags Accounts
         * @name GetAccountNftItems
         * @request GET:/v2/accounts/{account_id}/nfts
         */
        getAccountNftItems: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/nfts`,
                method: 'GET',
                query: query && {
                    ...query,
                    collection: query.collection?.toRawString()
                },
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/NftItems' });
        },
        /**
         * @description Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
         *
         * @tags Accounts
         * @name GetAccountEvents
         * @request GET:/v2/accounts/{account_id}/events
         */
        getAccountEvents: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/events`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description Get event for an account by event_id
         *
         * @tags Accounts
         * @name GetAccountEvent
         * @request GET:/v2/accounts/{account_id}/events/{event_id}
         */
        getAccountEvent: (accountId_Address, eventId, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/events/${eventId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvent'
            });
        },
        /**
         * @description Get traces for account
         *
         * @tags Accounts
         * @name GetAccountTraces
         * @request GET:/v2/accounts/{account_id}/traces
         */
        getAccountTraces: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/traces`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/TraceIDs' });
        },
        /**
         * @description Get all subscriptions by wallet address
         *
         * @tags Accounts
         * @name GetAccountSubscriptions
         * @request GET:/v2/accounts/{account_id}/subscriptions
         */
        getAccountSubscriptions: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/subscriptions`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/Subscriptions'
            });
        },
        /**
         * @description Update internal cache for a particular account
         *
         * @tags Accounts
         * @name ReindexAccount
         * @request POST:/v2/accounts/{account_id}/reindex
         */
        reindexAccount: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/reindex`,
                method: 'POST',
                ...params
            });
            return prepareResponse(req);
        },
        /**
         * @description Search by account domain name
         *
         * @tags Accounts
         * @name SearchAccounts
         * @request GET:/v2/accounts/search
         */
        searchAccounts: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/accounts/search`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/FoundAccounts'
            });
        },
        /**
         * @description Get expiring account .ton dns
         *
         * @tags Accounts
         * @name GetAccountDnsExpiring
         * @request GET:/v2/accounts/{account_id}/dns/expiring
         */
        getAccountDnsExpiring: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/dns/expiring`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/DnsExpiring' });
        },
        /**
         * @description Get public key by account id
         *
         * @tags Accounts
         * @name GetAccountPublicKey
         * @request GET:/v2/accounts/{account_id}/publickey
         */
        getAccountPublicKey: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/publickey`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['public_key'],
                properties: { public_key: { type: 'string' } }
            });
        },
        /**
         * @description Get account's multisigs
         *
         * @tags Accounts
         * @name GetAccountMultisigs
         * @request GET:/v2/accounts/{account_id}/multisigs
         */
        getAccountMultisigs: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/multisigs`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Multisigs' });
        },
        /**
         * @description Get account's balance change
         *
         * @tags Accounts
         * @name GetAccountDiff
         * @request GET:/v2/accounts/{account_id}/diff
         */
        getAccountDiff: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/diff`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['balance_change'],
                properties: { balance_change: { type: 'integer', format: 'int64' } }
            });
        },
        /**
         * @description parse address and display in all formats
         *
         * @tags Utilities
         * @name AddressParse
         * @request GET:/v2/address/{account_id}/parse
         * @deprecated
         */
        addressParse: (accountId_Address, requestParams = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/address/${accountId}/parse`,
                method: 'GET',
                format: 'json',
                ...requestParams
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['raw_form', 'bounceable', 'non_bounceable', 'given_type', 'test_only'],
                properties: {
                    raw_form: { type: 'string', format: 'address' },
                    bounceable: {
                        required: ['b64', 'b64url'],
                        type: 'object',
                        properties: { b64: { type: 'string' }, b64url: { type: 'string' } }
                    },
                    non_bounceable: {
                        required: ['b64', 'b64url'],
                        type: 'object',
                        properties: { b64: { type: 'string' }, b64url: { type: 'string' } }
                    },
                    given_type: { type: 'string' },
                    test_only: { type: 'boolean' }
                }
            });
        }
    };
    nft = {
        /**
         * @description Get the transfer nft history
         *
         * @tags NFT
         * @name GetAccountNftHistory
         * @request GET:/v2/accounts/{account_id}/nfts/history
         */
        getAccountNftHistory: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/nfts/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description Get NFT collections
         *
         * @tags NFT
         * @name GetNftCollections
         * @request GET:/v2/nfts/collections
         */
        getNftCollections: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/nfts/collections`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/NftCollections'
            });
        },
        /**
         * @description Get NFT collection by collection address
         *
         * @tags NFT
         * @name GetNftCollection
         * @request GET:/v2/nfts/collections/{account_id}
         */
        getNftCollection: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/nfts/collections/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/NftCollection'
            });
        },
        /**
         * @description Get NFT collection items by their addresses
         *
         * @tags NFT
         * @name GetNftCollectionItemsByAddresses
         * @request POST:/v2/nfts/collections/_bulk
         */
        getNftCollectionItemsByAddresses: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/nfts/collections/_bulk`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['accountIds'],
                    properties: {
                        accountIds: { type: 'array', items: { type: 'string', format: 'address' } }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/NftCollections'
            });
        },
        /**
         * @description Get NFT items from collection by collection address
         *
         * @tags NFT
         * @name GetItemsFromCollection
         * @request GET:/v2/nfts/collections/{account_id}/items
         */
        getItemsFromCollection: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/nfts/collections/${accountId}/items`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/NftItems' });
        },
        /**
         * @description Get NFT items by their addresses
         *
         * @tags NFT
         * @name GetNftItemsByAddresses
         * @request POST:/v2/nfts/_bulk
         */
        getNftItemsByAddresses: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/nfts/_bulk`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['accountIds'],
                    properties: {
                        accountIds: { type: 'array', items: { type: 'string', format: 'address' } }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/NftItems' });
        },
        /**
         * @description Get NFT item by its address
         *
         * @tags NFT
         * @name GetNftItemByAddress
         * @request GET:/v2/nfts/{account_id}
         */
        getNftItemByAddress: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/nfts/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/NftItem' });
        },
        /**
         * @description Get the transfer nfts history for account
         *
         * @tags NFT
         * @name GetNftHistoryById
         * @request GET:/v2/nfts/{account_id}/history
         */
        getNftHistoryById: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/nfts/${accountId}/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        }
    };
    dns = {
        /**
         * @description Get full information about domain name
         *
         * @tags DNS
         * @name GetDnsInfo
         * @request GET:/v2/dns/{domain_name}
         */
        getDnsInfo: (domainName, params = {}) => {
            const req = this.http.request({
                path: `/v2/dns/${domainName}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/DomainInfo' });
        },
        /**
         * @description DNS resolve for domain name
         *
         * @tags DNS
         * @name DnsResolve
         * @request GET:/v2/dns/{domain_name}/resolve
         */
        dnsResolve: (domainName, params = {}) => {
            const req = this.http.request({
                path: `/v2/dns/${domainName}/resolve`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/DnsRecord' });
        },
        /**
         * @description Get domain bids
         *
         * @tags DNS
         * @name GetDomainBids
         * @request GET:/v2/dns/{domain_name}/bids
         */
        getDomainBids: (domainName, params = {}) => {
            const req = this.http.request({
                path: `/v2/dns/${domainName}/bids`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/DomainBids' });
        },
        /**
         * @description Get all auctions
         *
         * @tags DNS
         * @name GetAllAuctions
         * @request GET:/v2/dns/auctions
         */
        getAllAuctions: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/dns/auctions`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Auctions' });
        }
    };
    traces = {
        /**
         * @description Get the trace by trace ID or hash of any transaction in trace
         *
         * @tags Traces
         * @name GetTrace
         * @request GET:/v2/traces/{trace_id}
         */
        getTrace: (traceId, params = {}) => {
            const req = this.http.request({
                path: `/v2/traces/${traceId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Trace' });
        }
    };
    events = {
        /**
         * @description Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
         *
         * @tags Events
         * @name GetEvent
         * @request GET:/v2/events/{event_id}
         */
        getEvent: (eventId, params = {}) => {
            const req = this.http.request({
                path: `/v2/events/${eventId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Event' });
        }
    };
    inscriptions = {
        /**
         * @description Get all inscriptions by owner address. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptions
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions
         */
        getAccountInscriptions: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/experimental/accounts/${accountId}/inscriptions`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/InscriptionBalances'
            });
        },
        /**
         * @description Get the transfer inscriptions history for account. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptionsHistory
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions/history
         */
        getAccountInscriptionsHistory: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/experimental/accounts/${accountId}/inscriptions/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description Get the transfer inscriptions history for account. It's experimental API and can be dropped in the future.
         *
         * @tags Inscriptions
         * @name GetAccountInscriptionsHistoryByTicker
         * @request GET:/v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history
         */
        getAccountInscriptionsHistoryByTicker: (accountId_Address, ticker, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/experimental/accounts/${accountId}/inscriptions/${ticker}/history`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvents'
            });
        },
        /**
         * @description return comment for making operation with inscription. please don't use it if you don't know what you are doing
         *
         * @tags Inscriptions
         * @name GetInscriptionOpTemplate
         * @request GET:/v2/experimental/inscriptions/op-template
         */
        getInscriptionOpTemplate: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/experimental/inscriptions/op-template`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['comment', 'destination'],
                properties: { comment: { type: 'string' }, destination: { type: 'string' } }
            });
        }
    };
    jettons = {
        /**
         * @description Get a list of all indexed jetton masters in the blockchain.
         *
         * @tags Jettons
         * @name GetJettons
         * @request GET:/v2/jettons
         */
        getJettons: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/jettons`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Jettons' });
        },
        /**
         * @description Get jetton metadata by jetton master address
         *
         * @tags Jettons
         * @name GetJettonInfo
         * @request GET:/v2/jettons/{account_id}
         */
        getJettonInfo: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/jettons/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/JettonInfo' });
        },
        /**
         * @description Get jetton metadata items by jetton master addresses
         *
         * @tags Jettons
         * @name GetJettonInfosByAddresses
         * @request POST:/v2/jettons/_bulk
         */
        getJettonInfosByAddresses: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/jettons/_bulk`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['accountIds'],
                    properties: {
                        accountIds: { type: 'array', items: { type: 'string', format: 'address' } }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Jettons' });
        },
        /**
         * @description Get jetton's holders
         *
         * @tags Jettons
         * @name GetJettonHolders
         * @request GET:/v2/jettons/{account_id}/holders
         */
        getJettonHolders: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/jettons/${accountId}/holders`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/JettonHolders'
            });
        },
        /**
         * @description Get jetton's custom payload and state init required for transfer
         *
         * @tags Jettons
         * @name GetJettonTransferPayload
         * @request GET:/v2/jettons/{jetton_id}/transfer/{account_id}/payload
         */
        getJettonTransferPayload: (accountId_Address, jettonId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const jettonId = jettonId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/jettons/${jettonId}/transfer/${accountId}/payload`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/JettonTransferPayload'
            });
        },
        /**
         * @description Get only jetton transfers in the event
         *
         * @tags Jettons
         * @name GetJettonsEvents
         * @request GET:/v2/events/{event_id}/jettons
         */
        getJettonsEvents: (eventId, params = {}) => {
            const req = this.http.request({
                path: `/v2/events/${eventId}/jettons`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Event' });
        }
    };
    staking = {
        /**
         * @description All pools where account participates
         *
         * @tags Staking
         * @name GetAccountNominatorsPools
         * @request GET:/v2/staking/nominator/{account_id}/pools
         */
        getAccountNominatorsPools: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/staking/nominator/${accountId}/pools`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountStaking'
            });
        },
        /**
         * @description Stacking pool info
         *
         * @tags Staking
         * @name GetStakingPoolInfo
         * @request GET:/v2/staking/pool/{account_id}
         */
        getStakingPoolInfo: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/staking/pool/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['implementation', 'pool'],
                properties: {
                    implementation: { $ref: '#/components/schemas/PoolImplementation' },
                    pool: { $ref: '#/components/schemas/PoolInfo' }
                }
            });
        },
        /**
         * @description Pool history
         *
         * @tags Staking
         * @name GetStakingPoolHistory
         * @request GET:/v2/staking/pool/{account_id}/history
         */
        getStakingPoolHistory: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/staking/pool/${accountId}/history`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['apy'],
                properties: {
                    apy: { type: 'array', items: { $ref: '#/components/schemas/ApyHistory' } }
                }
            });
        },
        /**
         * @description All pools available in network
         *
         * @tags Staking
         * @name GetStakingPools
         * @request GET:/v2/staking/pools
         */
        getStakingPools: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/staking/pools`,
                method: 'GET',
                query: query && {
                    ...query,
                    available_for: query.available_for?.toRawString()
                },
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['pools', 'implementations'],
                properties: {
                    pools: { type: 'array', items: { $ref: '#/components/schemas/PoolInfo' } },
                    implementations: {
                        type: 'object',
                        additionalProperties: { $ref: '#/components/schemas/PoolImplementation' }
                    }
                }
            });
        }
    };
    storage = {
        /**
         * @description Get TON storage providers deployed to the blockchain.
         *
         * @tags Storage
         * @name GetStorageProviders
         * @request GET:/v2/storage/providers
         */
        getStorageProviders: (params = {}) => {
            const req = this.http.request({
                path: `/v2/storage/providers`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['providers'],
                properties: {
                    providers: {
                        type: 'array',
                        items: { $ref: '#/components/schemas/StorageProvider' }
                    }
                }
            });
        }
    };
    rates = {
        /**
         * @description Get the token price in the chosen currency for display only. Dont use this for financial transactions.
         *
         * @tags Rates
         * @name GetRates
         * @request GET:/v2/rates
         */
        getRates: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/rates`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['rates'],
                properties: {
                    rates: {
                        type: 'object',
                        additionalProperties: { $ref: '#/components/schemas/TokenRates' }
                    }
                }
            });
        },
        /**
         * @description Get chart by token
         *
         * @tags Rates
         * @name GetChartRates
         * @request GET:/v2/rates/chart
         */
        getChartRates: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/rates/chart`,
                method: 'GET',
                query: query && {
                    ...query,
                    token: query.token?.toRawString()
                },
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['points'],
                properties: {
                    points: { type: 'array', items: { $ref: '#/components/schemas/ChartPoints' } }
                }
            });
        },
        /**
         * @description Get the TON price from markets
         *
         * @tags Rates
         * @name GetMarketsRates
         * @request GET:/v2/rates/markets
         */
        getMarketsRates: (params = {}) => {
            const req = this.http.request({
                path: `/v2/rates/markets`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['markets'],
                properties: {
                    markets: {
                        type: 'array',
                        items: { $ref: '#/components/schemas/MarketTonRates' }
                    }
                }
            });
        }
    };
    connect = {
        /**
         * @description Get a payload for further token receipt
         *
         * @tags Connect
         * @name GetTonConnectPayload
         * @request GET:/v2/tonconnect/payload
         */
        getTonConnectPayload: (params = {}) => {
            const req = this.http.request({
                path: `/v2/tonconnect/payload`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['payload'],
                properties: { payload: { type: 'string' } }
            });
        },
        /**
         * @description Get account info by state init
         *
         * @tags Connect
         * @name GetAccountInfoByStateInit
         * @request POST:/v2/tonconnect/stateinit
         */
        getAccountInfoByStateInit: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/tonconnect/stateinit`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['stateInit'],
                    properties: { stateInit: { type: 'string', format: 'cell-base64' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountInfoByStateInit'
            });
        }
    };
    wallet = {
        /**
         * @description Get backup info
         *
         * @tags Wallet
         * @name GetWalletBackup
         * @request GET:/v2/wallet/backup
         */
        getWalletBackup: (params = {}) => {
            const req = this.http.request({
                path: `/v2/wallet/backup`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['dump'],
                properties: { dump: { type: 'string' } }
            });
        },
        /**
         * @description Set backup info
         *
         * @tags Wallet
         * @name SetWalletBackup
         * @request PUT:/v2/wallet/backup
         */
        setWalletBackup: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/wallet/backup`,
                method: 'PUT',
                body: prepareRequestData(data),
                ...params
            });
            return prepareResponse(req);
        },
        /**
         * @description Account verification and token issuance
         *
         * @tags Wallet
         * @name TonConnectProof
         * @request POST:/v2/wallet/auth/proof
         */
        tonConnectProof: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/wallet/auth/proof`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['address', 'proof'],
                    properties: {
                        address: { type: 'string', format: 'address' },
                        proof: {
                            type: 'object',
                            required: ['timestamp', 'domain', 'signature', 'payload'],
                            properties: {
                                timestamp: { type: 'integer', format: 'int64' },
                                domain: {
                                    type: 'object',
                                    required: ['value'],
                                    properties: {
                                        lengthBytes: { type: 'integer', format: 'int32' },
                                        value: { type: 'string' }
                                    }
                                },
                                signature: { type: 'string' },
                                payload: { type: 'string' },
                                stateInit: { type: 'string', format: 'cell-base64' }
                            }
                        }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['token'],
                properties: { token: { type: 'string' } }
            });
        },
        /**
         * @description Get account seqno
         *
         * @tags Wallet
         * @name GetAccountSeqno
         * @request GET:/v2/wallet/{account_id}/seqno
         */
        getAccountSeqno: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/wallet/${accountId}/seqno`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Seqno' });
        },
        /**
         * @description Get wallets by public key
         *
         * @tags Wallet
         * @name GetWalletsByPublicKey
         * @request GET:/v2/pubkeys/{public_key}/wallets
         */
        getWalletsByPublicKey: (publicKey, params = {}) => {
            const req = this.http.request({
                path: `/v2/pubkeys/${publicKey}/wallets`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Accounts' });
        }
    };
    gasless = {
        /**
         * @description Returns configuration of gasless transfers
         *
         * @tags Gasless
         * @name GaslessConfig
         * @request GET:/v2/gasless/config
         */
        gaslessConfig: (params = {}) => {
            const req = this.http.request({
                path: `/v2/gasless/config`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/GaslessConfig'
            });
        },
        /**
         * @description Estimates the cost of the given messages and returns a payload to sign
         *
         * @tags Gasless
         * @name GaslessEstimate
         * @request POST:/v2/gasless/estimate/{master_id}
         */
        gaslessEstimate: (masterId_Address, data, params = {}) => {
            const masterId = masterId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/gasless/estimate/${masterId}`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['messages', 'walletAddress', 'walletPublicKey'],
                    properties: {
                        walletAddress: { type: 'string', format: 'address' },
                        walletPublicKey: { type: 'string' },
                        messages: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['boc'],
                                properties: { boc: { type: 'string', format: 'cell' } }
                            }
                        }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/SignRawParams'
            });
        },
        /**
         * @description Submits the signed gasless transaction message to the network
         *
         * @tags Gasless
         * @name GaslessSend
         * @request POST:/v2/gasless/send
         */
        gaslessSend: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/gasless/send`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc', 'walletPublicKey'],
                    properties: {
                        walletPublicKey: { type: 'string' },
                        boc: { type: 'string', format: 'cell' }
                    }
                }),
                ...params
            });
            return prepareResponse(req);
        }
    };
    liteServer = {
        /**
         * @description Get raw masterchain info
         *
         * @tags Lite Server
         * @name GetRawMasterchainInfo
         * @request GET:/v2/liteserver/get_masterchain_info
         */
        getRawMasterchainInfo: (params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_masterchain_info`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['last', 'state_root_hash', 'init'],
                properties: {
                    last: { $ref: '#/components/schemas/BlockRaw' },
                    state_root_hash: { type: 'string' },
                    init: { $ref: '#/components/schemas/InitStateRaw' }
                }
            });
        },
        /**
         * @description Get raw masterchain info ext
         *
         * @tags Lite Server
         * @name GetRawMasterchainInfoExt
         * @request GET:/v2/liteserver/get_masterchain_info_ext
         */
        getRawMasterchainInfoExt: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_masterchain_info_ext`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: [
                    'mode',
                    'version',
                    'capabilities',
                    'last',
                    'last_utime',
                    'now',
                    'state_root_hash',
                    'init'
                ],
                properties: {
                    mode: { type: 'integer', format: 'int32' },
                    version: { type: 'integer', format: 'int32' },
                    capabilities: { type: 'integer', format: 'int64' },
                    last: { $ref: '#/components/schemas/BlockRaw' },
                    last_utime: { type: 'integer', format: 'int32' },
                    now: { type: 'integer', format: 'int32' },
                    state_root_hash: { type: 'string' },
                    init: { $ref: '#/components/schemas/InitStateRaw' }
                }
            });
        },
        /**
         * @description Get raw time
         *
         * @tags Lite Server
         * @name GetRawTime
         * @request GET:/v2/liteserver/get_time
         */
        getRawTime: (params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_time`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['time'],
                properties: { time: { type: 'integer', format: 'int32' } }
            });
        },
        /**
         * @description Get raw blockchain block
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlock
         * @request GET:/v2/liteserver/get_block/{block_id}
         */
        getRawBlockchainBlock: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_block/${blockId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'data'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    data: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw blockchain block state
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlockState
         * @request GET:/v2/liteserver/get_state/{block_id}
         */
        getRawBlockchainBlockState: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_state/${blockId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'root_hash', 'file_hash', 'data'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    root_hash: { type: 'string' },
                    file_hash: { type: 'string' },
                    data: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw blockchain block header
         *
         * @tags Lite Server
         * @name GetRawBlockchainBlockHeader
         * @request GET:/v2/liteserver/get_block_header/{block_id}
         */
        getRawBlockchainBlockHeader: (blockId, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_block_header/${blockId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'mode', 'header_proof'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    mode: { type: 'integer', format: 'int32' },
                    header_proof: { type: 'string' }
                }
            });
        },
        /**
         * @description Send raw message to blockchain
         *
         * @tags Lite Server
         * @name SendRawMessage
         * @request POST:/v2/liteserver/send_message
         */
        sendRawMessage: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/send_message`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['body'],
                    properties: { body: { type: 'string', format: 'cell-base64' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['code'],
                properties: { code: { type: 'integer', format: 'int32' } }
            });
        },
        /**
         * @description Get raw account state
         *
         * @tags Lite Server
         * @name GetRawAccountState
         * @request GET:/v2/liteserver/get_account_state/{account_id}
         */
        getRawAccountState: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/liteserver/get_account_state/${accountId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'shardblk', 'shard_proof', 'proof', 'state'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    shardblk: { $ref: '#/components/schemas/BlockRaw' },
                    shard_proof: { type: 'string' },
                    proof: { type: 'string' },
                    state: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw shard info
         *
         * @tags Lite Server
         * @name GetRawShardInfo
         * @request GET:/v2/liteserver/get_shard_info/{block_id}
         */
        getRawShardInfo: (blockId, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_shard_info/${blockId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'shardblk', 'shard_proof', 'shard_descr'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    shardblk: { $ref: '#/components/schemas/BlockRaw' },
                    shard_proof: { type: 'string' },
                    shard_descr: { type: 'string' }
                }
            });
        },
        /**
         * @description Get all raw shards info
         *
         * @tags Lite Server
         * @name GetAllRawShardsInfo
         * @request GET:/v2/liteserver/get_all_shards_info/{block_id}
         */
        getAllRawShardsInfo: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_all_shards_info/${blockId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'proof', 'data'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    proof: { type: 'string' },
                    data: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw transactions
         *
         * @tags Lite Server
         * @name GetRawTransactions
         * @request GET:/v2/liteserver/get_transactions/{account_id}
         */
        getRawTransactions: (accountId_Address, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/liteserver/get_transactions/${accountId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['ids', 'transactions'],
                properties: {
                    ids: { type: 'array', items: { $ref: '#/components/schemas/BlockRaw' } },
                    transactions: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw list block transactions
         *
         * @tags Lite Server
         * @name GetRawListBlockTransactions
         * @request GET:/v2/liteserver/list_block_transactions/{block_id}
         */
        getRawListBlockTransactions: (blockId, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/list_block_transactions/${blockId}`,
                method: 'GET',
                query: query && {
                    ...query,
                    account_id: query.account_id?.toRawString()
                },
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['id', 'req_count', 'incomplete', 'ids', 'proof'],
                properties: {
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    req_count: { type: 'integer', format: 'int32' },
                    incomplete: { type: 'boolean' },
                    ids: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['mode'],
                            properties: {
                                mode: { type: 'integer', format: 'int32' },
                                account: { type: 'string' },
                                lt: { type: 'integer', format: 'bigint', 'x-js-format': 'bigint' },
                                hash: { type: 'string' }
                            }
                        }
                    },
                    proof: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw block proof
         *
         * @tags Lite Server
         * @name GetRawBlockProof
         * @request GET:/v2/liteserver/get_block_proof
         */
        getRawBlockProof: (query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_block_proof`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['complete', 'from', 'to', 'steps'],
                properties: {
                    complete: { type: 'boolean' },
                    from: { $ref: '#/components/schemas/BlockRaw' },
                    to: { $ref: '#/components/schemas/BlockRaw' },
                    steps: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: [
                                'lite_server_block_link_back',
                                'lite_server_block_link_forward'
                            ],
                            properties: {
                                lite_server_block_link_back: {
                                    type: 'object',
                                    required: [
                                        'to_key_block',
                                        'from',
                                        'to',
                                        'dest_proof',
                                        'proof',
                                        'state_proof'
                                    ],
                                    properties: {
                                        to_key_block: { type: 'boolean' },
                                        from: { $ref: '#/components/schemas/BlockRaw' },
                                        to: { $ref: '#/components/schemas/BlockRaw' },
                                        dest_proof: { type: 'string' },
                                        proof: { type: 'string' },
                                        state_proof: { type: 'string' }
                                    }
                                },
                                lite_server_block_link_forward: {
                                    type: 'object',
                                    required: [
                                        'to_key_block',
                                        'from',
                                        'to',
                                        'dest_proof',
                                        'config_proof',
                                        'signatures'
                                    ],
                                    properties: {
                                        to_key_block: { type: 'boolean' },
                                        from: { $ref: '#/components/schemas/BlockRaw' },
                                        to: { $ref: '#/components/schemas/BlockRaw' },
                                        dest_proof: { type: 'string' },
                                        config_proof: { type: 'string' },
                                        signatures: {
                                            type: 'object',
                                            required: [
                                                'validator_set_hash',
                                                'catchain_seqno',
                                                'signatures'
                                            ],
                                            properties: {
                                                validator_set_hash: {
                                                    type: 'integer',
                                                    format: 'int64'
                                                },
                                                catchain_seqno: {
                                                    type: 'integer',
                                                    format: 'int32'
                                                },
                                                signatures: {
                                                    type: 'array',
                                                    items: {
                                                        type: 'object',
                                                        required: ['node_id_short', 'signature'],
                                                        properties: {
                                                            node_id_short: { type: 'string' },
                                                            signature: { type: 'string' }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            });
        },
        /**
         * @description Get raw config
         *
         * @tags Lite Server
         * @name GetRawConfig
         * @request GET:/v2/liteserver/get_config_all/{block_id}
         */
        getRawConfig: (blockId, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_config_all/${blockId}`,
                method: 'GET',
                query: query,
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['mode', 'id', 'state_proof', 'config_proof'],
                properties: {
                    mode: { type: 'integer', format: 'int32' },
                    id: { $ref: '#/components/schemas/BlockRaw' },
                    state_proof: { type: 'string' },
                    config_proof: { type: 'string' }
                }
            });
        },
        /**
         * @description Get raw shard block proof
         *
         * @tags Lite Server
         * @name GetRawShardBlockProof
         * @request GET:/v2/liteserver/get_shard_block_proof/{block_id}
         */
        getRawShardBlockProof: (blockId, params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_shard_block_proof/${blockId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['masterchain_id', 'links'],
                properties: {
                    masterchain_id: { $ref: '#/components/schemas/BlockRaw' },
                    links: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['id', 'proof'],
                            properties: {
                                id: { $ref: '#/components/schemas/BlockRaw' },
                                proof: { type: 'string' }
                            }
                        }
                    }
                }
            });
        },
        /**
         * @description Get out msg queue sizes
         *
         * @tags Lite Server
         * @name GetOutMsgQueueSizes
         * @request GET:/v2/liteserver/get_out_msg_queue_sizes
         */
        getOutMsgQueueSizes: (params = {}) => {
            const req = this.http.request({
                path: `/v2/liteserver/get_out_msg_queue_sizes`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                type: 'object',
                required: ['ext_msg_queue_size_limit', 'shards'],
                properties: {
                    ext_msg_queue_size_limit: { type: 'integer', format: 'uint32' },
                    shards: {
                        type: 'array',
                        items: {
                            type: 'object',
                            required: ['id', 'size'],
                            properties: {
                                id: { $ref: '#/components/schemas/BlockRaw' },
                                size: { type: 'integer', format: 'uint32' }
                            }
                        }
                    }
                }
            });
        }
    };
    multisig = {
        /**
         * @description Get multisig account info
         *
         * @tags Multisig
         * @name GetMultisigAccount
         * @request GET:/v2/multisig/{account_id}
         */
        getMultisigAccount: (accountId_Address, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/multisig/${accountId}`,
                method: 'GET',
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Multisig' });
        }
    };
    emulation = {
        /**
         * @description Decode a given message. Only external incoming messages can be decoded currently.
         *
         * @tags Emulation
         * @name DecodeMessage
         * @request POST:/v2/message/decode
         */
        decodeMessage: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/message/decode`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc'],
                    properties: { boc: { type: 'string', format: 'cell' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/DecodedMessage'
            });
        },
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation, Events
         * @name EmulateMessageToEvent
         * @request POST:/v2/events/emulate
         */
        emulateMessageToEvent: (data, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/events/emulate`,
                method: 'POST',
                query: query,
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc'],
                    properties: { boc: { type: 'string', format: 'cell' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Event' });
        },
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation, Traces
         * @name EmulateMessageToTrace
         * @request POST:/v2/traces/emulate
         */
        emulateMessageToTrace: (data, query, params = {}) => {
            const req = this.http.request({
                path: `/v2/traces/emulate`,
                method: 'POST',
                query: query,
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc'],
                    properties: { boc: { type: 'string', format: 'cell' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, { $ref: '#/components/schemas/Trace' });
        },
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation, Wallet
         * @name EmulateMessageToWallet
         * @request POST:/v2/wallet/emulate
         */
        emulateMessageToWallet: (data, params = {}) => {
            const req = this.http.request({
                path: `/v2/wallet/emulate`,
                method: 'POST',
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc'],
                    properties: {
                        boc: { type: 'string', format: 'cell' },
                        params: {
                            type: 'array',
                            items: {
                                type: 'object',
                                required: ['address'],
                                properties: {
                                    address: { type: 'string', format: 'address' },
                                    balance: {
                                        type: 'integer',
                                        format: 'bigint',
                                        'x-js-format': 'bigint'
                                    }
                                }
                            }
                        }
                    }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/MessageConsequences'
            });
        },
        /**
         * @description Emulate sending message to blockchain
         *
         * @tags Emulation, Accounts
         * @name EmulateMessageToAccountEvent
         * @request POST:/v2/accounts/{account_id}/events/emulate
         */
        emulateMessageToAccountEvent: (accountId_Address, data, query, params = {}) => {
            const accountId = accountId_Address.toRawString();
            const req = this.http.request({
                path: `/v2/accounts/${accountId}/events/emulate`,
                method: 'POST',
                query: query,
                body: prepareRequestData(data, {
                    type: 'object',
                    required: ['boc'],
                    properties: { boc: { type: 'string', format: 'cell' } }
                }),
                format: 'json',
                ...params
            });
            return prepareResponse(req, {
                $ref: '#/components/schemas/AccountEvent'
            });
        }
    };
}
exports.TonApiClient = TonApiClient;
