"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ContractAdapter: () => ContractAdapter
});
module.exports = __toCommonJS(src_exports);

// src/tonapi-adapter.ts
var import_core = require("@ton/core");
var import_client = require("@ton-api/client");
var import_buffer = require("buffer");
var ContractAdapter = class {
  constructor(tonapi) {
    this.tonapi = tonapi;
  }
  /**
   * Open smart contract
   * @param contract contract
   * @returns opened contract
   */
  open(contract) {
    return (0, import_core.openContract)(
      contract,
      (args) => createProvider(this.tonapi, args.address, args.init)
    );
  }
  /**
   * Create provider
   * @param address address
   * @param init optional init data
   * @returns provider
   */
  provider(address, init) {
    return createProvider(this.tonapi, address, init ? init : null);
  }
};
function createProvider(tonapi, address, init) {
  return {
    async getState() {
      const account = await tonapi.blockchain.getBlockchainRawAccount(address).catch((error) => {
        if (error.message !== "entity not found") {
          throw new Error(`Account request failed: ${error.message}`, error);
        }
        const mockResult = {
          address,
          balance: 0n,
          lastTransactionLt: void 0,
          status: import_client.AccountStatus.Uninit,
          storage: {
            usedCells: 1,
            usedBits: 95,
            usedPublicCells: 0,
            lastPaid: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3),
            duePayment: 0n
          }
        };
        return mockResult;
      });
      const last = account.lastTransactionHash !== void 0 && account.lastTransactionLt !== void 0 ? {
        lt: account.lastTransactionLt,
        hash: import_buffer.Buffer.from(account.lastTransactionHash, "base64")
      } : null;
      const stateGetters = {
        active: (account2) => ({
          type: "active",
          code: account2.code?.toBoc() ?? null,
          data: account2.data?.toBoc() ?? null
        }),
        uninit: () => ({
          type: "uninit"
        }),
        nonexist: () => ({
          type: "uninit"
        }),
        frozen: () => {
          throw new Error(`Frozen accounts are not supported by TonApi`);
        }
      };
      return {
        balance: account.balance,
        last,
        state: stateGetters[account.status](account)
      };
    },
    async get(name, args) {
      if (typeof name !== "string") {
        throw new Error("Method name must be a string for TonClient provider");
      }
      if (args.some((arg) => arg.type === "tuple")) {
        throw new Error("Tuples as get parameters are not supported by tonapi");
      }
      const result = await tonapi.blockchain.execGetMethodForBlockchainAccount(
        address,
        name,
        { args: args.map(TupleItemToTonapiString) }
      );
      return {
        stack: new import_core.TupleReader(result.stack)
      };
    },
    async external(message) {
      let neededInit = null;
      if (init && (await tonapi.accounts.getAccount(address)).status !== "active") {
        neededInit = init;
      }
      const ext = (0, import_core.external)({
        to: address,
        init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
        body: message
      });
      const boc = (0, import_core.beginCell)().store((0, import_core.storeMessage)(ext)).endCell();
      await tonapi.blockchain.sendBlockchainMessage({ boc });
    },
    async internal(via, message) {
      let neededInit = null;
      if (init && (await tonapi.accounts.getAccount(address)).status !== "active") {
        neededInit = init;
      }
      let bounce = true;
      if (message.bounce !== null && message.bounce !== void 0) {
        bounce = message.bounce;
      }
      let value;
      if (typeof message.value === "string") {
        value = (0, import_core.toNano)(message.value);
      } else {
        value = message.value;
      }
      let body = null;
      if (typeof message.body === "string") {
        body = (0, import_core.comment)(message.body);
      } else if (message.body) {
        body = message.body;
      }
      await via.send({
        to: address,
        value,
        bounce,
        sendMode: message.sendMode,
        init: neededInit,
        body
      });
    },
    open(contract) {
      return (0, import_core.openContract)(
        contract,
        (params) => createProvider(tonapi, params.address, params.init)
      );
    },
    getTransactions(address2, lt, hash, limit) {
      console.info(
        "hash param in getTransactions action ignored, beacause not supported",
        hash.toString("hex")
      );
      return tonapi.blockchain.getBlockchainAccountTransactions(address2, {
        before_lt: lt + 1n,
        limit
      }).then(
        ({ transactions }) => transactions.map((transaction) => (0, import_core.loadTransaction)(transaction.raw.asSlice()))
      );
    }
  };
}
function TupleItemToTonapiString(item) {
  switch (item.type) {
    case "int":
      return "0x" + item.value.toString(16);
    case "nan":
      return "NaN";
    case "null":
      return "Null";
    case "cell":
    case "builder":
      return item.cell.toBoc().toString("base64");
    case "slice":
      return item.cell.toBoc().toString("hex");
    case "tuple":
      throw new Error("Tuple is not supported in TonApi get method parameters");
    default:
      throw new Error(`Unknown type ${item.type}`);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ContractAdapter
});
//# sourceMappingURL=index.js.map