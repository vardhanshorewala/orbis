// src/tonapi-adapter.ts
import {
  beginCell,
  comment,
  external,
  openContract,
  storeMessage,
  toNano,
  TupleReader,
  loadTransaction
} from "@ton/core";
import {
  AccountStatus
} from "@ton-api/client";
import { Buffer } from "buffer";
var ContractAdapter = class {
  constructor(tonapi) {
    this.tonapi = tonapi;
  }
  /**
   * Open smart contract
   * @param contract contract
   * @returns opened contract
   */
  open(contract) {
    return openContract(
      contract,
      (args) => createProvider(this.tonapi, args.address, args.init)
    );
  }
  /**
   * Create provider
   * @param address address
   * @param init optional init data
   * @returns provider
   */
  provider(address, init) {
    return createProvider(this.tonapi, address, init ? init : null);
  }
};
function createProvider(tonapi, address, init) {
  return {
    async getState() {
      const account = await tonapi.blockchain.getBlockchainRawAccount(address).catch((error) => {
        if (error.message !== "entity not found") {
          throw new Error(`Account request failed: ${error.message}`, error);
        }
        const mockResult = {
          address,
          balance: 0n,
          lastTransactionLt: void 0,
          status: AccountStatus.Uninit,
          storage: {
            usedCells: 1,
            usedBits: 95,
            usedPublicCells: 0,
            lastPaid: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3),
            duePayment: 0n
          }
        };
        return mockResult;
      });
      const last = account.lastTransactionHash !== void 0 && account.lastTransactionLt !== void 0 ? {
        lt: account.lastTransactionLt,
        hash: Buffer.from(account.lastTransactionHash, "base64")
      } : null;
      const stateGetters = {
        active: (account2) => ({
          type: "active",
          code: account2.code?.toBoc() ?? null,
          data: account2.data?.toBoc() ?? null
        }),
        uninit: () => ({
          type: "uninit"
        }),
        nonexist: () => ({
          type: "uninit"
        }),
        frozen: () => {
          throw new Error(`Frozen accounts are not supported by TonApi`);
        }
      };
      return {
        balance: account.balance,
        last,
        state: stateGetters[account.status](account)
      };
    },
    async get(name, args) {
      if (typeof name !== "string") {
        throw new Error("Method name must be a string for TonClient provider");
      }
      if (args.some((arg) => arg.type === "tuple")) {
        throw new Error("Tuples as get parameters are not supported by tonapi");
      }
      const result = await tonapi.blockchain.execGetMethodForBlockchainAccount(
        address,
        name,
        { args: args.map(TupleItemToTonapiString) }
      );
      return {
        stack: new TupleReader(result.stack)
      };
    },
    async external(message) {
      let neededInit = null;
      if (init && (await tonapi.accounts.getAccount(address)).status !== "active") {
        neededInit = init;
      }
      const ext = external({
        to: address,
        init: neededInit ? { code: neededInit.code, data: neededInit.data } : null,
        body: message
      });
      const boc = beginCell().store(storeMessage(ext)).endCell();
      await tonapi.blockchain.sendBlockchainMessage({ boc });
    },
    async internal(via, message) {
      let neededInit = null;
      if (init && (await tonapi.accounts.getAccount(address)).status !== "active") {
        neededInit = init;
      }
      let bounce = true;
      if (message.bounce !== null && message.bounce !== void 0) {
        bounce = message.bounce;
      }
      let value;
      if (typeof message.value === "string") {
        value = toNano(message.value);
      } else {
        value = message.value;
      }
      let body = null;
      if (typeof message.body === "string") {
        body = comment(message.body);
      } else if (message.body) {
        body = message.body;
      }
      await via.send({
        to: address,
        value,
        bounce,
        sendMode: message.sendMode,
        init: neededInit,
        body
      });
    },
    open(contract) {
      return openContract(
        contract,
        (params) => createProvider(tonapi, params.address, params.init)
      );
    },
    getTransactions(address2, lt, hash, limit) {
      console.info(
        "hash param in getTransactions action ignored, beacause not supported",
        hash.toString("hex")
      );
      return tonapi.blockchain.getBlockchainAccountTransactions(address2, {
        before_lt: lt + 1n,
        limit
      }).then(
        ({ transactions }) => transactions.map((transaction) => loadTransaction(transaction.raw.asSlice()))
      );
    }
  };
}
function TupleItemToTonapiString(item) {
  switch (item.type) {
    case "int":
      return "0x" + item.value.toString(16);
    case "nan":
      return "NaN";
    case "null":
      return "Null";
    case "cell":
    case "builder":
      return item.cell.toBoc().toString("base64");
    case "slice":
      return item.cell.toBoc().toString("hex");
    case "tuple":
      throw new Error("Tuple is not supported in TonApi get method parameters");
    default:
      throw new Error(`Unknown type ${item.type}`);
  }
}
export {
  ContractAdapter
};
//# sourceMappingURL=index.mjs.map