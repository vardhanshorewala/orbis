"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectMetric = exports.OpCodeReserved = exports.calcComputePhase = exports.calcStateSize = exports.calcCellSize = exports.calcDictSize = exports.calcMessageSize = exports.resetMetricStore = exports.createMetricStore = exports.getMetricStore = exports.makeSnapshotMetric = exports.sortByCreatedAt = exports.isCodeHash = exports.isAddressFriendly = void 0;
const core_1 = require("@ton/core");
const ContractDatabase_1 = require("./ContractDatabase");
function isAddressFriendly(value) {
    return typeof value === 'string' && core_1.Address.isFriendly(value);
}
exports.isAddressFriendly = isAddressFriendly;
function isCodeHash(value) {
    return typeof value === 'string' && value.length === 66 && /^0x[0-9a-fA-F]+$/.test(value);
}
exports.isCodeHash = isCodeHash;
function sortByCreatedAt(reverse = false) {
    return (a, b) => (a.createdAt.getTime() - b.createdAt.getTime()) * (reverse ? -1 : 1);
}
exports.sortByCreatedAt = sortByCreatedAt;
const STORE_METRIC = Symbol.for('ton-sandbox-metric-store');
function makeSnapshotMetric(store, config = {}) {
    const label = config.label || 'current';
    const contractExcludes = config.contractExcludes || new Array();
    const contractDatabase = config.contractDatabase || ContractDatabase_1.ContractDatabase.from({});
    const snapshot = {
        label,
        createdAt: new Date(),
        items: new Array(),
    };
    // remove duplicates and extract ABI
    const seen = new Set();
    for (const metric of store) {
        const key = JSON.stringify(metric);
        if (seen.has(key))
            continue;
        snapshot.items.push(metric);
        seen.add(key);
        if (metric.codeHash) {
            contractDatabase.extract(metric);
        }
    }
    // ABI auto-mapping
    for (const item of snapshot.items) {
        const find = contractDatabase.by(item);
        if (!item.contractName && find.contractName) {
            item.contractName = find.contractName;
        }
        if (!item.methodName && find.methodName) {
            item.methodName = find.methodName;
        }
    }
    if (contractExcludes.length > 0) {
        snapshot.items = snapshot.items.filter((it) => typeof it.contractName === 'undefined' || !contractExcludes.includes(it.contractName));
    }
    return snapshot;
}
exports.makeSnapshotMetric = makeSnapshotMetric;
function getMetricStore(context = globalThis) {
    return context[STORE_METRIC];
}
exports.getMetricStore = getMetricStore;
function createMetricStore(context = globalThis) {
    if (!Array.isArray(context[STORE_METRIC])) {
        context[STORE_METRIC] = new Array();
    }
    return context[STORE_METRIC];
}
exports.createMetricStore = createMetricStore;
function resetMetricStore(context = globalThis) {
    const store = getMetricStore(context);
    if (store)
        store.length = 0;
    return createMetricStore(context);
}
exports.resetMetricStore = resetMetricStore;
function calcMessageSize(msg) {
    if (msg) {
        return calcCellSize((0, core_1.beginCell)().store((0, core_1.storeMessage)(msg)).endCell());
    }
    return { cells: 0, bits: 0 };
}
exports.calcMessageSize = calcMessageSize;
function calcDictSize(dict) {
    if (dict.size > 0) {
        return calcCellSize((0, core_1.beginCell)().storeDict(dict).endCell().asSlice().loadRef());
    }
    return { cells: 0, bits: 0 };
}
exports.calcDictSize = calcDictSize;
function calcCellSize(root, visited = new Set()) {
    const hash = root.hash().toString('hex');
    if (visited.has(hash)) {
        return { cells: 0, bits: 0 };
    }
    visited.add(hash);
    const out = {
        cells: 1,
        bits: root.bits.length,
    };
    for (const ref of root.refs) {
        const childRes = calcCellSize(ref, visited);
        out.cells += childRes.cells;
        out.bits += childRes.bits;
    }
    return out;
}
exports.calcCellSize = calcCellSize;
function calcStateSize(state) {
    const codeSize = calcCellSize(state.code);
    const dataSize = calcCellSize(state.data);
    return {
        code: codeSize,
        data: dataSize,
    };
}
exports.calcStateSize = calcStateSize;
function calcComputePhase(phase) {
    if (phase.type === 'vm') {
        return {
            type: phase.type,
            success: phase.success,
            gasUsed: Number(phase.gasUsed),
            exitCode: phase.exitCode,
            vmSteps: phase.vmSteps,
        };
    }
    return {
        type: phase.type,
    };
}
exports.calcComputePhase = calcComputePhase;
var OpCodeReserved;
(function (OpCodeReserved) {
    OpCodeReserved[OpCodeReserved["send"] = 0] = "send";
    OpCodeReserved[OpCodeReserved["notSupported"] = 4294967295] = "notSupported";
    OpCodeReserved[OpCodeReserved["notAllowed"] = 4294967294] = "notAllowed";
})(OpCodeReserved = exports.OpCodeReserved || (exports.OpCodeReserved = {}));
async function collectMetric(blockchain, ctx, result) {
    const store = getMetricStore();
    if (!Array.isArray(store)) {
        return;
    }
    let state = { data: { cells: 0, bits: 0 }, code: { cells: 0, bits: 0 } };
    let codeHash;
    if (ctx.contract.init && ctx.contract.init.code && ctx.contract.init.data) {
        codeHash = `0x${ctx.contract.init.code.hash().toString('hex')}`;
        state = calcStateSize({ code: ctx.contract.init.code, data: ctx.contract.init.data });
    }
    else {
        const account = (await blockchain.getContract(ctx.contract.address)).accountState;
        if (account && account.type === 'active' && account.state.code && account.state.data) {
            codeHash = `0x${account.state.code.hash().toString('hex')}`;
            state = calcStateSize({ code: account.state.code, data: account.state.data });
        }
    }
    let testName;
    if (globalThis['expect']) {
        testName = expect.getState().currentTestName;
    }
    let contractName = ctx.contract.constructor.name;
    let methodName = ctx.methodName;
    for (const tx of result.transactions) {
        if (tx.description.type !== 'generic')
            continue;
        const receiver = tx.inMessage?.info.type;
        const body = tx.inMessage?.body ? tx.inMessage.body.beginParse() : undefined;
        let opCode = '0x0';
        if (receiver === 'internal') {
            opCode = `0x${(body && body.remainingBits >= 32 ? body.preloadUint(32) : 0).toString(16)}`;
        }
        if (!methodName && Object.values(OpCodeReserved).includes(Number(opCode))) {
            methodName = OpCodeReserved[Number(opCode)];
        }
        const address = core_1.Address.parseRaw(`0:${tx.address.toString(16).padStart(64, '0')}`);
        const { computePhase, actionPhase, bouncePhase, storagePhase } = tx.description;
        const action = actionPhase
            ? {
                success: actionPhase.success,
                totalActions: actionPhase.totalActions,
                skippedActions: actionPhase.skippedActions,
                resultCode: actionPhase.resultCode,
                totalActionFees: actionPhase.totalActions,
                totalFwdFees: actionPhase.totalFwdFees ? Number(actionPhase.totalFwdFees) : undefined,
                totalMessageSize: {
                    cells: Number(actionPhase.totalMessageSize.cells),
                    bits: Number(actionPhase.totalMessageSize.bits),
                },
            }
            : undefined;
        const compute = calcComputePhase(computePhase);
        const metric = {
            testName,
            address: address.toString(),
            codeHash,
            contractName,
            methodName,
            receiver,
            opCode,
            execute: {
                compute,
                action,
            },
            message: {
                in: calcMessageSize(tx.inMessage),
                out: calcDictSize(tx.outMessages),
            },
            state,
        };
        store.push(metric);
        methodName = undefined;
        if (!address.equals(ctx.contract.address)) {
            contractName = ctx.contract.constructor.name;
        }
        else {
            contractName = undefined;
        }
    }
}
exports.collectMetric = collectMetric;
