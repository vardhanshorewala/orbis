"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.minComparisonDepth = exports.defaultDepthCompare = exports.defaultContractDatabaseName = exports.defaultReportName = exports.defaultSnapshotDir = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const chalk_1 = __importStar(require("chalk"));
const reporters_1 = require("@jest/reporters");
const BenchmarkCommand_1 = require("./BenchmarkCommand");
const BenchmarkEnvironment_1 = require("./BenchmarkEnvironment");
const readJsonl_1 = require("../utils/readJsonl");
const metric_1 = require("../metric");
exports.defaultSnapshotDir = '.snapshot';
exports.defaultReportName = 'gas-report';
exports.defaultContractDatabaseName = 'contract.abi.json';
exports.defaultDepthCompare = 2;
exports.minComparisonDepth = 1;
const PASS_TEXT = 'PASS';
const PASS = chalk_1.supportsColor ? chalk_1.default.reset.inverse.bold.green(` ${PASS_TEXT} `) : PASS_TEXT;
const SKIP_TEXT = 'SKIP';
const SKIP = chalk_1.supportsColor ? chalk_1.default.reset.inverse.bold.yellow(` ${SKIP_TEXT} `) : SKIP_TEXT;
class BenchmarkReporter extends reporters_1.BaseReporter {
    constructor(globalConfig, options = {}) {
        super();
        this.rootDirPath = globalConfig.rootDir;
        this.options = options;
        this.command = new BenchmarkCommand_1.BenchmarkCommand();
        if (this.depthCompare < exports.minComparisonDepth) {
            throw new Error(`The minimum depth compare must be greater than or equal to ${exports.minComparisonDepth}`);
        }
        this.contractDatabase = this.readContractDatabase();
    }
    get reportMode() {
        return this.options.reportMode || 'gas';
    }
    get reportName() {
        return this.options.reportName || exports.defaultReportName;
    }
    get snapshotDir() {
        return this.options.snapshotDir || exports.defaultSnapshotDir;
    }
    get snapshotDirPath() {
        const dirPath = (0, path_1.join)(this.rootDirPath, this.snapshotDir);
        try {
            if (!(0, fs_1.existsSync)(dirPath)) {
                (0, fs_1.mkdirSync)(dirPath, { recursive: true });
            }
        }
        catch (_) {
            throw new Error(`Can not create directory: ${dirPath}`);
        }
        return dirPath;
    }
    get depthCompare() {
        return this.options.depthCompare || exports.defaultDepthCompare;
    }
    get snapshotFiles() {
        return (0, metric_1.readSnapshots)(this.snapshotDirPath);
    }
    get snapshots() {
        return this.snapshotFiles.then((list) => Object.values(list).map((item) => item.content));
    }
    get snapshotCurrent() {
        return this.metricStore.then((store) => (0, metric_1.makeSnapshotMetric)(store, {
            contractDatabase: this.contractDatabase,
            contractExcludes: this.contractExcludes,
        }));
    }
    get removeRawResult() {
        return this.options.removeRawResult || true;
    }
    get contractExcludes() {
        return this.options.contractExcludes || [];
    }
    get sandboxMetricRawFile() {
        return (0, path_1.join)(this.rootDirPath, BenchmarkEnvironment_1.sandboxMetricRawFile);
    }
    get metricStore() {
        if ((0, fs_1.existsSync)(this.sandboxMetricRawFile)) {
            return (0, readJsonl_1.readJsonl)(this.sandboxMetricRawFile);
        }
        return new Promise((resolve) => resolve([]));
    }
    readContractDatabase() {
        let data = {};
        const filePath = this.options.contractDatabase || exports.defaultContractDatabaseName;
        if (typeof filePath === 'string') {
            try {
                if ((0, fs_1.existsSync)((0, path_1.join)(this.rootDirPath, filePath))) {
                    data = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(this.rootDirPath, filePath), 'utf-8'));
                }
            }
            catch (error) {
                throw new Error(`Could not parse contract database: ${filePath}`);
            }
        }
        return metric_1.ContractDatabase.from(data);
    }
    saveContractDatabase() {
        const contractDatabase = this.options.contractDatabase;
        let filePath = typeof contractDatabase === 'string' ? contractDatabase : exports.defaultContractDatabaseName;
        try {
            const content = JSON.stringify(this.contractDatabase.data, null, 2) + '\n';
            (0, fs_1.writeFileSync)((0, path_1.join)(this.rootDirPath, filePath), content, {
                encoding: 'utf8',
            });
        }
        catch (_) {
            throw new Error(`Can not write: ${filePath}`);
        }
    }
    async onRunComplete() {
        const log = [];
        let status = SKIP;
        if (this.command.doBenchmark) {
            const list = await this.snapshots;
            const snapshots = [await this.snapshotCurrent, ...list];
            let doDiff = this.command.doDiff;
            const depthCompare = Math.min(snapshots.length, this.depthCompare);
            if (doDiff) {
                log.push(`Comparison metric mode: ${this.reportMode} depth: ${depthCompare}`);
                switch (this.reportMode) {
                    case 'gas':
                        log.push(...this.gasReportReport(snapshots, depthCompare));
                        status = PASS;
                        break;
                    default:
                        throw new Error(`Report mode ${this.reportMode} not supported`);
                }
            }
            else if (this.command.label) {
                log.push(`Collect metric mode: "${this.reportMode}"`);
                const file = await this.saveSnapshot(this.command.label);
                log.push(`Report write in '${file}'`);
                status = PASS;
            }
            if (this.removeRawResult) {
                (0, fs_1.unlinkSync)(this.sandboxMetricRawFile);
            }
            this.saveContractDatabase();
        }
        else {
            log.push(`Reporter mode: ${this.reportMode}`);
        }
        this.log(`${status} ${log.join('\n')}`);
    }
    gasReportReport(data, benchmarkDepth) {
        const log = [];
        const reportFile = `${this.reportName}.json`;
        const report = (0, metric_1.makeGasReport)(data);
        try {
            const reportFilePath = (0, path_1.join)(this.rootDirPath, reportFile);
            (0, fs_1.writeFileSync)(reportFilePath, JSON.stringify(report, null, 2) + '\n', {
                encoding: 'utf8',
            });
            log.push(`Gas report write in '${reportFile}'`);
        }
        catch (_) {
            throw new Error(`Can not write: ${reportFile}`);
        }
        const list = report.sort((0, metric_1.sortByCreatedAt)(true)).slice(0, benchmarkDepth);
        log.push((0, metric_1.gasReportTable)(list, metric_1.defaultColor));
        return log;
    }
    async saveSnapshot(label) {
        const snapshot = await this.snapshotCurrent;
        snapshot.label = label;
        const list = await this.snapshotFiles;
        let snapshotFile = `${snapshot.createdAt.getTime()}.json`;
        if (list[snapshot.label]) {
            snapshotFile = list[snapshot.label].name;
        }
        const snapshotFilePath = (0, path_1.join)(this.snapshotDirPath, snapshotFile);
        try {
            (0, fs_1.writeFileSync)(snapshotFilePath, JSON.stringify(snapshot, null, 2) + '\n', {
                encoding: 'utf8',
            });
        }
        catch (_) {
            throw new Error(`Can not write: ${(0, path_1.join)(this.snapshotDir, snapshotFile)}`);
        }
        return (0, path_1.join)(this.snapshotDir, snapshotFile);
    }
}
exports.default = BenchmarkReporter;
