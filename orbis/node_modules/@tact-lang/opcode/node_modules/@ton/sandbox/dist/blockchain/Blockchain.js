"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = exports.toSandboxContract = exports.SANDBOX_CONTRACT_SYMBOL = void 0;
const defaultConfig_1 = require("../config/defaultConfig");
const core_1 = require("@ton/core");
const Executor_1 = require("../executor/Executor");
const BlockchainStorage_1 = require("./BlockchainStorage");
const Event_1 = require("../event/Event");
const BlockchainContractProvider_1 = require("./BlockchainContractProvider");
const BlockchainSender_1 = require("./BlockchainSender");
const Treasury_1 = require("../treasury/Treasury");
const AsyncLock_1 = require("../utils/AsyncLock");
const message_1 = require("../utils/message");
const slimConfig_1 = require("../config/slimConfig");
const testTreasurySubwalletId_1 = require("../utils/testTreasurySubwalletId");
const collectMetric_1 = require("../metric/collectMetric");
const CREATE_WALLETS_PREFIX = 'CREATE_WALLETS';
function createWalletsSeed(idx) {
    return `${CREATE_WALLETS_PREFIX}${idx}`;
}
const LT_ALIGN = 1000000n;
exports.SANDBOX_CONTRACT_SYMBOL = Symbol('SandboxContract');
/**
 * Provide way to check if contract is in sandbox environment.
 * @param contract Any open contract
 * @throws Error if contract not a sandbox contract
 */
function toSandboxContract(contract) {
    if (contract[exports.SANDBOX_CONTRACT_SYMBOL] === true) {
        return contract;
    }
    throw new Error('Invalid contract: not a sandbox contract');
}
exports.toSandboxContract = toSandboxContract;
const TREASURY_INIT_BALANCE_TONS = 1000000;
function blockchainConfigToBase64(config) {
    switch (config) {
        case 'default':
            return defaultConfig_1.defaultConfig;
        case 'slim':
            return slimConfig_1.slimConfig;
        default:
            return config?.toBoc({ idx: false }).toString('base64') ?? defaultConfig_1.defaultConfig;
    }
}
class Blockchain {
    /**
     * Saves snapshot of current blockchain.
     * @example
     * const snapshot = blockchain.snapshot();
     * // some operations
     * await blockchain.loadFrom(snapshot); // restores blockchain state
     */
    snapshot() {
        return {
            contracts: this.storage.knownContracts().map(s => s.snapshot()),
            networkConfig: this.networkConfig,
            lt: this.currentLt,
            time: this.currentTime,
            verbosity: { ...this.logsVerbosity },
            libs: this.globalLibs,
            nextCreateWalletIndex: this.nextCreateWalletIndex,
        };
    }
    /**
     * Restores blockchain state from snapshot.
     * Usage provided in {@link Blockchain#snapshot}.
     *
     * @param snapshot Snapshot of blockchain
     */
    async loadFrom(snapshot) {
        this.storage.clearKnownContracts();
        this.contractFetches.clear();
        for (const contract of snapshot.contracts) {
            const storageContract = await this.getContract(contract.address);
            storageContract.loadFrom(contract);
        }
        this.networkConfig = snapshot.networkConfig;
        this.currentLt = snapshot.lt;
        this.currentTime = snapshot.time;
        this.logsVerbosity = { ...snapshot.verbosity };
        this.globalLibs = snapshot.libs;
        this.nextCreateWalletIndex = snapshot.nextCreateWalletIndex;
    }
    get recordStorage() {
        return this.shouldRecordStorage;
    }
    /**
     * If set to `true`, [BlockchainTransaction]{@link BlockchainTransaction} will have `oldStorage` and `newStorage` fields.
     *
     * Note that enabling this flag will disable a certain optimization, which will slow down contract emulation
     *
     * @param v
     */
    set recordStorage(v) {
        this.shouldRecordStorage = v;
    }
    /**
     * @returns Current time in blockchain
     */
    get now() {
        return this.currentTime;
    }
    /**
     * Updates Current time in blockchain.
     * @param now UNIX time to set
     */
    set now(now) {
        this.currentTime = now;
    }
    /**
     * @returns Current logical time in blockchain
     */
    get lt() {
        return this.currentLt;
    }
    constructor(opts) {
        this.currentLt = 0n;
        this.messageQueue = [];
        this.logsVerbosity = {
            print: true,
            blockchainLogs: false,
            vmLogs: 'none',
            debugLogs: true,
        };
        this.lock = new AsyncLock_1.AsyncLock();
        this.contractFetches = new Map();
        this.nextCreateWalletIndex = 0;
        this.shouldRecordStorage = false;
        this.networkConfig = blockchainConfigToBase64(opts.config);
        this.executor = opts.executor;
        this.storage = opts.storage;
        this.meta = opts.meta;
    }
    /**
     * @returns Config used in blockchain.
     */
    get config() {
        return core_1.Cell.fromBase64(this.networkConfig);
    }
    /**
     * @returns Config used in blockchain in base64 format.
     */
    get configBase64() {
        return this.networkConfig;
    }
    /**
     * @returns Current PrevBlocksInfo
     */
    get prevBlocks() {
        return this.prevBlocksInfo;
    }
    /**
     * Sets PrevBlocksInfo.
     * @param value PrevBlocksInfo to set
     */
    set prevBlocks(value) {
        this.prevBlocksInfo = value;
    }
    /**
     * Emulates the result of sending a message to this Blockchain. Emulates the whole chain of transactions before returning the result. Each transaction increases lt by 1000000.
     *
     * @param message Message to send
     * @param params Optional params
     * @returns Result of queue processing
     *
     * @example
     * const result = await blockchain.sendMessage(internal({
     *      from: sender.address,
     *      to: address,
     *      value: toNano('1'),
     *      body: beginCell().storeUint(0, 32).endCell(),
     * }));
     */
    async sendMessage(message, params) {
        await this.pushMessage(message);
        return await this.runQueue(params);
    }
    /**
     * Starts emulating the result of sending a message to this Blockchain (refer to {@link sendMessage}). Each iterator call emulates one transaction, so the whole chain is not emulated immediately, unlike in {@link sendMessage}.
     *
     * @param message Message to send
     * @param params Optional params
     * @returns Async iterable of {@link BlockchainTransaction}
     *
     * @example
     * const message = internal({
     *     from: sender.address,
     *     to: address,
     *     value: toNano('1'),
     *     body: beginCell().storeUint(0, 32).endCell(),
     * }, { randomSeed: crypto.randomBytes(32) });
     * for await (const tx of await blockchain.sendMessageIter(message)) {
     *     // process transaction
     * }
     */
    async sendMessageIter(message, params) {
        params = {
            now: this.now,
            ...params,
        };
        await this.pushMessage(message);
        // Iterable will lock on per tx basis
        return await this.txIter(true, params);
    }
    /**
     * Runs tick or tock transaction.
     *
     * @param on Address or addresses to run tick-tock
     * @param which Type of transaction (tick or tock)
     * @param [params] Params to run tick tock transaction
     * @returns Result of tick-tock transaction
     *
     * @example
     * let res = await blockchain.runTickTock(address, 'tock');
     */
    async runTickTock(on, which, params) {
        for (const addr of (Array.isArray(on) ? on : [on])) {
            await this.pushTickTock(addr, which);
        }
        return await this.runQueue(params);
    }
    /**
     * Runs get method on contract.
     *
     * @param address Address or addresses to run get method
     * @param method MethodId or method name to run
     * @param stack Method params
     * @param [params] Params to run get method
     * @returns Result of get method
     *
     * @example
     * const { stackReader } = await blockchain.runGetMethod(address, 'get_now', [], {
     *     now: 2,
     * });
     * const now = res.stackReader.readNumber();
     */
    async runGetMethod(address, method, stack = [], params) {
        return await (await this.getContract(address)).get(method, stack, {
            now: this.now,
            ...params,
        });
    }
    async pushMessage(message) {
        const msg = message instanceof core_1.Cell ? (0, core_1.loadMessage)(message.beginParse()) : message;
        if (msg.info.type === 'external-out') {
            throw new Error('Cannot send external out message');
        }
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'message',
                ...msg,
            });
        });
    }
    async pushTickTock(on, which) {
        await this.lock.with(async () => {
            this.messageQueue.push({
                type: 'ticktock',
                on,
                which,
            });
        });
    }
    async runQueue(params) {
        const txes = await this.processQueue(params);
        return {
            transactions: txes,
            events: txes.map(tx => tx.events).flat(),
            externals: txes.map(tx => tx.externals).flat(),
        };
    }
    txIter(needsLocking, params) {
        const it = { next: () => this.processTx(needsLocking, params), [Symbol.asyncIterator]() { return it; } };
        return it;
    }
    async processInternal(params) {
        let result = undefined;
        let done = this.messageQueue.length == 0;
        while (!done) {
            const message = this.messageQueue.shift();
            let tx;
            if (message.type === 'message') {
                if (message.info.type === 'external-out') {
                    done = this.messageQueue.length == 0;
                    continue;
                }
                this.currentLt += LT_ALIGN;
                tx = await (await this.getContract(message.info.dest)).receiveMessage(message, params);
            }
            else {
                this.currentLt += LT_ALIGN;
                tx = await (await this.getContract(message.on)).runTickTock(message.which, params);
            }
            const transaction = {
                ...tx,
                events: (0, Event_1.extractEvents)(tx),
                parent: message.parentTransaction,
                children: [],
                externals: [],
            };
            transaction.parent?.children.push(transaction);
            result = transaction;
            done = true;
            for (const message of transaction.outMessages.values()) {
                if (message.info.type === 'external-out') {
                    transaction.externals.push({
                        info: {
                            type: 'external-out',
                            src: message.info.src,
                            dest: message.info.dest ?? undefined,
                            createdAt: message.info.createdAt,
                            createdLt: message.info.createdLt,
                        },
                        init: message.init ?? undefined,
                        body: message.body,
                    });
                    continue;
                }
                this.messageQueue.push({
                    type: 'message',
                    parentTransaction: transaction,
                    ...message,
                });
                if (message.info.type === 'internal') {
                    this.startFetchingContract(message.info.dest);
                }
            }
        }
        return result === undefined ? { value: result, done: true } : { value: result, done: false };
    }
    async processTx(needsLocking, params) {
        // Lock only if not locked already
        return needsLocking ? await this.lock.with(async () => this.processInternal(params)) : await this.processInternal(params);
    }
    async processQueue(params) {
        params = {
            now: this.now,
            ...params,
        };
        return await this.lock.with(async () => {
            // Locked already
            const txs = this.txIter(false, params);
            const result = [];
            for await (const tx of txs) {
                result.push(tx);
            }
            return result;
        });
    }
    /**
     * Creates new {@link ContractProvider} for contract address.
     *
     * @param address Address to create contract provider for
     * @param init Initial state of contract
     *
     * @example
     * const contractProvider = blockchain.provider(address, init);
     */
    provider(address, init) {
        return new BlockchainContractProvider_1.BlockchainContractProvider({
            getContract: (addr) => this.getContract(addr),
            pushMessage: (msg) => this.pushMessage(msg),
            runGetMethod: (addr, method, args) => this.runGetMethod(addr, method, args),
            pushTickTock: (on, which) => this.pushTickTock(on, which),
            openContract: (contract) => this.openContract(contract),
        }, address, init);
    }
    /**
     * Creates {@link Sender} for address.
     *
     * Note, that this sender pushes internal messages to Blockchain directly.
     * No value is deducted from sender address, all the values are set to defaults. Use for test purposes only.
     *
     * @example
     * const sender = this.sender(address);
     * await contract.send(sender, ...);
     *
     * @param address Address to create sender for
     */
    sender(address) {
        return new BlockchainSender_1.BlockchainSender({
            pushMessage: (msg) => this.pushMessage(msg),
        }, address);
    }
    treasuryParamsToMapKey(workchain, seed) {
        return `${workchain}:${seed}`;
    }
    /**
     * Creates treasury wallet contract. This wallet is used as alternative to wallet smart contract.
     *
     * @param {string} seed Initial seed for treasury. If the same seed is used to create a treasury, then these treasuries will be identical
     * @param {TreasuryParams} params Params for treasury creation. See {@link TreasuryParams} for more information.
     *
     * @example
     * const wallet = await blockchain.treasury('wallet')
     * await wallet.send({
     *     to: someAddress,
     *     value: toNano('0.5'),
     * });
     */
    async treasury(seed, params) {
        const subwalletId = (0, testTreasurySubwalletId_1.testSubwalletId)(seed);
        const wallet = this.openContract(Treasury_1.TreasuryContract.create(params?.workchain ?? 0, subwalletId));
        const contract = await this.getContract(wallet.address);
        if ((params?.predeploy ?? true) && (contract.accountState === undefined || contract.accountState.type === 'uninit')) {
            await this.sendMessage((0, message_1.internal)({
                from: new core_1.Address(0, Buffer.alloc(32)),
                to: wallet.address,
                value: (0, core_1.toNano)(1),
                stateInit: wallet.init,
            }));
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        else if ((params?.resetBalanceIfZero ?? true) && contract.balance === 0n) {
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        this.meta?.upsert(wallet.address, { treasurySeed: seed });
        return wallet;
    }
    /**
     * Bulk variant of {@link treasury}.
     * @param n Number of wallets to create
     * @param params Params for treasury creation. See {@link TreasuryParams} for more information.
     * @returns Array of opened treasury contracts
     *
     * @example
     * const [wallet1, wallet2, wallet3] = await blockchain.createWallets(3);
     */
    async createWallets(n, params) {
        const wallets = [];
        for (let i = 0; i < n; i++) {
            const seed = createWalletsSeed(this.nextCreateWalletIndex++);
            wallets.push(await this.treasury(seed, params));
        }
        return wallets;
    }
    /**
     * Opens contract. Returns proxy that substitutes the blockchain Provider in methods starting with get and set.
     *
     * @param contract Contract to open.
     *
     * @example
     * const contract = blockchain.openContract(new Contract(address));
     */
    openContract(contract) {
        let address;
        let init = undefined;
        if (!core_1.Address.isAddress(contract.address)) {
            throw Error('Invalid address');
        }
        address = contract.address;
        if (contract.init) {
            if (!(contract.init.code instanceof core_1.Cell)) {
                throw Error('Invalid init.code');
            }
            if (!(contract.init.data instanceof core_1.Cell)) {
                throw Error('Invalid init.data');
            }
            init = contract.init;
        }
        this.meta?.upsert(address, { wrapperName: contract?.constructor?.name, abi: contract.abi });
        const provider = this.provider(address, init);
        const blkch = this;
        return new Proxy(contract, {
            get(target, prop) {
                if (prop === exports.SANDBOX_CONTRACT_SYMBOL) {
                    return true;
                }
                const value = target[prop];
                if (typeof prop === 'string' && typeof value === 'function') {
                    const ctx = {
                        contract,
                        methodName: prop,
                    };
                    if (prop.startsWith('get')) {
                        return (...args) => value.apply(target, [provider, ...args]);
                    }
                    else if (prop.startsWith('send')) {
                        return async (...args) => {
                            let ret = value.apply(target, [provider, ...args]);
                            if (ret instanceof Promise) {
                                ret = await ret;
                            }
                            const out = {
                                ...await blkch.runQueue(),
                                result: ret,
                            };
                            await (0, collectMetric_1.collectMetric)(blkch, ctx, out);
                            return out;
                        };
                    }
                }
                return value;
            }
        });
    }
    startFetchingContract(address) {
        const addrString = address.toRawString();
        let promise = this.contractFetches.get(addrString);
        if (promise !== undefined) {
            return promise;
        }
        promise = this.storage.getContract(this, address);
        this.contractFetches.set(addrString, promise);
        return promise;
    }
    /**
     * Retrieves {@link SmartContract} from {@link BlockchainStorage}.
     * @param address Address of contract to get
     */
    async getContract(address) {
        try {
            const contract = await this.startFetchingContract(address);
            return contract;
        }
        catch (e) {
            throw e;
        }
        finally {
            this.contractFetches.delete(address.toRawString());
        }
    }
    /**
     * @returns {LogsVerbosity} level
     */
    get verbosity() {
        return this.logsVerbosity;
    }
    /**
     * Updates logs verbosity level.
     * @param {LogsVerbosity} value
     */
    set verbosity(value) {
        this.logsVerbosity = value;
    }
    /**
     * Updates logs verbosity level for address.
     */
    async setVerbosityForAddress(address, verbosity) {
        const contract = await this.getContract(address);
        contract.setVerbosity(verbosity);
    }
    /**
     * Updates blockchain config
     *
     * @param {BlockchainConfig} config - Custom config in Cell format, or predefined `default` | `slim`
     */
    setConfig(config) {
        this.networkConfig = blockchainConfigToBase64(config);
    }
    async setShardAccount(address, account) {
        const contract = await this.getContract(address);
        contract.account = account;
    }
    /**
     * Retrieves global libs cell
     */
    get libs() {
        return this.globalLibs;
    }
    /**
     * Update global blockchain libs.
     *
     * @param value Cell in libs format: Dictionary<CellHash, Cell>
     *
     * @example
     * const code = await compile('Contract');
     *
     * const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell());
     * libsDict.set(code.hash(), code);
     *
     * blockchain.libs = beginCell().storeDictDirect(libsDict).endCell();
     */
    set libs(value) {
        this.globalLibs = value;
    }
    /**
     * Creates instance of sandbox blockchain.
     *
     * @param [opts.executor] Custom contract executor. If omitted {@link Executor} is used.
     * @param [opts.config] Config used in blockchain. If omitted {@link defaultConfig} is used.
     * @param [opts.storage] Contracts storage used for blockchain. If omitted {@link LocalBlockchainStorage} is used.
     * @param [opts.meta] Optional contracts metadata provider. If not provided, {@link @ton/test-utils.contractsMeta} will be used to accumulate contracts metadata.
     * @example
     * const blockchain = await Blockchain.create({ config: 'slim' });
     *
     * @example Remote storage
     * let client = new TonClient4({
     *     endpoint: 'https://mainnet-v4.tonhubapi.com'
     * })
     *
     * let blockchain = await Blockchain.create({
     *     storage: new RemoteBlockchainStorage(wrapTonClient4ForRemote(client), 34892000)
     * });
     */
    static async create(opts) {
        return new Blockchain({
            executor: opts?.executor ?? await Executor_1.Executor.create(),
            storage: opts?.storage ?? new BlockchainStorage_1.LocalBlockchainStorage(),
            meta: opts?.meta ?? require('@ton/test-utils')?.contractsMeta,
            ...opts
        });
    }
}
exports.Blockchain = Blockchain;
