import { BitString, Cell, Slice } from "@ton/core";
import type { Instruction, Operand } from "../spec/tvm-spec";
type ExtractType<T extends Operand["type"], A = Operand> = A extends {
    type: T;
} ? A : never;
export type UintOperand = ExtractType<"uint">;
export type IntOperand = ExtractType<"int">;
export type PushLongOperand = ExtractType<"pushint_long">;
export type SubsliceOperand = ExtractType<"subslice">;
export type RefOperand = ExtractType<"ref">;
export type NumericOperand = UintOperand | IntOperand;
export interface NumericValue {
    readonly type: "numeric";
    readonly definition: NumericOperand;
    readonly value: number;
    readonly bitcode: BitString;
}
export interface BigIntValue {
    readonly type: "bigint";
    readonly definition: PushLongOperand;
    readonly value: bigint;
    readonly bitcode: BitString;
}
export interface RefValue {
    readonly type: "ref";
    readonly definition: RefOperand;
    readonly value: Cell;
    readonly bitcode: BitString;
}
export interface SliceValue {
    readonly type: "subslice";
    readonly definition: SubsliceOperand;
    readonly value: Cell;
    readonly source: Cell;
    readonly offsetBits: number;
    readonly offsetRefs: number;
    readonly limitBits: number;
    readonly limitRefs: number;
}
export type OperandValue = NumericValue | BigIntValue | RefValue | SliceValue;
export interface DecodedInstruction {
    readonly definition: Instruction;
    readonly operands: OperandValue[];
}
export interface DecompiledInstruction {
    readonly op: DecodedInstruction;
    readonly hash: string;
    readonly offset: number;
    readonly length: number;
}
export declare function decodeInstruction(source: Cell, slice: Slice): DecodedInstruction;
export declare function parseInstructions(source: Cell, slice: Slice, instruction: Instruction): OperandValue[];
export {};
//# sourceMappingURL=operand-loader.d.ts.map