"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.disassemble = disassemble;
exports.disassembleAndProcess = disassembleAndProcess;
exports.disassembleRoot = disassembleRoot;
exports.disassembleRawRoot = disassembleRawRoot;
const core_1 = require("@ton/core");
const subcell_1 = require("../utils/subcell");
const operand_loader_1 = require("./operand-loader");
const helpers_1 = require("../ast/helpers");
const helpers_2 = require("../spec/helpers");
const errors_1 = require("./errors");
/**
 * Disassembles a cell into a list of instructions.
 */
function disassemble(args) {
    const bitsOffset = args.offset?.bits ?? 0;
    const refsOffset = args.offset?.refs ?? 0;
    const bitsLimit = args.limit?.bits ?? args.source.bits.length - bitsOffset;
    const refsLimit = args.limit?.refs ?? args.source.refs.length - refsOffset;
    // Process only a slice of the source cell to support partial disassembly
    const slice = (0, subcell_1.subslice)({
        cell: args.source,
        offsetBits: bitsOffset,
        offsetRefs: refsOffset,
        bits: bitsLimit,
        refs: refsLimit,
    });
    const instructions = [];
    const hash = args.source.hash().toString("hex");
    while (slice.remainingBits > 0) {
        const opcodeOffset = slice.offsetBits;
        const opcode = (0, operand_loader_1.decodeInstruction)(args.source, slice);
        const opcodeLength = slice.offsetBits - opcodeOffset;
        instructions.push({
            op: opcode,
            hash,
            offset: opcodeOffset,
            length: opcodeLength,
        });
    }
    // Since every cell can contain references to other cells, we need to disassemble them recursively.
    while (slice.remainingRefs > 0) {
        const source = slice.loadRef();
        instructions.push(...disassemble({ source }));
    }
    return instructions;
}
/**
 * Disassembles a cell into a list of instructions with the help of `disassembly` function
 * and processes them to correctly handle references, calls and operands.
 *
 * This function is a core function of the decompiler.
 */
function disassembleAndProcess(args) {
    const opcodes = disassemble(args);
    const hash = args.source.hash().toString("hex");
    const offset = args.offset?.bits ?? 0;
    const instructions = opcodes.map(op => processInstruction(op, args));
    if (instructions.length === 0) {
        return (0, helpers_1.createBlock)([], hash, offset, 0);
    }
    const lastInstruction = instructions.at(-1);
    if (lastInstruction === undefined)
        throw new Error("unreachable");
    return (0, helpers_1.createBlock)(instructions, hash, offset, lastInstruction.offset + lastInstruction.length);
}
/**
 * Processes an instruction to correctly handle references, calls and operands.
 */
function processInstruction(op, args) {
    const opcode = op.op;
    const opcodeName = opcode.definition.mnemonic;
    switch (opcodeName) {
        case "CALLREF": {
            return processCallRef(op, args);
        }
        case "CALLDICT":
        case "CALLDICT_LONG":
        case "JMPDICT": {
            return processCallDict(op);
        }
    }
    return processDefaultInstruction(op, args);
}
/**
 * Processes a `CALLREF` instruction.
 *
 * Decompiler has two modes for decompilation.
 *
 * In bitcode `CALLREF` means that the code of the function
 * placed in the operand of this instruction.
 *
 * In some cases we want to extract the code of the function
 * to another standalone function to make the result more readable.
 */
function processCallRef(op, args) {
    const opcode = op.op;
    const operand = opcode.operands.find(it => it.definition.name === "c");
    if (!operand || operand.type !== "ref") {
        throw new errors_1.OperandError(opcode.definition.mnemonic, "c", "Cell", {
            operands: opcode.operands,
        });
    }
    // onCellReference is set when we want to extract the code of the function
    if (args.onCellReference) {
        args.onCellReference(operand.value);
        return (0, helpers_1.createInstruction)(
        // actually INLINECALLDICT is Fift opcode, not TVM,
        // but we use it to get same behavior when compiling the resulting
        // Fift asm file back to the TVM code
        PSEUDO_INLINECALLDICT, [
            {
                type: "reference",
                hash: operand.value.hash().toString("hex"),
            },
        ], op.offset, op.length, op.hash);
    }
    const block = disassembleAndProcess({
        source: operand.value,
        offset: {
            bits: 0,
            refs: 0,
        },
        onCellReference: args.onCellReference,
    });
    return (0, helpers_1.createInstruction)(opcode, [{ ...block, cell: true }], op.offset, op.length, op.hash);
}
/**
 * Processes a `CALLDICT`, `CALLDICT_LONG` or `JMPDICT` instruction.
 */
function processCallDict(op) {
    const opcode = op.op;
    const operand = opcode.operands.find(it => it.definition.name === "n");
    if (!operand || operand.type !== "numeric") {
        throw new errors_1.OperandError(opcode.definition.mnemonic, "n", "numeric", {
            operands: opcode.operands,
        });
    }
    return (0, helpers_1.createInstruction)(opcode, [
        {
            type: "method_reference",
            methodId: operand.value,
        },
    ], op.offset, op.length, op.hash);
}
/**
 * Processes all other instructions.
 *
 * In other instructions we need to process all its operands if any.
 */
function processDefaultInstruction(op, args) {
    const opcode = op.op;
    const operands = opcode.operands.map((operand) => {
        switch (operand.type) {
            case "numeric": {
                return processNumericOperand(operand);
            }
            case "bigint": {
                return {
                    type: "scalar",
                    value: operand.value,
                };
            }
            case "ref":
            case "subslice": {
                return processRefOrSliceOperand(opcode, operand, args);
            }
            default: {
                throw new errors_1.UnknownOperandTypeError(operand, {
                    instruction: opcode.definition.mnemonic,
                });
            }
        }
    });
    return (0, helpers_1.createInstruction)(opcode, operands, op.offset, op.length, op.hash);
}
/**
 * Processes a numeric operand.
 *
 * Numeric operand can be actually be a stack entry, control register or just a scalar.
 */
function processNumericOperand(operand) {
    const displayHints = operand.definition.display_hints;
    // some instructions have hints with value that should be added to the operand
    // for example for `PUSHPOW2` it's 1
    const addHint = displayHints.find((hint) => hint.type === "add");
    const add = addHint?.value ?? 0;
    const displayNumber = (0, helpers_2.getDisplayNumber)(operand, add, displayHints);
    if ((0, helpers_2.hasHint)(displayHints, "stack")) {
        return {
            type: "stack_entry",
            value: displayNumber,
        };
    }
    if ((0, helpers_2.hasHint)(displayHints, "register")) {
        return {
            type: "control_register",
            value: displayNumber,
        };
    }
    return {
        type: "scalar",
        value: displayNumber,
    };
}
/**
 * Processes a reference or slice operand.
 */
function processRefOrSliceOperand(opcode, operand, args) {
    const displayHints = operand.definition.display_hints;
    const opcodeName = opcode.definition.mnemonic;
    if ((0, helpers_2.hasHint)(displayHints, "continuation") ||
        opcodeName === "PUSHCONT" ||
        opcodeName === "PUSHCONT_SHORT") {
        if (operand.type === "ref") {
            const block = disassembleAndProcess({
                source: operand.value,
                offset: {
                    bits: 0,
                    refs: 0,
                },
                onCellReference: args.onCellReference,
            });
            return {
                ...block,
                cell: true,
            };
        }
        return disassembleAndProcess({
            source: operand.source,
            offset: {
                bits: operand.offsetBits,
                refs: operand.offsetRefs,
            },
            limit: {
                bits: operand.limitBits,
                refs: operand.limitRefs,
            },
            onCellReference: args.onCellReference,
        });
    }
    return {
        type: "scalar",
        value: operand.value.toString(),
    };
}
function findDictOpcode(opcodes) {
    return opcodes.find(it => it.op.definition.mnemonic === "DICTPUSHCONST");
}
function findRootMethods(opcodes) {
    const methods = [];
    if (opcodes[2]?.op.definition.mnemonic === "PUSHCONT") {
        const cont = opcodes[2].op.operands.at(0);
        if (!cont || cont.type !== "subslice") {
            return methods;
        }
        const recvInternal = disassembleRawRoot(cont.value);
        methods.push({
            type: "method",
            hash: recvInternal.hash,
            offset: recvInternal.offset,
            body: recvInternal,
            id: 0,
        });
    }
    if (opcodes[6]?.op.definition.mnemonic === "PUSHCONT") {
        const cont = opcodes[6].op.operands.at(0);
        if (!cont || cont.type !== "subslice") {
            return methods;
        }
        const recvExternal = disassembleRawRoot(cont.value);
        methods.push({
            type: "method",
            hash: recvExternal.hash,
            offset: recvExternal.offset,
            body: recvExternal,
            id: -1,
        });
    }
    return methods;
}
/**
 * Disassembles the root cell into a list of instructions.
 *
 * Use this function if you want to disassemble the whole BoC file with dictionary unpacked.
 */
function disassembleRoot(cell, options) {
    const opcodes = disassemble({ source: cell });
    const args = {
        source: cell,
        offset: { bits: 0, refs: 9 },
        onCellReference: undefined,
    };
    const rootMethods = findRootMethods(opcodes);
    const dictOpcode = findDictOpcode(opcodes);
    if (!dictOpcode) {
        // Likely some non-Tact/FunC produced BoC
        return {
            type: "program",
            topLevelInstructions: opcodes.map(op => processInstruction(op, args)),
            procedures: [],
            methods: rootMethods,
            withRefs: options.computeRefs,
        };
    }
    const { procedures, methods } = deserializeDict(dictOpcode.op.operands, options.computeRefs);
    return {
        type: "program",
        topLevelInstructions: opcodes.map(op => processInstruction(op, args)),
        procedures,
        methods: [...rootMethods, ...methods],
        withRefs: options.computeRefs,
    };
}
/**
 * Disassembles a cell without any additional unpacking of the dictionary.
 */
function disassembleRawRoot(cell) {
    return disassembleAndProcess({
        source: cell,
        onCellReference: undefined,
    });
}
/**
 * Deserializes a dictionary from the dictionary opcode to list
 * of procedures and methods.
 */
function deserializeDict(operands, computeRefs) {
    const dictKeyLen = operands.find(operand => operand.definition.name === "n");
    const dictCell = operands.find(operand => operand.definition.name === "d");
    if (!dictKeyLen || !dictCell || dictKeyLen.type !== "numeric" || dictCell.type !== "ref") {
        throw new Error("Cannot find valid operands for Cell and length");
    }
    function createCodeCell() {
        return {
            serialize: (_src, _builder) => {
                throw new Error("Not implemented");
            },
            parse: (src) => {
                const cloned = src.clone(true);
                const offset = src.offsetBits;
                return { offset, cell: cloned.asCell() };
            },
        };
    }
    const countEntries = dictKeyLen.value;
    const dict = core_1.Dictionary.loadDirect(core_1.Dictionary.Keys.Int(countEntries), createCodeCell(), dictCell.value);
    const registeredCells = new Map();
    const procedures = [];
    function extractReferencedCell(cell) {
        const callHash = cell.hash().toString("hex");
        const prevCell = registeredCells.get(callHash);
        if (prevCell !== undefined) {
            return prevCell;
        }
        const name = "?fun_ref_" + callHash.substring(0, 16);
        registeredCells.set(callHash, name);
        const block = disassembleAndProcess({
            source: cell,
            onCellReference: extractReferencedCell,
        });
        procedures.push({
            type: "procedure",
            hash: callHash,
            body: block,
        });
        return name;
    }
    const methods = [...dict].map(([key, value]) => {
        return {
            type: "method",
            id: key,
            body: disassembleAndProcess({
                source: value.cell,
                offset: { bits: value.offset, refs: 0 },
                onCellReference: computeRefs ? extractReferencedCell : undefined,
            }),
            hash: value.cell.hash().toString("hex"),
            offset: value.offset,
        };
    });
    return {
        procedures,
        methods,
    };
}
const PSEUDO_INLINECALLDICT = {
    definition: {
        mnemonic: "INLINECALLDICT",
        doc: {
            fift: "",
            opcode: "",
            gas: "",
            category: "",
            stack: "",
            description: "",
            fift_examples: [],
        },
        bytecode: {
            operands: [],
            tlb: "",
            prefix: "",
        },
        control_flow: {
            branches: [],
            nobranch: true,
        },
        value_flow: {
            inputs: {
                stack: [],
                registers: [],
            },
            outputs: {
                stack: [],
                registers: [],
            },
        },
        since_version: 0,
    },
    operands: [],
};
//# sourceMappingURL=disasm.js.map