import { Cell } from "@ton/core";
import { DecompiledInstruction } from "./operand-loader";
import { BlockNode, ProgramNode } from "../ast/ast";
export interface DisassembleParams {
    /**
     * The cell to disassemble.
     */
    readonly source: Cell;
    /**
     * The offset in the cell to start disassembling from.
     */
    readonly offset?: {
        bits: number;
        refs: number;
    };
    /**
     * The limit in the cell to stop disassembling at.
     */
    readonly limit?: {
        bits: number;
        refs: number;
    };
}
/**
 * Disassembles a cell into a list of instructions.
 */
export declare function disassemble(args: DisassembleParams): DecompiledInstruction[];
export interface DisassembleAndProcessParams extends DisassembleParams {
    readonly onCellReference?: (cell: Cell) => void;
}
/**
 * Disassembles a cell into a list of instructions with the help of `disassembly` function
 * and processes them to correctly handle references, calls and operands.
 *
 * This function is a core function of the decompiler.
 */
export declare function disassembleAndProcess(args: DisassembleAndProcessParams): BlockNode;
/**
 * Disassembles the root cell into a list of instructions.
 *
 * Use this function if you want to disassemble the whole BoC file with dictionary unpacked.
 */
export declare function disassembleRoot(cell: Cell, options: {
    /**
     * Whether to deduplicate refs into separate functions. True, by default.
     */
    computeRefs: boolean;
}): ProgramNode;
/**
 * Disassembles a cell without any additional unpacking of the dictionary.
 */
export declare function disassembleRawRoot(cell: Cell): BlockNode;
//# sourceMappingURL=disasm.d.ts.map