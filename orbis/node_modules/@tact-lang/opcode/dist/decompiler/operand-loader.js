"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeInstruction = decodeInstruction;
exports.parseInstructions = parseInstructions;
const core_1 = require("@ton/core");
const binutils_1 = require("../utils/binutils");
const prefix_matcher_1 = require("../utils/prefix-matcher");
const errors_1 = require("./errors");
const tricks_1 = require("../utils/tricks");
const prefixMatcher = new prefix_matcher_1.PrefixMatcher();
function decodeInstruction(source, slice) {
    const definition = prefixMatcher.loadPrefix(slice);
    const operands = parseInstructions(source, slice, definition);
    return {
        definition,
        operands,
    };
}
function parseInstructions(source, slice, instruction) {
    const operands = [];
    for (const operand of instruction.bytecode.operands) {
        try {
            operands.push(parseInstruction(source, operand, slice));
        }
        catch (error) {
            throw new errors_1.DisassemblerError(`Bad operand ${operand.name} for instruction ${instruction.mnemonic}`, {
                cause: error,
            });
        }
    }
    return operands;
}
function parseInstruction(source, operand, slice) {
    const type = operand.type;
    if (type === "uint") {
        const raw = slice.clone().loadBits(operand.size);
        return {
            type: "numeric",
            definition: operand,
            bitcode: raw,
            value: slice.loadUint(operand.size),
        };
    }
    if (type === "int") {
        const raw = slice.clone().loadBits(operand.size);
        return {
            type: "numeric",
            definition: operand,
            bitcode: raw,
            value: slice.loadInt(operand.size),
        };
    }
    if (type === "ref") {
        const raw = slice.clone().loadRef();
        return { type: "ref", definition: operand, bitcode: raw.bits, value: slice.loadRef() };
    }
    if (type === "pushint_long") {
        const cloned = slice.clone();
        const prefix = slice.loadUint(5);
        const length = 8 * prefix + 19;
        const raw = cloned.loadBits(5 + length);
        return {
            type: "bigint",
            definition: operand,
            bitcode: raw,
            value: slice.loadIntBig(length),
        };
    }
    // Handle remaining subslice type
    const refLength = (operand.refs_add ?? 0) +
        (operand.refs_length_var_size ? slice.loadUint(operand.refs_length_var_size) : 0);
    const bitLength = operand.bits_padding +
        (operand.bits_length_var_size ? slice.loadUint(operand.bits_length_var_size) * 8 : 0);
    const offsetBits = slice.offsetBits;
    const offsetRefs = slice.offsetRefs;
    const loadedBits = slice.loadBits(bitLength);
    const bits = operand.completion_tag ? (0, binutils_1.removeCompletionTag)(loadedBits) : loadedBits;
    const builder = new core_1.Builder();
    builder.storeBits(bits);
    (0, tricks_1.repeat)(refLength, () => builder.storeRef(slice.loadRef()));
    return {
        type: "subslice",
        definition: operand,
        value: builder.endCell(),
        source: source,
        offsetBits,
        offsetRefs,
        limitBits: bitLength,
        limitRefs: refLength,
    };
}
//# sourceMappingURL=operand-loader.js.map