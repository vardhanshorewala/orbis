"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrefixMatcher = void 0;
const binutils_1 = require("./binutils");
const cp0_json_1 = __importDefault(require("../spec/cp0.json"));
class PrefixMatcher {
    instructions;
    longestPrefixLength;
    constructor() {
        const cp0 = cp0_json_1.default;
        this.instructions = new Map(cp0.instructions.map(inst => [
            (0, binutils_1.prefixToBin)(inst.bytecode.prefix).toString(), // normalize prefixes such as CFC0_ to CFC_
            inst,
        ]));
        this.longestPrefixLength = Math.max(...cp0.instructions.map(inst => (0, binutils_1.prefixToBin)(inst.bytecode.prefix).length));
    }
    loadPrefix(slice) {
        for (let bits = 1; bits <= this.longestPrefixLength; bits++) {
            if (slice.remainingBits < bits) {
                throw new Error(`Prefix not found, slice was: ${slice.toString()}`);
            }
            const prefix = slice.preloadBits(bits);
            const instruction = this.instructions.get(prefix.toString());
            if (instruction === undefined)
                continue;
            const rangeCheck = instruction.bytecode.operands_range_check;
            if (rangeCheck !== undefined) {
                if (slice.remainingBits < prefix.length + rangeCheck.length)
                    continue;
                const operands = slice.clone().skip(prefix.length).loadUint(rangeCheck.length);
                if (operands < rangeCheck.from || operands > rangeCheck.to)
                    continue;
            }
            slice.skip(bits);
            return instruction;
        }
        throw new Error(`Prefix not found, slice was: ${slice.toString()}`);
    }
}
exports.PrefixMatcher = PrefixMatcher;
//# sourceMappingURL=prefix-matcher.js.map