"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.main = void 0;
const arg_consumer_1 = require("../arg-consumer");
const arg_parser_1 = require("../arg-parser");
const logger_1 = require("../logger");
const version_1 = require("../version");
const error_schema_1 = require("./error-schema");
const fs = __importStar(require("fs"));
const fmt_1 = require("../../fmt/fmt");
const path_1 = __importStar(require("path"));
const colors_1 = require("../colors");
const glob_1 = require("glob");
const process_1 = require("process");
const fmtVersion = "0.0.1";
const main = () => {
    const Log = (0, logger_1.CliLogger)();
    const Errors = (0, error_schema_1.FormatterErrors)(Log.log);
    try {
        const argv = process.argv.slice(2);
        processArgs(Errors, argv);
    }
    catch (e) {
        Errors.unexpected(e);
    }
    if (Log.hadErrors()) {
        // https://nodejs.org/docs/v20.12.1/api/process.html#exit-codes
        process.exit(30);
    }
};
exports.main = main;
const processArgs = (Errors, argv) => {
    const Parser = (0, arg_parser_1.ArgParser)(Errors);
    const getArgs = ArgSchema(Parser);
    const match = getArgs(argv);
    if (match.kind === "ok") {
        const Args = (0, arg_consumer_1.ArgConsumer)(Errors, match.value);
        parseArgs(Errors, Args);
    }
    else {
        showHelp();
    }
};
const ArgSchema = (Parser) => {
    return Parser.tokenizer
        .add(Parser.boolean("write", "w"))
        .add(Parser.boolean("check", "c"))
        .add(Parser.boolean("version", "v"))
        .add(Parser.boolean("help", "h"))
        .add(Parser.immediate).end;
};
const showHelp = () => {
    console.log(`
    Usage
      $ tact-fmt [...flags] <files> or <directories>

    Flags
      -w, --write                 Write result to same file
      -c, --check                 Check if the given files are formatted
      -v, --version               Print tact-fmt version and exit
      -h, --help                  Display this text and exit

    Examples
      $ tact-fmt --version
      ${fmtVersion}

      $ tact-fmt file.tact
      Format and output the result to stdout

      $ tact-fmt -w file.tact
      Format and rewrite file.tact

      $ tact-fmt -w ./sources
      Format and rewrite all Tact files in ./sources

      $ tact-fmt -w ./sources ./scripts
      Format and rewrite all Tact files in ./sources and ./scripts`);
};
const markup = (0, colors_1.getAnsiMarkup)(Boolean((0, colors_1.isColorSupported)()));
function formatFile(filepath, mode) {
    const content = readFileOrFail(filepath);
    if (typeof content === "undefined")
        return undefined;
    const [res, time] = measureTime(() => (0, fmt_1.formatCode)(filepath, content));
    if (res.$ === "FormatCodeError") {
        console.error(`Cannot format file ${path_1.default.relative((0, process_1.cwd)(), filepath)}:`, res.message);
        return undefined;
    }
    const alreadyFormatted = content === res.code;
    if (mode === "check") {
        if (alreadyFormatted) {
            return true;
        }
        console.log(`[${markup.yellow("warn")}]`, path_1.default.basename(filepath));
        return false;
    }
    if (mode === "format-and-write") {
        console.log(markup.gray(path_1.default.basename(filepath)), `${time.toFixed(0)}ms`, status(content, res.code));
        fs.writeFileSync(filepath, res.code);
        return alreadyFormatted;
    }
    else {
        console.log(res.code);
    }
    return alreadyFormatted;
}
function status(before, after) {
    if (before !== after) {
        return "(reformatted)";
    }
    return "(unchanged)";
}
function measureTime(fn) {
    const startTime = performance.now();
    const result = fn();
    const endTime = performance.now();
    const time = endTime - startTime;
    return [result, time];
}
const parseArgs = (Errors, Args) => {
    if (Args.single("help")) {
        if (noUnknownParams(Errors, Args)) {
            showHelp();
        }
        return;
    }
    if (Args.single("version")) {
        if (noUnknownParams(Errors, Args)) {
            console.log(fmtVersion);
            (0, version_1.showCommit)();
        }
        return;
    }
    const write = Args.single("write") ?? false;
    const onlyCheck = Args.single("check") ?? false;
    if (write && onlyCheck) {
        Errors.checkAndWrite();
        process.exit(1);
    }
    const filePaths = Args.multiple("immediate") ?? [];
    if (filePaths.length === 0) {
        if (noUnknownParams(Errors, Args)) {
            showHelp();
        }
        return;
    }
    const mode = onlyCheck ? "check" : write ? "format-and-write" : "format";
    if (mode === "check") {
        console.log("Checking formatting...");
    }
    const filesToFormat = collectFilesToFormat(filePaths);
    let someFileCannotBeFormatted = false;
    let allFormatted = true;
    for (const file of filesToFormat) {
        const res = formatFile(file, mode);
        if (typeof res === "undefined") {
            someFileCannotBeFormatted = true;
        }
        else {
            allFormatted &&= res;
        }
    }
    if (onlyCheck) {
        if (!allFormatted) {
            console.log("Code style issues found in the above file. Run tact-fmt with --write to fix.");
            process.exit(1);
        }
        else {
            console.log("All Tact files use official code style!");
        }
    }
    if (someFileCannotBeFormatted) {
        process.exit(1);
    }
};
const collectFilesToFormat = (paths) => {
    return paths.flatMap((path) => {
        if (!fs.statSync(path).isFile()) {
            return globSync(["**/*.tact"], { cwd: path }).map((file) => (0, path_1.join)(path, file));
        }
        else {
            return path;
        }
    });
};
const noUnknownParams = (Errors, Args) => {
    const leftoverArgs = Args.leftover();
    if (leftoverArgs.length === 0) {
        return true;
    }
    for (const argument of leftoverArgs) {
        Errors.unexpectedArgument(argument);
    }
    showHelp();
    return false;
};
function readFileOrFail(filePath) {
    try {
        return fs.readFileSync(filePath, "utf8");
    }
    catch (e) {
        const error = e;
        console.error(`Cannot read file: ${error.message}`);
        return undefined;
    }
}
const globSync = (globs, options) => {
    return globs.flatMap((g) => glob_1.glob.sync(g, options));
};
