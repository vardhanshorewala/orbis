"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeNonBouncedRouter = writeNonBouncedRouter;
exports.writeLoadOpcode = writeLoadOpcode;
exports.groupContractReceivers = groupContractReceivers;
exports.writeBouncedRouter = writeBouncedRouter;
exports.messageOpcode = messageOpcode;
exports.commentPseudoOpcode = commentPseudoOpcode;
const core_1 = require("@ton/core");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const id_1 = require("./id");
const ops_1 = require("./ops");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const writeFunction_1 = require("./writeFunction");
const errors_1 = require("../../error/errors");
const errors_2 = require("../../abi/errors");
const resolveFuncTypeFromAbiUnpack_1 = require("./resolveFuncTypeFromAbiUnpack");
const resolveAllocation_1 = require("../../storage/resolveAllocation");
const features_1 = require("../../config/features");
const ast_helpers_1 = require("../../ast/ast-helpers");
const constEval_1 = require("../../optimizer/constEval");
const util_1 = require("../../ast/util");
const ast_printer_1 = require("../../ast/ast-printer");
const text_1 = require("../../utils/text");
const writeSerialization_1 = require("./writeSerialization");
// empty string receiver (`receive("")`) is not allowed
function writeNonBouncedRouter(receivers, contract, wCtx) {
    // - Special case: there are no receivers at all
    if (typeof receivers.empty === "undefined" &&
        receivers.binary.length === 0 &&
        receivers.comment.length === 0 &&
        typeof receivers.commentFallback === "undefined" &&
        typeof receivers.fallback === "undefined") {
        wCtx.append(`throw(${errors_2.contractErrors.invalidMessage.id});`);
        return;
    }
    // - Special case: only fallback receiver
    if (typeof receivers.fallback !== "undefined" &&
        receivers.binary.length === 0 &&
        receivers.comment.length === 0 &&
        typeof receivers.commentFallback === "undefined" &&
        typeof receivers.empty === "undefined") {
        writeFallbackReceiver(receivers.fallback, contract, "in_msg", wCtx);
        return;
    }
    const writeBinaryReceivers = (msgOpcodeRemoved) => {
        receivers.binary.forEach((binRcv) => {
            writeBinaryReceiver(binRcv, msgOpcodeRemoved, contract, wCtx);
            wCtx.append();
        });
    };
    // - Special case: only binary receivers and possibly
    //    - fallback receiver not reading its input message, or
    //    - empty fallback receiver, or
    //    - fallback receiver of the form `receive(msg: Slice) { throw(CODE) }`
    //      where CODE is a statically known exit code expression
    if (typeof receivers.empty === "undefined" &&
        receivers.comment.length === 0 &&
        typeof receivers.commentFallback === "undefined" &&
        fallbackReceiverKind(receivers.fallback, wCtx).kind !== "unknown") {
        wCtx.append(`var op = in_msg~load_opcode_${receivers.kind}();`);
        writeBinaryReceivers(true);
        if (typeof receivers.fallback !== "undefined") {
            writeFallbackReceiver(receivers.fallback, contract, "in_msg", wCtx);
        }
        else {
            // "default" fallback receiver
            wCtx.append(`;; Throw if not handled`);
            wCtx.append(`throw(${errors_2.contractErrors.invalidMessage.id});`);
        }
        return;
    }
    // If there is a fallback receiver and binary/string receivers, we need to keep in_msg intact,
    // otherwise we can modify in_msg in-place
    const opcodeReader = typeof receivers.fallback === "undefined"
        ? "~load_uint"
        : ".preload_uint";
    const doesHaveTextReceivers = receivers.comment.length > 0 ||
        typeof receivers.commentFallback !== "undefined";
    wCtx.append("int op = 0;");
    wCtx.append("int in_msg_length = slice_bits(in_msg);");
    wCtx.inBlock("if (in_msg_length >= 32)", () => {
        wCtx.append(`op = in_msg${opcodeReader}(32);`);
        if (doesHaveTextReceivers) {
            writeBinaryReceivers(opcodeReader === "~load_uint");
        }
    });
    // NOTE: It should be more efficient to write all binary receivers inside
    //       `in_msg_length` length if-check regardless of text receivers,
    //       but while using Fift this way is better
    if (!doesHaveTextReceivers) {
        writeBinaryReceivers(opcodeReader === "~load_uint");
    }
    if (typeof receivers.empty !== "undefined") {
        const emptyRcv = receivers.empty;
        wCtx.append(";; Receive empty message");
        wCtx.inBlock("if ((op == 0) & (in_msg_length <= 32))", () => {
            writeReceiverBody(emptyRcv, contract, wCtx);
        });
    }
    writeCommentReceivers(receivers.comment, receivers.commentFallback, receivers.kind, opcodeReader === "~load_uint", typeof receivers.fallback !== "undefined", contract, wCtx);
    if (typeof receivers.fallback !== "undefined") {
        wCtx.append(";; Receiver fallback");
        writeFallbackReceiver(receivers.fallback, contract, "in_msg", wCtx);
    }
    else {
        wCtx.append(`;; Throw if not handled`);
        wCtx.append(`throw(${errors_2.contractErrors.invalidMessage.id});`);
    }
}
function writeBinaryReceiver(binaryReceiver, msgOpcodeRemoved, contract, wCtx) {
    const selector = binaryReceiver.selector;
    if (selector.kind !== "internal-binary" &&
        selector.kind !== "external-binary")
        (0, errors_1.throwInternalCompilerError)(`Invalid selector type: ${selector.kind} (internal-binary or external-binary is expected)`, binaryReceiver.ast.loc);
    const type = (0, resolveDescriptors_1.getType)(wCtx.ctx, selector.type);
    if (!type.header) {
        (0, errors_1.throwInternalCompilerError)(`Invalid allocation: ${selector.type}`, binaryReceiver.ast.loc);
    }
    wCtx.append(`;; Receive ${selector.type} message`);
    wCtx.inBlock(`if (op == ${messageOpcode(type.header)})`, () => {
        if (!msgOpcodeRemoved) {
            wCtx.append("in_msg~skip_bits(32);");
        }
        const name = (0, id_1.funcIdOf)(selector.name);
        if (type.fields.length === 0) {
            // special case for empty messages
            wCtx.append(`var ${name} = empty_tuple();`);
        }
        else {
            // write cell parser in place for much better performance
            const allocation = (0, resolveAllocation_1.getAllocation)(wCtx.ctx, type.name);
            (0, writeSerialization_1.writeCellParser)(allocation.root, type, 0, wCtx, name, "in_msg");
        }
        writeReceiverBody(binaryReceiver, contract, wCtx);
    });
}
function writeCommentReceivers(commentReceivers, commentFallbackReceiver, kind, msgOpcodeRemoved, fallbackReceiverExists, contract, wCtx) {
    // - Special case: no text receivers at all
    if (typeof commentFallbackReceiver === "undefined" &&
        commentReceivers.length === 0) {
        return;
    }
    const writeFallbackTextReceiver = (commentFallbackReceiver) => {
        const writeFallbackTextReceiverInternal = () => {
            wCtx.append(";; Fallback Text Receiver");
            wCtx.inBlock("if (in_msg_length >= 32)", () => {
                const inMsg = msgOpcodeRemoved
                    ? "in_msg"
                    : "in_msg.skip_bits(32)";
                writeFallbackReceiver(commentFallbackReceiver, contract, inMsg, wCtx);
            });
        };
        // We optimize fallback
        if (!fallbackReceiverExists) {
            wCtx.inBlock("if (op == 0)", writeFallbackTextReceiverInternal);
        }
        else {
            writeFallbackTextReceiverInternal();
        }
    };
    const writeTextReceivers = () => {
        // - Special case: only fallback comment receiver
        if (typeof commentFallbackReceiver !== "undefined" &&
            commentReceivers.length === 0) {
            writeFallbackTextReceiver(commentFallbackReceiver);
            return;
        }
        wCtx.append("var text_op = slice_hash(in_msg);");
        commentReceivers.forEach((commentRcv) => {
            if (commentRcv.selector.kind !== "external-comment" &&
                commentRcv.selector.kind !== "internal-comment") {
                (0, errors_1.throwInternal)(`Wrong type of a text receiver: ${commentRcv.selector.kind}`);
                return;
            }
            const hash = commentPseudoOpcode(commentRcv.selector.comment, !msgOpcodeRemoved, commentRcv.ast.loc);
            const comment = (0, text_1.escapeUnicodeControlCodes)(commentRcv.selector.comment);
            wCtx.append(`;; Receive "${comment}" message`);
            wCtx.inBlock(`if (text_op == 0x${hash})`, () => {
                writeReceiverBody(commentRcv, contract, wCtx);
            });
        });
        if (typeof commentFallbackReceiver !== "undefined") {
            writeFallbackTextReceiver(commentFallbackReceiver);
        }
    };
    wCtx.append(";; Empty Receiver and Text Receivers");
    if (fallbackReceiverExists) {
        wCtx.inBlock("if (op == 0)", writeTextReceivers);
    }
    else {
        // - Special case: no fallback receiver
        writeTextReceivers();
    }
}
// this opcode reader utility only handles the cases of only binary receivers + different special cases
// for the fallback receiver (for instance, there is neither empty receiver nor text receivers)
function writeLoadOpcode(receivers, wCtx) {
    const loadOpcodeSignature = `(slice, int) ~load_opcode_${receivers.kind}(slice s)`;
    // assumes the boolean flag is already at the top of the stack
    const throwIfNot = (exitCode) => {
        if (exitCode < 2 ** 11)
            return `${exitCode} THROWIFNOT`;
        else
            return `${exitCode} PUSHINT SWAP THROWANYIFNOT`;
    };
    const fbRcvKind = fallbackReceiverKind(receivers.fallback, wCtx);
    switch (fbRcvKind.kind) {
        case "unknown":
            return;
        case "no-fallback":
        case "statically-known-single-throw": {
            // no fallback receiver or fallback with throw
            const exitCode = fbRcvKind.kind === "no-fallback"
                ? errors_2.contractErrors.invalidMessage.id
                : fbRcvKind.exitCode;
            wCtx.append(";; message opcode reader utility: only binary receivers");
            wCtx.append(`;; Returns 32 bit message opcode, otherwise throws the "Invalid incoming message" exit code`);
            wCtx.append(`${loadOpcodeSignature} asm( -> 1 0) "32 LDUQ ${throwIfNot(exitCode)}";`);
            return;
        }
        case "empty-body": {
            // fallback receiver with empty body
            wCtx.append(";; message opcode reader utility: binary receivers and empty fallback receiver");
            wCtx.append(";; Returns 32 bit message opcode, or returns immediately if the message is shorter than 32 bits");
            wCtx.append(`${loadOpcodeSignature} asm( -> 1 0) "32 LDUQ IFNOTRET";`);
            return;
        }
        case "wildcard-parameter": {
            // fallback receiver with non-empty body and wildcard parameter
            wCtx.append(";; message opcode reader utility: binary receivers and non-empty fallback receiver that does not read the message");
            wCtx.append(";; Returns 32 bit message opcode, or -1 if the message is shorter than 32 bits");
            wCtx.append(`${loadOpcodeSignature} asm "32 LDUQ NEGATE 2 0 BLKPUSH DROPX ROLLX";`);
            /*
            32 LDUQ
            1. x s′ −1
            2. s 0

            NEGATE 2 0 BLKPUSH
            1. x s′ 1 1 1
            2. s 0  0 0

            DROPX
            1. x s′ 1
            2. s 0  0

            ROLLX
            1. s′ x
            2. s  0
            */
            return;
        }
    }
}
function fallbackReceiverKind(fallback, wCtx) {
    // Note the order of the `if` statements is very important
    // For instance, `receive(foo: Slice) { } and
    // `receive(_: Slice) { throw(0xFFFF) }` have higher priority
    // compared to a fallback receiver that does not read its message, i.e.
    // `receive(_: Slice) { /* body that is not `throw()` and not empty */}`
    if (typeof fallback === "undefined") {
        return { kind: "no-fallback" };
    }
    if (fallback.ast.statements.length === 0) {
        return { kind: "empty-body" };
    }
    // fallback receiver with single statement `throw(CODE)` in its body
    const [fbStmt] = fallback.ast.statements;
    if (typeof fbStmt !== "undefined") {
        if (fbStmt.kind === "statement_expression" &&
            fbStmt.expression.kind === "static_call" &&
            (0, ast_helpers_1.idText)(fbStmt.expression.function) === "throw") {
            const [throwArg] = fbStmt.expression.args;
            const util = (0, util_1.getAstUtil)((0, ast_helpers_1.getAstFactory)());
            if (typeof throwArg !== "undefined") {
                const constEvalResult = (0, constEval_1.evalConstantExpression)(throwArg, wCtx.ctx, util);
                if (constEvalResult.kind !== "number") {
                    (0, errors_1.throwInternalCompilerError)(`"throw" can only have a number as an argument, but it throws ${(0, ast_printer_1.prettyPrint)(constEvalResult)}`, throwArg.loc);
                }
                if (constEvalResult.value < 0n ||
                    constEvalResult.value >= 2n ** 16n) {
                    (0, errors_1.throwCompilationError)(`Invalid exit code for "throw": ${constEvalResult.value}, but it must be in range [0, 65535]`, throwArg.loc);
                }
                return {
                    kind: "statically-known-single-throw",
                    exitCode: Number(constEvalResult.value),
                };
            }
            else {
                (0, errors_1.throwInternalCompilerError)(`"throw" must have an argument`, fbStmt.expression.loc);
            }
        }
    }
    if (fallback.selector.name.kind === "wildcard") {
        return { kind: "wildcard-parameter" };
    }
    return { kind: "unknown" };
}
function groupContractReceivers(contract) {
    const contractReceivers = {
        internal: {
            kind: "internal",
            empty: undefined,
            binary: [],
            comment: [],
            commentFallback: undefined,
            fallback: undefined,
        },
        external: {
            kind: "external",
            empty: undefined,
            binary: [],
            comment: [],
            commentFallback: undefined,
            fallback: undefined,
        },
        bounced: {
            binary: [],
            fallback: undefined,
        },
    };
    for (const receiver of contract.receivers) {
        const selector = receiver.selector;
        switch (selector.kind) {
            case "internal-empty":
                contractReceivers.internal.empty = receiver;
                break;
            case "internal-binary":
                contractReceivers.internal.binary.push(receiver);
                break;
            case "internal-comment":
                contractReceivers.internal.comment.push(receiver);
                break;
            case "internal-comment-fallback":
                contractReceivers.internal.commentFallback = {
                    selector,
                    effects: receiver.effects,
                    ast: receiver.ast,
                };
                break;
            case "internal-fallback":
                contractReceivers.internal.fallback = {
                    selector,
                    effects: receiver.effects,
                    ast: receiver.ast,
                };
                break;
            case "external-empty":
                contractReceivers.external.empty = receiver;
                break;
            case "external-binary":
                contractReceivers.external.binary.push(receiver);
                break;
            case "external-comment":
                contractReceivers.external.comment.push(receiver);
                break;
            case "external-comment-fallback":
                contractReceivers.external.commentFallback = {
                    selector,
                    effects: receiver.effects,
                    ast: receiver.ast,
                };
                break;
            case "external-fallback":
                contractReceivers.external.fallback = {
                    selector,
                    effects: receiver.effects,
                    ast: receiver.ast,
                };
                break;
            case "bounce-binary":
                contractReceivers.bounced.binary.push(receiver);
                break;
            case "bounce-fallback":
                contractReceivers.bounced.fallback = {
                    selector,
                    effects: receiver.effects,
                    ast: receiver.ast,
                };
                break;
        }
    }
    return contractReceivers;
}
function writeBouncedRouter(bouncedReceivers, contract, wCtx) {
    wCtx.append(";; Handle bounced messages");
    // - Special case: there are no bounce receivers at all, we can skip the bounce handling
    if (typeof bouncedReceivers.fallback === "undefined" &&
        bouncedReceivers.binary.length === 0) {
        wCtx.append("if (msg_bounced) { return (); }");
        return;
    }
    // - Special case: there is only a fallback receiver
    if (typeof bouncedReceivers.fallback !== "undefined" &&
        bouncedReceivers.binary.length === 0) {
        const bouncedFallback = bouncedReceivers.fallback;
        wCtx.inBlock("if (msg_bounced)", () => {
            wCtx.append(";; Fallback bounce receiver");
            wCtx.append(";; Skip 0xFFFFFFFF prefix of the bounced message");
            wCtx.append("in_msg~skip_bits(32);");
            writeFallbackReceiver(bouncedFallback, contract, "in_msg", wCtx);
        });
        return;
    }
    // If there is a fallback receiver and bounced message receivers, we need to keep in_msg intact,
    // otherwise we can modify in_msg in-place
    const opcodeReader = typeof bouncedReceivers.fallback === "undefined"
        ? "~load_uint"
        : ".preload_uint";
    wCtx.inBlock("if (msg_bounced)", () => {
        wCtx.append(";; Skip 0xFFFFFFFF prefix of a bounced message");
        wCtx.append("in_msg~skip_bits(32);");
        wCtx.append(`int op = 0;`);
        wCtx.inBlock("if (slice_bits(in_msg) >= 32)", () => {
            wCtx.append(`op = in_msg${opcodeReader}(32);`);
        });
        bouncedReceivers.binary.forEach((bouncedRcv) => {
            writeBouncedReceiver(bouncedRcv, opcodeReader === "~load_uint", contract, wCtx);
            wCtx.append();
        });
        if (typeof bouncedReceivers.fallback !== "undefined") {
            wCtx.append(";; Fallback bounce receiver");
            writeFallbackReceiver(bouncedReceivers.fallback, contract, "in_msg", wCtx);
        }
        // it's cheaper in terms of gas to just exit with code zero even if the
        // bounced message wasn't recognized, this is a common behavior of TON contracts
        wCtx.append("return ();");
    });
}
function writeFallbackReceiver(fbRcv, contract, inMsg, wCtx) {
    if (fbRcv.selector.name.kind === "id" && fbRcv.ast.statements.length != 0) {
        wCtx.append(`slice ${(0, id_1.funcIdOf)(fbRcv.selector.name)} = ${inMsg};`);
    }
    for (const stmt of fbRcv.ast.statements) {
        writeRcvStatement(stmt, fbRcv.effects, contract, wCtx);
    }
    wCtx.append(storeContractVariablesConditionally(fbRcv.effects, contract, wCtx));
    if (fbRcv.selector.kind !== "internal-fallback" &&
        fbRcv.selector.kind !== "external-fallback") {
        wCtx.append("return ();");
    }
}
function writeBouncedReceiver(bouncedReceiver, msgOpcodeRemoved, contract, wCtx) {
    const selector = bouncedReceiver.selector;
    if (selector.kind !== "bounce-binary")
        (0, errors_1.throwInternalCompilerError)(`Invalid selector type: ${selector.kind} (bounce-binary is expected)`, bouncedReceiver.ast.loc);
    wCtx.append(`;; Bounced handler for ${selector.type} message`);
    const allocation = (0, resolveDescriptors_1.getType)(wCtx.ctx, selector.type);
    wCtx.inBlock(`if (op == ${messageOpcode(allocation.header)})`, () => {
        if (!msgOpcodeRemoved) {
            wCtx.append("in_msg~skip_bits(32);");
        }
        const msgFields = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(selector.type, (0, id_1.funcIdOf)(selector.name), wCtx, false, selector.bounced);
        const msgReader = selector.bounced
            ? ops_1.ops.readerBounced(selector.type, wCtx)
            : ops_1.ops.reader(selector.type, "no-opcode", wCtx);
        wCtx.append(`var ${msgFields} = in_msg~${msgReader}();`);
        writeReceiverBody(bouncedReceiver, contract, wCtx);
    });
}
function writeReceiverBody(rcv, contract, wCtx) {
    for (const stmt of rcv.ast.statements) {
        writeRcvStatement(stmt, rcv.effects, contract, wCtx);
    }
    wCtx.append(storeContractVariablesConditionally(rcv.effects, contract, wCtx));
    wCtx.append("return ();");
}
function storeContractVariablesConditionally(rcvEffects, contract, wCtx) {
    // we persist the contract state in the following three cases:
    // - the user explicitly asks for it using tact.config.json
    // - lazy initialization is used (in that case the lazy deployment bit is set and the contract storage needs to be updated)
    // - the receiver has a side effect that writes to the contract storage
    return (0, features_1.enabledAlwaysSaveContractData)(wCtx.ctx) ||
        contract.init?.kind !== "contract-params" ||
        rcvEffects.has("contractStorageWrite")
        ? writeStoreContractVariables(contract, wCtx)
        : "";
}
function writeRcvStatement(stmt, rcvEffects, contract, wCtx) {
    // XXX: if this is the last return statement in the receiver, the user will get contract storage updated twice,
    // wasting gas, but this is a rare case and we don't want to complicate the code for this,
    // nobody should write code like this, as it is not idiomatic
    const returns = storeContractVariablesConditionally(rcvEffects, contract, wCtx);
    (0, writeFunction_1.writeStatement)(stmt, null, returns, wCtx);
}
function messageOpcode(n) {
    // FunC does not support binary and octal numerals
    switch (n.base) {
        case 10:
            return n.value.toString(n.base);
        case 2:
        case 8:
            return `0x${n.value.toString(16)}`;
        case 16:
            return `0x${n.value.toString(n.base)}`;
    }
}
function writeStoreContractVariables(contract, wCtx) {
    const contractVariables = (0, resolveFuncTypeFromAbiUnpack_1.resolveFuncTypeFromAbiUnpack)("$self", (0, resolveAllocation_1.getAllocation)(wCtx.ctx, contract.name).ops, wCtx);
    return `${ops_1.ops.contractStore(contract.name, wCtx)}(${contractVariables});`;
}
function commentPseudoOpcode(comment, includeZeroOpcode, loc) {
    const buffer = Buffer.from(comment, "utf8");
    if (buffer.length > 123) {
        (0, errors_1.throwCompilationError)(`receiver message is too long, max length is 123 bytes, but given ${buffer.length}`, loc);
    }
    const cell = includeZeroOpcode
        ? (0, core_1.beginCell)().storeUint(0, 32).storeBuffer(buffer).endCell()
        : (0, core_1.beginCell)().storeBuffer(buffer).endCell();
    return cell.hash().toString("hex", 0, 64);
}
