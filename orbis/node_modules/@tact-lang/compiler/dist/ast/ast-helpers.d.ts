import type * as Ast from "./ast";
/**
 * Check if input expression is a 'path expression',
 * i.e. an identifier or a sequence of field accesses starting from an identifier.
 * @param path A path expression to check.
 * @returns An array of identifiers or null if the input expression is not a path expression.
 */
export declare function tryExtractPath(path: Ast.Expression): Ast.Id[] | null;
type DistributiveOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
export declare const getAstFactory: () => {
    createNode: (src: DistributiveOmit<Ast.AstNode, "id">) => Ast.AstNode;
    cloneNode: <T extends Ast.AstNode>(src: T) => T;
};
export type FactoryAst = ReturnType<typeof getAstFactory>;
export declare function idText(ident: Ast.Id | Ast.FuncId | Ast.TypeId): string;
export declare function isInt(ident: Ast.TypeId): boolean;
export declare function isBool(ident: Ast.TypeId): boolean;
export declare function isCell(ident: Ast.TypeId): boolean;
export declare function isSlice(ident: Ast.TypeId): boolean;
export declare function isBuilder(ident: Ast.TypeId): boolean;
export declare function isAddress(ident: Ast.TypeId): boolean;
export declare function isString(ident: Ast.TypeId): boolean;
export declare function isStringBuilder(ident: Ast.TypeId): boolean;
export declare function isSelfId(ident: Ast.OptionalId): boolean;
export declare function isRequire(ident: Ast.Id): boolean;
export declare function eqNames(left: Ast.Id | Ast.TypeId | string, right: Ast.Id | Ast.TypeId | string): boolean;
export declare function idOfText(text: string): Ast.Id;
export declare function astNumToString(n: Ast.Number): string;
export declare function eqExpressions(ast1: Ast.Expression, ast2: Ast.Expression): boolean;
export declare function isLiteral(ast: Ast.Expression): ast is Ast.Literal;
export declare const selfId: Ast.Id;
export {};
