/**
 * AST node constructors are not just constructors: they also generate ids
 * We have this file so that the "current id" state would not be stored globally
 */
import type { Loc } from "@tonstudio/parser-runtime";
import type * as Ast from "./ast";
import type { FactoryAst } from "./ast-helpers";
import type { SrcInfo } from "../grammar/src-info";
export declare const getAstSchema: (factory: FactoryAst, toSrcInfo: (location: Loc) => SrcInfo) => {
    Module: (imports: Ast.Import[], items: Ast.ModuleItem[]) => Ast.Module;
    Import: (source: Ast.ImportPath, loc: Loc) => Ast.Import;
    PrimitiveTypeDecl: (name: Ast.Id, loc: Loc) => Ast.PrimitiveTypeDecl;
    FunctionDef: (attributes: Ast.FunctionAttribute[], name: Ast.Id, retType: Ast.Type | undefined, params: Ast.TypedParameter[], statements: Ast.Statement[], loc: Loc) => Ast.FunctionDef;
    AsmFunctionDef: (shuffle: Ast.AsmShuffle, attributes: Ast.FunctionAttribute[], name: Ast.Id, retType: Ast.Type | undefined, params: Ast.TypedParameter[], instructions: Ast.AsmInstruction[], loc: Loc) => Ast.AsmFunctionDef;
    FunctionDecl: (attributes: Ast.FunctionAttribute[], name: Ast.Id, retType: Ast.Type | undefined, params: Ast.TypedParameter[], loc: Loc) => Ast.FunctionDecl;
    NativeFunctionDecl: (attributes: Ast.FunctionAttribute[], name: Ast.Id, nativeName: Ast.FuncId, params: Ast.TypedParameter[], retType: Ast.Type | undefined, loc: Loc) => Ast.NativeFunctionDecl;
    ConstantDef: (attributes: Ast.ConstantAttribute[], name: Ast.Id, type: Ast.Type, initializer: Ast.Expression, loc: Loc) => Ast.ConstantDef;
    ConstantDecl: (attributes: Ast.ConstantAttribute[], name: Ast.Id, type: Ast.Type, loc: Loc) => Ast.ConstantDecl;
    StructDecl: (name: Ast.Id, fields: Ast.FieldDecl[], loc: Loc) => Ast.StructDecl;
    MessageDecl: (name: Ast.Id, opcode: Ast.Expression | undefined, fields: Ast.FieldDecl[], loc: Loc) => Ast.MessageDecl;
    Contract: (name: Ast.Id, traits: Ast.Id[], attributes: Ast.ContractAttribute[], params: undefined | readonly Ast.FieldDecl[], declarations: Ast.ContractDeclaration[], loc: Loc) => Ast.Contract;
    Trait: (name: Ast.Id, traits: Ast.Id[], attributes: Ast.ContractAttribute[], declarations: Ast.TraitDeclaration[], loc: Loc) => Ast.Trait;
    FieldDecl: (name: Ast.Id, type: Ast.Type, initializer: Ast.Expression | undefined, as: Ast.Id | undefined, loc: Loc) => Ast.FieldDecl;
    Receiver: (selector: Ast.ReceiverKind, statements: Ast.Statement[], loc: Loc) => Ast.Receiver;
    ReceiverSimple: (param: Ast.TypedParameter) => Ast.ReceiverSimple;
    ReceiverFallback: () => Ast.ReceiverFallback;
    ReceiverComment: (comment: Ast.String) => Ast.ReceiverComment;
    ReceiverInternal: (subKind: Ast.ReceiverSubKind, loc: Loc) => Ast.ReceiverInternal;
    ReceiverExternal: (subKind: Ast.ReceiverSubKind, loc: Loc) => Ast.ReceiverExternal;
    ReceiverBounce: (param: Ast.TypedParameter, loc: Loc) => Ast.ReceiverBounce;
    ContractInit: (params: Ast.TypedParameter[], statements: Ast.Statement[], loc: Loc) => Ast.ContractInit;
    StatementLet: (name: Ast.OptionalId, type: Ast.Type | undefined, expression: Ast.Expression, loc: Loc) => Ast.StatementLet;
    StatementDestruct: (type: Ast.TypeId, identifiers: Map<string, [Ast.Id, Ast.OptionalId]>, ignoreUnspecifiedFields: boolean, expression: Ast.Expression, loc: Loc) => Ast.StatementDestruct;
    StatementReturn: (expression: Ast.Expression | undefined, loc: Loc) => Ast.StatementReturn;
    StatementExpression: (expression: Ast.Expression, loc: Loc) => Ast.StatementExpression;
    StatementAssign: (path: Ast.Expression, expression: Ast.Expression, loc: Loc) => Ast.StatementAssign;
    StatementAugmentedAssign: (op: Ast.AugmentedAssignOperation, path: Ast.Expression, expression: Ast.Expression, loc: Loc) => Ast.StatementAugmentedAssign;
    StatementCondition: (condition: Ast.Expression, trueStatements: Ast.Statement[], falseStatements: Ast.Statement[] | undefined, loc: Loc) => Ast.StatementCondition;
    StatementWhile: (condition: Ast.Expression, statements: Ast.Statement[], loc: Loc) => Ast.StatementWhile;
    StatementUntil: (condition: Ast.Expression, statements: Ast.Statement[], loc: Loc) => Ast.StatementUntil;
    StatementRepeat: (iterations: Ast.Expression, statements: Ast.Statement[], loc: Loc) => Ast.StatementRepeat;
    StatementTry: (statements: Ast.Statement[], loc: Loc, catchBlock?: {
        catchName: Ast.OptionalId;
        catchStatements: Ast.Statement[];
    }) => Ast.StatementTry;
    StatementForEach: (keyName: Ast.OptionalId, valueName: Ast.OptionalId, map: Ast.Expression, statements: Ast.Statement[], loc: Loc) => Ast.StatementForEach;
    StatementBlock: (statements: Ast.Statement[], loc: Loc) => Ast.StatementBlock;
    TypeId: (text: string, loc: Loc) => Ast.TypeId;
    OptionalType: (typeArg: Ast.Type, loc: Loc) => Ast.OptionalType;
    MapType: (keyType: Ast.TypeId, keyStorageType: Ast.Id | undefined, valueType: Ast.TypeId, valueStorageType: Ast.Id | undefined, loc: Loc) => Ast.MapType;
    BouncedMessageType: (messageType: Ast.TypeId, loc: Loc) => Ast.BouncedMessageType;
    OpBinary: (op: Ast.BinaryOperation, left: Ast.Expression, right: Ast.Expression, loc: Loc) => Ast.OpBinary;
    OpUnary: (op: Ast.UnaryOperation, operand: Ast.Expression, loc: Loc) => Ast.OpUnary;
    FieldAccess: (aggregate: Ast.Expression, field: Ast.Id, loc: Loc) => Ast.FieldAccess;
    MethodCall: (self: Ast.Expression, method: Ast.Id, args: Ast.Expression[], loc: Loc) => Ast.MethodCall;
    StaticCall: (funcId: Ast.Id, args: Ast.Expression[], loc: Loc) => Ast.StaticCall;
    StructInstance: (type: Ast.Id, args: Ast.StructFieldInitializer[], loc: Loc) => Ast.StructInstance;
    StructFieldInitializer: (field: Ast.Id, initializer: Ast.Expression, loc: Loc) => Ast.StructFieldInitializer;
    MapLiteral: (type: Ast.MapType, fields: readonly Ast.MapField[], loc: Loc) => Ast.MapLiteral;
    SetLiteral: (valueType: Ast.TypeId, valueStorageType: Ast.Id | undefined, fields: readonly Ast.Expression[], loc: Loc) => Ast.SetLiteral;
    InitOf: (contract: Ast.Id, args: Ast.Expression[], loc: Loc) => Ast.InitOf;
    CodeOf: (contract: Ast.Id, loc: Loc) => Ast.CodeOf;
    Conditional: (condition: Ast.Expression, thenBranch: Ast.Expression, elseBranch: Ast.Expression, loc: Loc) => Ast.Conditional;
    Id: (text: string, loc: Loc) => Ast.Id;
    Wildcard: (loc: Loc) => Ast.Wildcard;
    FuncId: (text: string, loc: Loc) => Ast.FuncId;
    Null: (loc: Loc) => Ast.Null;
    String: (value: string, loc: Loc) => Ast.String;
    Boolean: (value: boolean, loc: Loc) => Ast.Boolean;
    Number: (base: Ast.NumberBase, value: bigint, loc: Loc) => Ast.Number;
    ContractAttribute: (name: Ast.String, loc: Loc) => Ast.ContractAttribute;
    FunctionAttributeGet: (methodId: Ast.Expression | undefined, loc: Loc) => Ast.FunctionAttributeGet;
    FunctionAttribute: (type: Ast.FunctionAttributeName, loc: Loc) => Ast.FunctionAttributeRest;
    ConstantAttribute: (type: Ast.ConstantAttributeName, loc: Loc) => Ast.ConstantAttribute;
    TypedParameter: (name: Ast.OptionalId, type: Ast.Type, as: Ast.Id | undefined, loc: Loc) => Ast.TypedParameter;
};
/**
 * List of all constructors for AST nodes
 */
export type AstSchema = ReturnType<typeof getAstSchema>;
