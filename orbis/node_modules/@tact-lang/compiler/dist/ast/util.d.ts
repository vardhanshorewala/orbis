import type { Address, Cell, Slice } from "@ton/core";
import type * as Ast from "./ast";
import type { FactoryAst } from "./ast-helpers";
import type { SrcInfo } from "../grammar";
export declare const getAstUtil: ({ createNode }: FactoryAst) => {
    makeUnaryExpression: (op: Ast.UnaryOperation, operand: Ast.Expression) => Ast.Expression;
    makeBinaryExpression: (op: Ast.BinaryOperation, left: Ast.Expression, right: Ast.Expression) => Ast.Expression;
    makeNumberLiteral: (n: bigint, loc: SrcInfo) => Ast.Number;
    makeBooleanLiteral: (b: boolean, loc: SrcInfo) => Ast.Boolean;
    makeNullLiteral: (loc: SrcInfo) => Ast.Null;
    makeCellLiteral: (c: Cell, loc: SrcInfo) => Ast.Cell;
    makeSliceLiteral: (s: Slice, loc: SrcInfo) => Ast.Slice;
    makeAddressLiteral: (a: Address, loc: SrcInfo) => Ast.Address;
    makeStructFieldValue: (fieldName: string, val: Ast.Literal, loc: SrcInfo) => Ast.StructFieldValue;
    makeStructValue: (fields: Ast.StructFieldValue[], type: Ast.Id, loc: SrcInfo) => Ast.StructValue;
    makeMapValue: (bocHex: string | undefined, type: Ast.MapType, loc: SrcInfo) => Ast.MapValue;
};
export type AstUtil = ReturnType<typeof getAstUtil>;
export declare function checkIsUnaryOpNode(ast: Ast.Expression): boolean;
export declare function checkIsBinaryOpNode(ast: Ast.Expression): boolean;
export declare function checkIsBinaryOp_With_RightValue(ast: Ast.Expression): boolean;
export declare function checkIsBinaryOp_With_LeftValue(ast: Ast.Expression): boolean;
export declare function checkIsNumber(ast: Ast.Expression, n: bigint): boolean;
export declare function checkIsName(ast: Ast.Expression): boolean;
export declare function checkIsBoolean(ast: Ast.Expression, b: boolean): boolean;
export declare function binaryOperationFromAugmentedAssignOperation(op: Ast.AugmentedAssignOperation): Ast.BinaryOperation;
