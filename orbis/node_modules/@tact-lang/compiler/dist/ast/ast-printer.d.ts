import type * as Ast from "./ast";
import { astNumToString, idText } from "./ast-helpers";
export declare const ppAstTypeId: typeof idText;
export declare const ppAstTypeIdWithStorage: (type: Ast.TypeId, storageType: Ast.Id | undefined) => string;
export declare const ppAstMapType: ({ keyType, keyStorageType, valueType, valueStorageType, }: Ast.MapType) => string;
export declare const ppAstBouncedMessageType: ({ messageType, }: Ast.BouncedMessageType) => string;
export declare const ppAstOptionalType: ({ typeArg }: Ast.OptionalType) => string;
export declare const ppAstType: (input: Ast.Type) => string;
export declare const unaryOperatorType: Record<Ast.UnaryOperation, "post" | "pre">;
export declare const checkPostfix: (operator: Ast.UnaryOperation) => boolean;
/**
 * Description of precedence of certain type of AST node
 */
export type Precedence = {
    /**
     * Add parentheses around `code` if in this `parent` position we need brackets
     * @param check Position-checking function from parent
     * @param code Code to put parentheses around
     * @returns
     */
    brace: (position: (childPrecedence: number) => boolean, code: string) => string;
    /**
     * Used in positions where grammar rule mentions itself
     *
     * Passed down when a position allows same unparenthesized operator
     * For example, on left side of addition we can use another addition without
     * parentheses: `1 + 2 + 3` means `(1 + 2) + 3`. Thus for left-associative
     * operators we pass `self` to their left argument printer.
     */
    self: (childPrecedence: number) => boolean;
    /**
     * Used in positions where grammar rule mentions other rule
     *
     * Passed down when a position disallows same unparenthesized operator
     * For example, on the right side of subtraction we can't use another subtraction
     * without parentheses: `1 - (2 - 3)` is not the same as `(1 - 2) - 3`. Thus for
     * left-associative operators we pass `child` to their right argument printer.
     */
    child: (childPrecedence: number) => boolean;
};
/**
 * Given numeric value of precedence, where higher values stand for higher binding power,
 * create a helper object for precedence checking
 */
export declare const makePrecedence: (myPrecedence: number) => Precedence;
export declare const lowestPrecedence: Precedence;
export declare const conditionalPrecedence: Precedence;
export declare const binaryPrecedence: Readonly<Record<Ast.BinaryOperation, Precedence>>;
export declare const prefixPrecedence: Precedence;
export declare const postfixPrecedence: Precedence;
/**
 * Expression printer takes an expression and a function from parent AST node printer that checks
 * whether expressions with given precedence should be parenthesized in parent context
 */
export type ExprPrinter<T> = (expr: T) => (check: (childPrecedence: number) => boolean) => string;
/**
 * Wrapper for AST nodes that should never be parenthesized, and thus do not require information
 * about the position they're printed in
 *
 * Takes a regular printer function and returns corresponding ExprPrinter that ignores all
 * position and precedence information
 */
export declare const ppLeaf: <T>(printer: (t: T) => string) => ExprPrinter<T>;
export declare const ppExprArgs: (args: readonly Ast.Expression[]) => string;
export declare const ppAstStructFieldInit: (param: Ast.StructFieldInitializer) => string;
export declare const ppAstStructFieldValue: (param: Ast.StructFieldValue) => string;
export declare const ppAstStructInstance: ({ type, args }: Ast.StructInstance) => string;
export declare const ppAstStructValue: ({ type, args }: Ast.StructValue) => string;
export declare const ppAstInitOf: ({ contract, args }: Ast.InitOf) => string;
export declare const ppAstCodeOf: ({ contract }: Ast.CodeOf) => string;
export declare const ppAstNumber: typeof astNumToString;
export declare const ppAstBoolean: ({ value }: Ast.Boolean) => string;
export declare const ppAstId: ({ text }: Ast.Id) => string;
export declare const ppAstOptionalId: (node: Ast.OptionalId) => string;
export declare const ppAstNull: (_expr: Ast.Null) => string;
export declare const ppAstString: ({ value }: Ast.String) => string;
export declare const ppAstAddress: ({ value }: Ast.Address) => string;
export declare const ppAstCell: ({ value }: Ast.Cell) => string;
export declare const ppAstSlice: ({ value }: Ast.Slice) => string;
export declare const ppAstMapLiteral: ({ type, fields }: Ast.MapLiteral) => string;
export declare const ppAstSetLiteral: ({ valueType, valueStorageType, fields, }: Ast.SetLiteral) => string;
export declare const ppAstMapValue: (_: Ast.MapValue) => string;
export declare const ppAstStaticCall: ({ function: func, args }: Ast.StaticCall) => string;
export declare const ppAstMethodCall: ExprPrinter<Ast.MethodCall>;
export declare const ppAstFieldAccess: ExprPrinter<Ast.FieldAccess>;
export declare const ppAstOpUnary: ExprPrinter<Ast.OpUnary>;
export declare const ppAstOpBinary: ExprPrinter<Ast.OpBinary>;
export declare const ppAstConditional: ExprPrinter<Ast.Conditional>;
export declare const ppAstExpressionNested: (input: Ast.Expression) => (check: (childPrecedence: number) => boolean) => string;
export declare const ppAstExpression: (expr: Ast.Expression) => string;
export declare const ppAstWildcard: (_expr: Ast.Wildcard) => string;
/**
 * An intermediate language that is only concerned of spacing and indentation
 */
type Context<U> = {
    /**
     * Line of code with \n implied
     */
    row: (s: string) => U;
    /**
     * Stacks lines after each other
     */
    block: (rows: readonly U[]) => U;
    /**
     * Similar to `block`, but adjacent lines of groups get concatenated
     * [a, b] + [c, d] = [a, bc, d]
     */
    concat: (rows: readonly U[]) => U;
    /**
     * Same as `indent`, but indents `rows` 1 level deeper and adds `{` and `}`
     */
    braced: (rows: readonly U[]) => U;
    /**
     * Print a list of `items` with `print`
     */
    list: <T>(items: readonly T[], print: Printer<T>) => readonly U[];
    /**
     * Display `items` with `print` in groups distinguished by return value of `getTag`
     */
    grouped: <T, V>(options: {
        items: readonly T[];
        /**
         * Items with the same tag are displayed without extra empty line between them
         *
         * Use NaN for tag whenever items should always be displayed with empty line,
         * because NaN !== NaN
         */
        getTag: (t: T) => V;
        print: Printer<T>;
    }) => readonly U[];
};
/**
 * Prints AST node of type `T` into an intermediate language of row of type `U`
 *
 * We enforce `U` to be a generic argument so that no implementation can (ab)use
 * the fact it's a string and generate some indentation without resorting to
 * methods of `Context`.
 */
type Printer<T> = (item: T) => <U>(ctx: Context<U>) => U;
export declare const ppAstModule: Printer<Ast.Module>;
export declare const ppAstStruct: Printer<Ast.StructDecl>;
export declare const ppAstContract: Printer<Ast.Contract>;
export declare const ppAstPrimitiveTypeDecl: Printer<Ast.PrimitiveTypeDecl>;
export declare const ppAstFunctionDef: Printer<Ast.FunctionDef>;
export declare const ppAsmShuffle: ({ args, ret }: Ast.AsmShuffle) => string;
export declare const ppAstAsmFunctionDef: Printer<Ast.AsmFunctionDef>;
export declare const ppAstNativeFunction: Printer<Ast.NativeFunctionDecl>;
export declare const ppAstTrait: Printer<Ast.Trait>;
export declare const ppAstConstant: Printer<Ast.ConstantDef>;
export declare const ppAstMessage: Printer<Ast.MessageDecl>;
export declare const ppModuleItem: Printer<Ast.ModuleItem>;
export declare const ppAstFieldDecl: Printer<Ast.FieldDecl>;
export declare const ppAstReceiver: Printer<Ast.Receiver>;
export declare const ppAstFunctionDecl: Printer<Ast.FunctionDecl>;
export declare const ppAstConstDecl: Printer<Ast.ConstantDecl>;
export declare const ppTraitBody: Printer<Ast.TraitDeclaration>;
export declare const ppAstInitFunction: Printer<Ast.ContractInit>;
export declare const ppContractBody: Printer<Ast.ContractDeclaration>;
export declare const ppAstImport: Printer<Ast.Import>;
export declare const ppAstFunctionSignature: ({ name, attributes, return: retTy, params, }: Ast.FunctionDef | Ast.AsmFunctionDef | Ast.FunctionDecl) => string;
export declare const ppAstFunctionAttribute: (attr: Ast.FunctionAttribute) => string;
export declare const ppReceiverSubKind: (input: Ast.ReceiverSubKind) => string;
export declare const ppAstReceiverKind: (input: Ast.ReceiverKind) => string;
export declare const ppAstFuncId: (func: Ast.FuncId) => string;
export declare const ppStatementBlock: Printer<readonly Ast.Statement[]>;
export declare const ppAsmInstructionsBlock: Printer<readonly Ast.AsmInstruction[]>;
export declare const ppAstStatementLet: Printer<Ast.StatementLet>;
export declare const ppAstStatementReturn: Printer<Ast.StatementReturn>;
export declare const ppAstStatementExpression: Printer<Ast.StatementExpression>;
export declare const ppAstStatementAssign: Printer<Ast.StatementAssign>;
export declare const ppAstStatementAugmentedAssign: Printer<Ast.StatementAugmentedAssign>;
export declare const ppAstStatementCondition: Printer<Ast.StatementCondition>;
export declare const ppAstStatementWhile: Printer<Ast.StatementWhile>;
export declare const ppAstStatementRepeat: Printer<Ast.StatementRepeat>;
export declare const ppAstStatementUntil: Printer<Ast.StatementUntil>;
export declare const ppAstStatementForEach: Printer<Ast.StatementForEach>;
export declare const ppAstStatementTry: Printer<Ast.StatementTry>;
export declare const ppAstStatementDestruct: Printer<Ast.StatementDestruct>;
export declare const ppTypedParameter: Printer<Ast.TypedParameter>;
export declare const ppAstStatementBlock: Printer<Ast.StatementBlock>;
export declare const ppAstStatement: Printer<Ast.Statement>;
export declare const exprNode: <T>(exprPrinter: (expr: T) => string) => Printer<T>;
export declare const ppAstNode: Printer<Ast.AstNode>;
/**
 * Pretty-prints an AST node into a string representation.
 * @param node The AST node to format.
 * @returns A string that represents the formatted AST node.
 */
export declare const prettyPrint: (node: Ast.AstNode) => string;
export {};
