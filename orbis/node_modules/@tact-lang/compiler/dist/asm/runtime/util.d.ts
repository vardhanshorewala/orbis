import type { Slice } from "@ton/core";
import { Cell } from "@ton/core";
import type { Instr } from "./instr-gen";
import * as c from "./constructors";
import { CodeBuilder } from "./builder";
export declare enum Hash {
    SHA256 = 0,
    SHA512 = 1,
    BLAKE2B = 2,
    KECCAK256 = 3,
    KECCAK512 = 4
}
export type Loc = {
    readonly file: string;
    readonly line: number;
};
export declare const Loc: (file: string, line: number) => {
    file: string;
    line: number;
};
export type Store<T> = (b: CodeBuilder, t: T) => void;
export type Load<T> = (s: Slice) => T;
export type Type<T> = {
    readonly store: Store<T>;
    readonly load: Load<T>;
};
export declare function uint(bits: number): Type<number>;
export declare const int: (bits: number) => Type<number>;
export type Code = Raw | Instructions;
export type Raw = {
    readonly $: "Raw";
    readonly slice: Slice;
};
export type Instructions = {
    readonly $: "Instructions";
    readonly instructions: Instr[];
};
export declare const rawCode: (slice: Slice) => Raw;
export declare const code: (instructions: Instr[]) => Instructions;
export declare const decompiledCode: (instructions: Instr[]) => Instructions;
export declare const codeSlice: (refs: Type<number>, bits: Type<number>) => Type<Code>;
export declare const refCodeSlice: Type<Code>;
export declare const inlineCodeSlice: (bits: Type<number>) => Type<Code>;
export declare const slice: (refs: Type<number> | number, bits: Type<number>, pad: number) => Type<Slice>;
export type DecompiledMethod = {
    readonly $: "DecompiledMethod";
    readonly id: number;
    readonly instructions: Instr[];
};
export declare const decompiledMethod: (id: number, instructions: Instr[]) => DecompiledMethod;
export type Dict = RawDict | DecompiledDict;
export type RawDict = {
    readonly $: "RawDict";
    readonly slice: Slice;
};
export type DecompiledDict = {
    readonly $: "DecompiledDict";
    readonly methods: DecompiledMethod[];
};
export declare const rawDict: (slice: Slice) => RawDict;
export declare const decompiledDict: (methods: DecompiledMethod[]) => DecompiledDict;
export declare const dictMap: (mapping: Map<number, Instr[]>) => DecompiledDict;
export declare const dictionary: (keyLength: number) => Type<Dict>;
export declare const dictpush: Type<[number, Dict]>;
export declare const debugstr: Type<Slice>;
export declare const refs: (count: number) => number;
export declare const control: Type<number>;
export declare const plduzArg: Type<number>;
export declare const tinyInt: Type<number>;
export declare const largeInt: Type<bigint>;
export type RunVmArg = number;
export declare const runvmArg: Type<RunVmArg>;
export declare const minusOne: Type<number>;
export declare const s1: Type<number>;
export declare const setcpArg: Type<number>;
export declare const delta: (n: number, ty: Type<number>) => Type<number>;
export declare const hash: Type<Hash>;
export declare const PSEUDO_PUSHSLICE: Type<c.PSEUDO_PUSHSLICE>;
export declare const PSEUDO_PUSHREF: Type<c.PSEUDO_PUSHREF>;
export declare const PSEUDO_EXOTIC: Type<c.PSEUDO_EXOTIC>;
export declare const hex: (value: string) => Slice;
export declare const bin: (value: string) => Slice;
export declare const boc: (value: string) => Slice;
export declare const exoticCellBody: (value: string) => Cell;
export type ExoticCell = DefaultExoticCell | LibraryCell;
export type DefaultExoticCell = {
    readonly $: "DefaultExoticCell";
    readonly cell: Cell;
};
export declare const DefaultExoticCell: (cell: Cell) => DefaultExoticCell;
export type LibraryCell = {
    readonly $: "LibraryCell";
    readonly data: Slice;
};
export declare const LibraryCell: (data: Slice) => LibraryCell;
export declare const exotic: Type<ExoticCell>;
