/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { Address } from "@ton/core";
import { Slice, Cell } from "@ton/core";
import { BitString } from "@ton/core";
import { Maybe } from "@ton/core/src/utils/maybe";
import { CodeBuilder } from "../runtime/builder";
export type DictionaryKeyTypes = Address | number | bigint | Buffer | BitString;
export type DictionaryKey<K extends DictionaryKeyTypes> = {
    bits: number;
    serialize(src: K): bigint;
    parse(src: bigint): K;
};
export type DictionaryValue<V> = {
    serialize(src: V, builder: CodeBuilder): void;
    parse(src: Slice): V;
};
export declare class Dictionary<K extends DictionaryKeyTypes, V> {
    static Keys: {
        /**
         * Create integer key
         * @param bits bits of integer
         * @returns DictionaryKey<number>
         */
        Int: (bits: number) => DictionaryKey<number>;
    };
    /**
     * Create an empty map
     * @param key key type
     * @param value value type
     * @returns Dictionary<K, V>
     */
    static empty<K extends DictionaryKeyTypes, V>(key?: Maybe<DictionaryKey<K>>, value?: Maybe<DictionaryValue<V>>): Dictionary<K, V>;
    private readonly _key;
    private readonly _value;
    private readonly _map;
    private constructor();
    set(key: K, value: V): this;
    [Symbol.iterator](): IterableIterator<[K, V]>;
    /**
     * Low level method for rare dictionaries from system contracts.
     * Loads dictionary from slice directly without going to the ref.
     *
     * @param key key description
     * @param value value description
     * @param sc slice
     * @returns Dictionary<K, V>
     */
    static loadDirect<K extends DictionaryKeyTypes, V>(key: DictionaryKey<K>, value: DictionaryValue<V>, sc: Slice | Cell | null): Dictionary<K, V>;
    storeDirect(builder: CodeBuilder): void;
}
