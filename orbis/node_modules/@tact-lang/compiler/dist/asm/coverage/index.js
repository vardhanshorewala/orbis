"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recompileCell = void 0;
exports.collectAsmCoverage = collectAsmCoverage;
exports.collectFuncCoverage = collectFuncCoverage;
const runtime_1 = require("../runtime");
const text_1 = require("../text");
const trace_1 = require("../trace");
const data_1 = require("./data");
const node_fs_1 = require("node:fs");
function collectAsmCoverage(cell, logs) {
    const [cleanCell, mapping] = (0, exports.recompileCell)(cell, false);
    const info = (0, trace_1.createMappingInfo)(mapping);
    const traceInfos = (0, trace_1.createTraceInfoPerTransaction)(logs, info, undefined);
    const assembly = (0, text_1.print)((0, runtime_1.decompileCell)(cleanCell));
    const combinedTrace = { steps: traceInfos.flatMap((trace) => trace.steps) };
    const combinedLines = (0, data_1.buildLineInfo)(combinedTrace, assembly);
    const combinedSummary = (0, data_1.generateCoverageSummary)(combinedLines);
    return { lines: combinedLines, summary: combinedSummary };
}
function collectFuncCoverage(cell, logs, funcSources, funcMappingPath) {
    const [_, mapping] = (0, exports.recompileCell)(cell, true);
    const info = (0, trace_1.createMappingInfo)(mapping);
    const funcMapping = (0, trace_1.loadFuncMapping)((0, node_fs_1.readFileSync)(funcMappingPath, "utf8"));
    const traceInfos = (0, trace_1.createTraceInfoPerTransaction)(logs, info, funcMapping);
    const func = (0, node_fs_1.readFileSync)(funcSources, "utf8");
    const combinedLines = (0, data_1.buildFuncLineInfo)(traceInfos, func);
    const combinedSummary = (0, data_1.generateCoverageSummary)(combinedLines);
    return { lines: combinedLines, summary: combinedSummary };
}
const recompileCell = (cell, forFunC) => {
    const instructionsWithoutPositions = (0, runtime_1.decompileCell)(cell);
    const assemblyForPositionsRaw = (0, text_1.print)(instructionsWithoutPositions);
    // filter out all DEBUGMARK lines from the assembly
    const assemblyForPositions = forFunC
        ? assemblyForPositionsRaw
        : assemblyForPositionsRaw
            .split("\n")
            .filter((it) => !it.includes("DEBUGMARK"))
            .join("\n");
    const parseResult = (0, text_1.parse)("out.tasm", assemblyForPositions);
    if (parseResult.$ === "ParseFailure") {
        throw new Error("Cannot parse resulting text Assembly");
    }
    return (0, runtime_1.compileCellWithMapping)(parseResult.instructions);
};
exports.recompileCell = recompileCell;
__exportStar(require("./html"), exports);
__exportStar(require("./text"), exports);
__exportStar(require("./integrations"), exports);
__exportStar(require("./data"), exports);
