import type * as $ from "@tonstudio/parser-runtime";
import type { Code, Dict, Loc } from "../runtime/util";
import type { $ast } from "./grammar";
import * as i from "../runtime";
import type { Slice } from "@ton/core";
export type Ctx = {
    readonly lines: readonly string[];
    readonly filepath: string;
};
export type Convert = (ctx: Ctx, instr: $ast.Instruction, loc: Loc) => i.Instr;
export declare class ParseError extends Error {
    loc: Loc;
    msg: string;
    constructor(loc: Loc, msg: string);
    toString(): string;
}
export declare const createLoc: (ctx: Ctx, loc: $.Loc) => Loc;
export declare const processInstructions: (ctx: Ctx, instructions: $ast.instructions) => i.Instr[];
export declare const singleIntegerArg: (instr: $ast.Instruction) => number;
export declare const singleStackArg: (instr: $ast.Instruction) => number;
export declare const singleControlArg: (instr: $ast.Instruction) => number;
export declare const singleBigIntArg: (instr: $ast.Instruction) => bigint;
export declare const twoIntegerArgs: (instr: $ast.Instruction) => [number, number];
export declare const twoStackArgs: (instr: $ast.Instruction) => [number, number];
export declare const threeIntegerArgs: (instr: $ast.Instruction) => [number, number, number];
export declare const threeStackArgs: (instr: $ast.Instruction) => [number, number, number];
export declare const codeSliceArg: (ctx: Ctx, instr: $ast.Instruction) => Code;
export declare const twoCodeSliceArgs: (ctx: Ctx, instr: $ast.Instruction) => [Code, Code];
export declare const ifElseBitArgs: (ctx: Ctx, instr: $ast.Instruction) => [number, Code, Code];
export declare const ifBitArgs: (ctx: Ctx, instr: $ast.Instruction) => [number, Code];
export declare const sliceArg: (instr: $ast.Instruction) => Slice;
export declare const debugstrArg: (instr: $ast.Instruction) => Slice;
export declare const dictpushArg: (ctx: Ctx, instr: $ast.Instruction) => [number, Dict];
