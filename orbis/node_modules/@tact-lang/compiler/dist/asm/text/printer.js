"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.print = exports.printInstructions = exports.printInstr = exports.Printer = void 0;
exports.printDictionary = printDictionary;
exports.printCode = printCode;
exports.printSlice = printSlice;
const printer_gen_1 = require("./printer-gen");
class Printer {
    indent;
    result;
    constructor(indent) {
        this.indent = indent;
        this.result = "";
    }
    beginLine(text) {
        const indentText = "    ".repeat(this.indent);
        this.result += indentText + text;
    }
    append(text) {
        this.result += text;
    }
    inIndent(action) {
        this.indent++;
        action(this);
        this.indent--;
    }
    build() {
        return this.result;
    }
}
exports.Printer = Printer;
const printInstr = (p, instr) => {
    if (instr.$ === "PSEUDO_PUSHREF") {
        p.beginLine("ref ");
        printCode(p, instr.arg0);
        return;
    }
    if (instr.$ === "PSEUDO_PUSHSLICE") {
        p.beginLine("embed ");
        printSlice(p, instr.arg0);
        return;
    }
    if (instr.$ === "PSEUDO_EXOTIC") {
        p.beginLine("exotic ");
        if (instr.arg0.$ === "LibraryCell") {
            p.append("library ");
            printSlice(p, instr.arg0.data);
            return;
        }
        printSlice(p, instr.arg0.cell.beginParse(true));
        return;
    }
    (0, printer_gen_1.printInstruction)(p, instr);
};
exports.printInstr = printInstr;
const printInstructions = (p, instructions) => {
    if (instructions.length === 0) {
        p.append("{}");
        return;
    }
    p.append("{\n");
    p.inIndent((p) => {
        for (const instr of instructions) {
            (0, exports.printInstr)(p, instr);
            p.append("\n");
        }
    });
    p.beginLine("}");
};
exports.printInstructions = printInstructions;
const print = (instructions) => {
    const p = new Printer(0);
    for (const instr of instructions) {
        (0, exports.printInstr)(p, instr);
        p.append("\n");
    }
    return p.build();
};
exports.print = print;
function printDictionary(p, dict) {
    if (dict.$ === "RawDict") {
        printSlice(p, dict.slice);
    }
    if (dict.$ === "DecompiledDict") {
        p.append(`[\n`);
        for (const method of dict.methods) {
            p.inIndent((p) => {
                p.beginLine(`${method.id} => `);
                (0, exports.printInstructions)(p, method.instructions);
                p.append(`\n`);
            });
        }
        p.beginLine("]");
    }
}
function printCode(p, arg0) {
    if (arg0.$ === "Instructions") {
        (0, exports.printInstructions)(p, arg0.instructions);
    }
    if (arg0.$ === "Raw") {
        const value = arg0.slice.asCell().toString().slice(2, -1);
        if (value.includes("\n")) {
            // cell with refs
            p.append(`boc{${arg0.slice.asCell().toBoc().toString("hex")}}`);
        }
        else {
            p.append(`x{${value}}`);
        }
    }
}
function printSlice(p, slice) {
    const value = slice.asCell().toString().slice(2, -1);
    if (value.includes("\n")) {
        // cell with refs
        p.append(`boc{${slice.asCell().toBoc().toString("hex")}}`);
    }
    else {
        p.append(`x{${value}}`);
    }
}
