"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCode = formatCode;
const formatter_1 = require("./formatter/formatter");
const cst_helpers_1 = require("./cst/cst-helpers");
const grammar_1 = require("../grammar");
const ast_helpers_1 = require("../ast/ast-helpers");
const errors_1 = require("../error/errors");
function formatCode(path, code) {
    const root = (0, cst_helpers_1.parseCode)(code);
    if (!root) {
        return getCannotParseCodeError(code, path);
    }
    const formatted = (0, formatter_1.format)(root);
    return checkFormatting(root, code, formatted);
}
function getCannotParseCodeError(code, path) {
    const parser = (0, grammar_1.getParser)((0, ast_helpers_1.getAstFactory)());
    try {
        parser.parse({
            code,
            origin: "user",
            path: path,
        });
    }
    catch (e) {
        if (e instanceof errors_1.TactCompilationError) {
            return {
                $: "FormatCodeError",
                message: e.message,
            };
        }
    }
    return {
        $: "FormatCodeError",
        message: "cannot parse code",
    };
}
function checkFormatting(root, before, after) {
    if (before === after) {
        return {
            $: "FormattedCode",
            code: before,
        };
    }
    const rootAfter = (0, cst_helpers_1.parseCode)(after);
    if (!rootAfter) {
        return {
            $: "FormatCodeError",
            message: "cannot parse code after formatting",
        };
    }
    const commentsBefore = new Set(collectComments(root));
    const commentsAfter = new Set(collectComments(rootAfter));
    if (!areSetsEqual(commentsBefore, commentsAfter)) {
        const missedComments = [
            ...missingElements(commentsBefore, commentsAfter),
        ];
        return {
            $: "FormatCodeError",
            message: `missed comments after formatting: ${missedComments.toString()}`,
        };
    }
    return {
        $: "FormattedCode",
        code: after,
    };
}
const collectComments = (node) => {
    if (node.$ === "leaf")
        return [];
    if (node.type === "Comment")
        return [(0, cst_helpers_1.visit)(node).trim()];
    return node.children.flatMap((it) => collectComments(it));
};
function areSetsEqual(setA, setB) {
    if (setA.size !== setB.size)
        return false;
    for (const item of setA) {
        if (!setB.has(item))
            return false;
    }
    return true;
}
function missingElements(setA, setB) {
    return new Set([...setA].filter((item) => !setB.has(item)));
}
