"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeArgs = exports.TypeId = exports.Bounced = exports.MapKeyword = exports.TypeGeneric = exports.TypeRegular = exports.typePrimary = exports.TypeOptional = exports.TypeAs = exports.$type = exports.ascription = exports.assemblyItem = exports.assemblySequence = exports.assembly = exports.receiverParam = exports.ReceiverType = exports.Receiver = exports.GetAttribute = exports.FunctionAttribute = exports.ContractAttribute = exports.ContractInit = exports.inheritedTraits = exports.Trait = exports.Contract = exports.FieldDecl = exports.structFields = exports.MessageDecl = exports.StructDecl = exports.storageVar = exports.ConstantDeclaration = exports.ConstantDefinition = exports.ConstantAttribute = exports.Constant = exports.NativeFunctionDecl = exports.shuffle = exports.AsmFunction = exports.FunctionDeclaration = exports.FunctionDefinition = exports.$Function = exports.PrimitiveTypeDecl = exports.traitItemDecl = exports.contractItemDecl = exports.moduleItem = exports.Import = exports.Module = exports.skip = exports.consumeAny = exports.CstNode = exports.CstLeaf = exports.createContext = void 0;
exports.StructInstanceFields = exports.StructInstance = exports.Parens = exports.parens = exports.Null = exports.primary = exports.SuffixFieldAccess = exports.SuffixCall = exports.SuffixUnboxNotNull = exports.suffix = exports.Operator = exports.Binary = exports.Suffix = exports.Unary = exports.mul = exports.add = exports.bitwiseShift = exports.compare = exports.equality = exports.bitwiseAnd = exports.bitwiseXor = exports.bitwiseOr = exports.and = exports.or = exports.Conditional = exports.expression = exports.NoRestArgument = exports.RestArgument = exports.optionalRest = exports.PunnedField = exports.RegularField = exports.destructItem = exports.semicolon = exports.FalseBranch = exports.augmentedOp = exports.StatementForEach = exports.StatementTry = exports.StatementUntil = exports.StatementRepeat = exports.StatementWhile = exports.StatementCondition = exports.StatementAssign = exports.StatementExpression = exports.StatementReturn = exports.StatementBlock = exports.StatementDestruct = exports.StatementLet = exports.statements = exports.statement = exports.generic = void 0;
exports.MessageDecl_seq_18 = exports.ConstantAttribute_alt_17 = exports.Constant_alt_16 = exports.Constant_star_15 = exports.NativeFunctionDecl_optional_14 = exports.NativeFunctionDecl_star_13 = exports.NativeFunctionDecl_lex_12 = exports.shuffle_optional_11 = exports.shuffle_seq_10 = exports.shuffle_plus_9 = exports.shuffle_star_8 = exports.AsmFunction_optional_7 = exports.AsmFunction_star_6 = exports.AsmFunction_optional_5 = exports.$Function_alt_4 = exports.$Function_optional_3 = exports.$Function_star_2 = exports.Module_star_1 = exports.Module_star_0 = exports.inter = exports.JustImports = exports.singleLineComment = exports.multiLineComment = exports.Comment = exports.space = exports.reservedWord = exports.keyword = exports.hexDigit = exports.escapeChar = exports.StringLiteral = exports.BoolLiteral = exports.FuncId = exports.Id = exports.idPart = exports.digit = exports.underscored = exports.IntegerLiteralOct = exports.IntegerLiteralBin = exports.IntegerLiteralHex = exports.IntegerLiteralDec = exports.IntegerLiteral = exports.commaList = exports.Parameter = exports.ParameterList = exports.StructFieldInitializer = exports.CodeOf = exports.InitOf = exports.SetLiteral = exports.mapField = exports.MapLiteral = void 0;
exports.compare_alt_68 = exports.equality_alt_67 = exports.Conditional_optional_66 = exports.Conditional_seq_65 = exports.optionalRest_seq_64 = exports.semicolon_lookpos_63 = exports.StatementTry_optional_62 = exports.StatementTry_seq_61 = exports.StatementCondition_optional_60 = exports.StatementCondition_seq_59 = exports.StatementCondition_alt_58 = exports.StatementAssign_alt_57 = exports.StatementReturn_optional_56 = exports.StatementLet_optional_55 = exports.statements_star_54 = exports.generic_optional_53 = exports.TypeId_lex_52 = exports.TypeId_stringify_51 = exports.TypeId_seq_50 = exports.TypeId_star_49 = exports.TypeGeneric_alt_48 = exports.TypeOptional_star_47 = exports.TypeAs_star_46 = exports.TypeAs_seq_45 = exports.assemblyItem_plus_44 = exports.assemblyItem_seq_43 = exports.assemblyItem_lookneg_42 = exports.assemblyItem_alt_41 = exports.assemblyItem_seq_40 = exports.assemblyItem_star_39 = exports.assemblyItem_seq_38 = exports.assembly_stringify_37 = exports.receiverParam_optional_36 = exports.receiverParam_alt_35 = exports.ReceiverType_alt_34 = exports.GetAttribute_optional_33 = exports.GetAttribute_seq_32 = exports.FunctionAttribute_alt_31 = exports.Trait_star_30 = exports.Trait_optional_29 = exports.Trait_star_28 = exports.Contract_star_27 = exports.Contract_optional_26 = exports.Contract_optional_25 = exports.Contract_star_24 = exports.FieldDecl_optional_23 = exports.FieldDecl_seq_22 = exports.structFields_optional_21 = exports.structFields_optional_20 = exports.MessageDecl_optional_19 = void 0;
exports.escapeChar_seq_118 = exports.escapeChar_stringify_117 = exports.escapeChar_seq_116 = exports.escapeChar_optional_115 = exports.escapeChar_optional_114 = exports.escapeChar_optional_113 = exports.escapeChar_optional_112 = exports.escapeChar_optional_111 = exports.StringLiteral_lex_110 = exports.StringLiteral_seq_109 = exports.StringLiteral_stringify_108 = exports.StringLiteral_star_107 = exports.StringLiteral_alt_106 = exports.StringLiteral_seq_105 = exports.BoolLiteral_lookneg_104 = exports.BoolLiteral_alt_103 = exports.FuncId_stringify_102 = exports.FuncId_alt_101 = exports.FuncId_plus_100 = exports.FuncId_seq_99 = exports.FuncId_plus_98 = exports.FuncId_optional_97 = exports.Id_lex_96 = exports.Id_stringify_95 = exports.Id_seq_94 = exports.Id_star_93 = exports.Id_lookneg_92 = exports.underscored_seq_91 = exports.underscored_star_90 = exports.underscored_seq_89 = exports.underscored_optional_88 = exports.IntegerLiteralOct_lex_87 = exports.IntegerLiteralOct_seq_86 = exports.IntegerLiteralBin_lex_85 = exports.IntegerLiteralBin_seq_84 = exports.IntegerLiteralHex_lex_83 = exports.IntegerLiteralHex_seq_82 = exports.IntegerLiteralDec_lex_81 = exports.IntegerLiteral_alt_80 = exports.commaList_optional_79 = exports.ParameterList_optional_78 = exports.StructFieldInitializer_optional_77 = exports.StructFieldInitializer_seq_76 = exports.SetLiteral_optional_75 = exports.MapLiteral_optional_74 = exports.StructInstanceFields_optional_73 = exports.Suffix_star_72 = exports.Unary_star_71 = exports.add_alt_70 = exports.bitwiseShift_alt_69 = void 0;
exports.inter_star_141 = exports.inter_seq_140 = exports.JustImports_star_139 = exports.JustImports_star_138 = exports.singleLineComment_stringify_137 = exports.singleLineComment_star_136 = exports.multiLineComment_stringify_135 = exports.multiLineComment_star_134 = exports.multiLineComment_seq_133 = exports.multiLineComment_lookneg_132 = exports.space_alt_131 = exports.space_lex_130 = exports.space_stringify_129 = exports.space_plus_128 = exports.reservedWord_alt_127 = exports.keyword_seq_126 = exports.keyword_lookneg_125 = exports.escapeChar_seq_124 = exports.escapeChar_stringify_123 = exports.escapeChar_seq_122 = exports.escapeChar_seq_121 = exports.escapeChar_stringify_120 = exports.escapeChar_seq_119 = void 0;
/* Generated. Do not edit. */
// @ts-nocheck
let nextId = 0;
const createContext = (s, space) => ({
    s,
    p: 0,
    l: s.length,
    space,
});
exports.createContext = createContext;
const CstLeaf = (text) => ({
    $: "leaf",
    id: nextId++,
    text,
});
exports.CstLeaf = CstLeaf;
const CstNode = (children, type = "unknown", field = "", group = "") => {
    if (children.length === 1 &&
        children[0]?.$ === "node" &&
        children[0].type === "") {
        return (0, exports.CstNode)(children[0].children, type, field, group);
    }
    const process = (ch) => {
        if (ch.$ === "node" && ch.type === "") {
            return ch.children.flatMap((ch) => process(ch));
        }
        return [ch];
    };
    const processedChildren = children.flatMap((ch) => process(ch));
    return {
        $: "node",
        id: nextId++,
        type,
        group,
        field,
        children: processedChildren,
    };
};
exports.CstNode = CstNode;
const pushGroupTo = (b, source, group) => {
    if (source.length === 0)
        return;
    b.push(...source.map((it) => {
        if (it.$ === "leaf")
            return it;
        return {
            ...it,
            group,
        };
    }));
};
const peek = (ctx) => {
    if (ctx.p === ctx.l)
        return undefined;
    return ctx.s[ctx.p];
};
const consumeClass = (ctx, b, cond) => {
    if (ctx.p === ctx.l)
        return false;
    const c = ctx.s[ctx.p] ?? "";
    if (!cond(c))
        return false;
    ctx.p++;
    const b2 = [];
    b2.push((0, exports.CstLeaf)(c));
    (0, exports.skip)(ctx, b2);
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, ""));
    }
    return true;
};
const consumeString = (ctx, b, token) => {
    if (ctx.s.substring(ctx.p, ctx.p + token.length) !== token)
        return false;
    ctx.p += token.length;
    const b2 = [];
    b2.push((0, exports.CstLeaf)(token));
    (0, exports.skip)(ctx, b2);
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, ""));
    }
    return true;
};
const consumeAny = (ctx, b) => {
    if (ctx.p === ctx.l) {
        b.push((0, exports.CstLeaf)(""));
        return false;
    }
    const c = ctx.s[ctx.p] ?? "";
    b.push((0, exports.CstLeaf)(c));
    ctx.p++;
    return true;
};
exports.consumeAny = consumeAny;
const skip = (ctx, b) => {
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    ctx.space?.(newCtx, b);
    ctx.p = newCtx.p;
};
exports.skip = skip;
const stringify = (ctx, b, rule) => {
    const p = ctx.p;
    const r = rule(ctx, b);
    ctx.p = p;
    return r;
};
const lex = (ctx, b, rule) => {
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    return rule(newCtx, b);
};
const Module = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Module_star_0)(ctx, b2, "imports");
    r = r && (0, exports.Module_star_1)(ctx, b2, "items");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Module", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Module = Module;
const Import = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "import"))(ctx, b2);
    r = r && (0, exports.StringLiteral)(ctx, b2, "path");
    r = r && consumeString(ctx, b2, ";");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Import", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Import = Import;
const moduleItem = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.PrimitiveTypeDecl)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.$Function)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.AsmFunction)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.NativeFunctionDecl)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Constant)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StructDecl)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.MessageDecl)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Contract)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Trait)(ctx, b2));
    pushGroupTo(b, b2, "moduleItem");
    return r;
};
exports.moduleItem = moduleItem;
const contractItemDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ContractInit)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.Receiver)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.$Function)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.AsmFunction)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Constant)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.storageVar)(ctx, b2));
    pushGroupTo(b, b2, "contractItemDecl");
    return r;
};
exports.contractItemDecl = contractItemDecl;
const traitItemDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Receiver)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.$Function)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.AsmFunction)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Constant)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.storageVar)(ctx, b2));
    pushGroupTo(b, b2, "traitItemDecl");
    return r;
};
exports.traitItemDecl = traitItemDecl;
const PrimitiveTypeDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "primitive"))(ctx, b2);
    r = r && (0, exports.TypeId)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, ";");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "PrimitiveTypeDecl", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.PrimitiveTypeDecl = PrimitiveTypeDecl;
const $Function = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.$Function_star_2)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "fun"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ParameterList)(exports.Parameter)(ctx, b2, "parameters");
    r = r && (0, exports.$Function_optional_3)(ctx, b2, "returnType");
    r = r && (0, exports.$Function_alt_4)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "$Function", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.$Function = $Function;
const FunctionDefinition = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FunctionDefinition", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FunctionDefinition = FunctionDefinition;
const FunctionDeclaration = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FunctionDeclaration", field ?? ""));
    }
    return r;
};
exports.FunctionDeclaration = FunctionDeclaration;
const AsmFunction = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "asm");
    r = r && (0, exports.AsmFunction_optional_5)(ctx, b2, "shuffle");
    r = r && (0, exports.AsmFunction_star_6)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "fun"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ParameterList)(exports.Parameter)(ctx, b2, "parameters");
    r = r && (0, exports.AsmFunction_optional_7)(ctx, b2, "returnType");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.assembly)(ctx, b2, "instructions");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "AsmFunction", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.AsmFunction = AsmFunction;
const shuffle = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "(");
    r = r && (0, exports.shuffle_star_8)(ctx, b2, "ids");
    r = r && (0, exports.shuffle_optional_11)(ctx, b2, "to");
    r = r && consumeString(ctx, b2, ")");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.shuffle = shuffle;
const NativeFunctionDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "@name");
    r = r && consumeString(ctx, b2, "(");
    r = r && (0, exports.NativeFunctionDecl_lex_12)(ctx, b2, "nativeName");
    r = r && consumeString(ctx, b2, ")");
    r = r && (0, exports.NativeFunctionDecl_star_13)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "native"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ParameterList)(exports.Parameter)(ctx, b2, "parameters");
    r = r && (0, exports.NativeFunctionDecl_optional_14)(ctx, b2, "returnType");
    r = r && consumeString(ctx, b2, ";");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "NativeFunctionDecl", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.NativeFunctionDecl = NativeFunctionDecl;
const Constant = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Constant_star_15)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "const"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ascription)(ctx, b2, "type");
    r = r && (0, exports.Constant_alt_16)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Constant", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Constant = Constant;
const ConstantAttribute = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ConstantAttribute_alt_17)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ConstantAttribute", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ConstantAttribute = ConstantAttribute;
const ConstantDefinition = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "=");
    r = r && (0, exports.expression)(ctx, b2, "expression");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ConstantDefinition", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ConstantDefinition = ConstantDefinition;
const ConstantDeclaration = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ConstantDeclaration", field ?? ""));
    }
    return r;
};
exports.ConstantDeclaration = ConstantDeclaration;
const storageVar = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FieldDecl)(ctx, b2);
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.storageVar = storageVar;
const StructDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "struct");
    r = r && (0, exports.TypeId)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.structFields)(ctx, b2, "fields");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StructDecl", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StructDecl = StructDecl;
const MessageDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "message");
    r = r && (0, exports.MessageDecl_optional_19)(ctx, b2, "opcode");
    r = r && (0, exports.TypeId)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.structFields)(ctx, b2, "fields");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "MessageDecl", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.MessageDecl = MessageDecl;
const structFields = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.structFields_optional_20)(ctx, b2);
    r = r && (0, exports.structFields_optional_21)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.structFields = structFields;
const FieldDecl = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ascription)(ctx, b2, "type");
    r = r && (0, exports.FieldDecl_optional_23)(ctx, b2, "expression");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FieldDecl", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FieldDecl = FieldDecl;
const Contract = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Contract_star_24)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "contract"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.Contract_optional_25)(ctx, b2, "parameters");
    r = r && (0, exports.Contract_optional_26)(ctx, b2, "traits");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.Contract_star_27)(ctx, b2, "declarations");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Contract", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Contract = Contract;
const Trait = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Trait_star_28)(ctx, b2, "attributes");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "trait"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.Trait_optional_29)(ctx, b2, "traits");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.Trait_star_30)(ctx, b2, "declarations");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Trait", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Trait = Trait;
const inheritedTraits = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "with"))(ctx, b2);
    r = r && (0, exports.commaList)(exports.Id)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.inheritedTraits = inheritedTraits;
const ContractInit = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "init");
    r = r && (0, exports.ParameterList)(exports.Parameter)(ctx, b2, "parameters");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ContractInit", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ContractInit = ContractInit;
const ContractAttribute = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "@interface");
    r = r && consumeString(ctx, b2, "(");
    r = r && (0, exports.StringLiteral)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, ")");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ContractAttribute", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ContractAttribute = ContractAttribute;
const FunctionAttribute = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FunctionAttribute_alt_31)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FunctionAttribute", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FunctionAttribute = FunctionAttribute;
const GetAttribute = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "get");
    r = r && (0, exports.GetAttribute_optional_33)(ctx, b2, "methodId");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "GetAttribute", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.GetAttribute = GetAttribute;
const Receiver = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ReceiverType)(ctx, b2, "type");
    r = r && consumeString(ctx, b2, "(");
    r = r && (0, exports.receiverParam)(ctx, b2, "param");
    r = r && consumeString(ctx, b2, ")");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Receiver", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Receiver = Receiver;
const ReceiverType = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ReceiverType_alt_34)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "ReceiverType", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ReceiverType = ReceiverType;
const receiverParam = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.receiverParam_optional_36)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.receiverParam = receiverParam;
const assembly = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.assembly_stringify_37)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.assembly = assembly;
const assemblySequence = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.assemblyItem)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.assemblySequence = assemblySequence;
const assemblyItem = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.assemblyItem_seq_38)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.Comment)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.assemblyItem_seq_40)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.assemblyItem_plus_44)(ctx, b2));
    pushGroupTo(b, b2, "assemblyItem");
    return r;
};
exports.assemblyItem = assemblyItem;
const ascription = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ":");
    r = r && (0, exports.$type)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.ascription = ascription;
const $type = (ctx, b, field) => {
    return (0, exports.TypeAs)(ctx, b, field);
};
exports.$type = $type;
const TypeAs = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeOptional)(ctx, b2, "type");
    r = r && (0, exports.TypeAs_star_46)(ctx, b2, "as");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "TypeAs", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeAs = TypeAs;
const TypeOptional = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.typePrimary)(ctx, b2, "type");
    r = r && (0, exports.TypeOptional_star_47)(ctx, b2, "optionals");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "TypeOptional", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeOptional = TypeOptional;
const typePrimary = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeGeneric)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.TypeRegular)(ctx, b2));
    pushGroupTo(b, b2, "typePrimary");
    return r;
};
exports.typePrimary = typePrimary;
const TypeRegular = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeId)(ctx, b2, "child");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "TypeRegular", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeRegular = TypeRegular;
const TypeGeneric = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeGeneric_alt_48)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, "<");
    r = r && (0, exports.commaList)(exports.$type)(ctx, b2, "args");
    r = r && consumeString(ctx, b2, ">");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "TypeGeneric", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeGeneric = TypeGeneric;
const MapKeyword = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "map"))(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "MapKeyword", field ?? ""));
    }
    return r;
};
exports.MapKeyword = MapKeyword;
const Bounced = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "bounced");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Bounced", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Bounced = Bounced;
const TypeId = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeId_lex_52)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "TypeId", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeId = TypeId;
const typeArgs = (ctx, b, field) => {
    return (0, exports.generic)(exports.$type)(ctx, b, field);
};
exports.typeArgs = typeArgs;
const generic = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = consumeString(ctx, b2, "<");
        r = r && (0, exports.generic_optional_53)(T)(ctx, b2);
        r = r && consumeString(ctx, b2, ">");
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.generic = generic;
const statement = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.StatementLet)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.StatementDestruct)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementBlock)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementReturn)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementCondition)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementWhile)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementRepeat)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementUntil)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementTry)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementForEach)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementExpression)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StatementAssign)(ctx, b2));
    pushGroupTo(b, b2, "statement");
    return r;
};
exports.statement = statement;
const statements = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "{");
    r = r && (0, exports.statements_star_54)(ctx, b2);
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.statements = statements;
const StatementLet = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "let"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.StatementLet_optional_55)(ctx, b2, "type");
    r = r && consumeString(ctx, b2, "=");
    r = r && (0, exports.expression)(ctx, b2, "init");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementLet", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementLet = StatementLet;
const StatementDestruct = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "let"))(ctx, b2);
    r = r && (0, exports.TypeId)(ctx, b2, "type");
    r = r && consumeString(ctx, b2, "{");
    r =
        r &&
            (0, exports.inter)(exports.destructItem, (ctx, b) => consumeString(ctx, b, ","))(ctx, b2, "fields");
    r = r && (0, exports.optionalRest)(ctx, b2, "rest");
    r = r && consumeString(ctx, b2, "}");
    r = r && consumeString(ctx, b2, "=");
    r = r && (0, exports.expression)(ctx, b2, "init");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementDestruct", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementDestruct = StatementDestruct;
const StatementBlock = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementBlock", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementBlock = StatementBlock;
const StatementReturn = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "return"))(ctx, b2);
    r = r && (0, exports.StatementReturn_optional_56)(ctx, b2, "expression");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementReturn", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementReturn = StatementReturn;
const StatementExpression = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.expression)(ctx, b2, "expression");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementExpression", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementExpression = StatementExpression;
const StatementAssign = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.expression)(ctx, b2, "left");
    r = r && (0, exports.StatementAssign_alt_57)(ctx, b2, "operator");
    r = r && (0, exports.expression)(ctx, b2, "right");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementAssign", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementAssign = StatementAssign;
const StatementCondition = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "if"))(ctx, b2);
    r = r && (0, exports.expression)(ctx, b2, "condition");
    r = r && (0, exports.statements)(ctx, b2, "trueBranch");
    r = r && (0, exports.StatementCondition_optional_60)(ctx, b2, "falseBranch");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementCondition", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementCondition = StatementCondition;
const StatementWhile = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "while"))(ctx, b2);
    r = r && (0, exports.parens)(ctx, b2, "condition");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementWhile", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementWhile = StatementWhile;
const StatementRepeat = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "repeat"))(ctx, b2);
    r = r && (0, exports.parens)(ctx, b2, "condition");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementRepeat", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementRepeat = StatementRepeat;
const StatementUntil = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "do"))(ctx, b2);
    r = r && (0, exports.statements)(ctx, b2, "body");
    r = r && (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "until"))(ctx, b2);
    r = r && (0, exports.parens)(ctx, b2, "condition");
    r = r && (0, exports.semicolon)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementUntil", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementUntil = StatementUntil;
const StatementTry = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "try"))(ctx, b2);
    r = r && (0, exports.statements)(ctx, b2, "body");
    r = r && (0, exports.StatementTry_optional_62)(ctx, b2, "handler");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementTry", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementTry = StatementTry;
const StatementForEach = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "foreach"))(ctx, b2);
    r = r && consumeString(ctx, b2, "(");
    r = r && (0, exports.Id)(ctx, b2, "key");
    r = r && consumeString(ctx, b2, ",");
    r = r && (0, exports.Id)(ctx, b2, "value");
    r = r && consumeString(ctx, b2, "in");
    r = r && (0, exports.expression)(ctx, b2, "expression");
    r = r && consumeString(ctx, b2, ")");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StatementForEach", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementForEach = StatementForEach;
const augmentedOp = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "||=");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "&&="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, ">>="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "<<="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "-="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "+="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "*="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "/="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "%="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "|="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "&="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "^="));
    pushGroupTo(b, b2, "augmentedOp");
    return r;
};
exports.augmentedOp = augmentedOp;
const FalseBranch = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FalseBranch", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FalseBranch = FalseBranch;
const semicolon = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ";");
    r = r || ((ctx.p = p), (0, exports.semicolon_lookpos_63)(ctx, b2));
    pushGroupTo(b, b2, "semicolon");
    return r;
};
exports.semicolon = semicolon;
const destructItem = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.RegularField)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.PunnedField)(ctx, b2));
    pushGroupTo(b, b2, "destructItem");
    return r;
};
exports.destructItem = destructItem;
const RegularField = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id)(ctx, b2, "fieldName");
    r = r && consumeString(ctx, b2, ":");
    r = r && (0, exports.Id)(ctx, b2, "varName");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "RegularField", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.RegularField = RegularField;
const PunnedField = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "PunnedField", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.PunnedField = PunnedField;
const optionalRest = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.optionalRest_seq_64)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.NoRestArgument)(ctx, b2));
    pushGroupTo(b, b2, "optionalRest");
    return r;
};
exports.optionalRest = optionalRest;
const RestArgument = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "..");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "RestArgument", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.RestArgument = RestArgument;
const NoRestArgument = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ",");
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "NoRestArgument", field ?? ""));
    }
    return r;
};
exports.NoRestArgument = NoRestArgument;
const expression = (ctx, b, field) => {
    return (0, exports.Conditional)(ctx, b, field);
};
exports.expression = expression;
const Conditional = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.or)(ctx, b2, "head");
    r = r && (0, exports.Conditional_optional_66)(ctx, b2, "tail");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Conditional", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Conditional = Conditional;
const or = (ctx, b, field) => {
    return (0, exports.Binary)(exports.and, (ctx, b) => consumeString(ctx, b, "||"))(ctx, b, field);
};
exports.or = or;
const and = (ctx, b, field) => {
    return (0, exports.Binary)(exports.bitwiseOr, (ctx, b) => consumeString(ctx, b, "&&"))(ctx, b, field);
};
exports.and = and;
const bitwiseOr = (ctx, b, field) => {
    return (0, exports.Binary)(exports.bitwiseXor, (ctx, b) => consumeString(ctx, b, "|"))(ctx, b, field);
};
exports.bitwiseOr = bitwiseOr;
const bitwiseXor = (ctx, b, field) => {
    return (0, exports.Binary)(exports.bitwiseAnd, (ctx, b) => consumeString(ctx, b, "^"))(ctx, b, field);
};
exports.bitwiseXor = bitwiseXor;
const bitwiseAnd = (ctx, b, field) => {
    return (0, exports.Binary)(exports.equality, (ctx, b) => consumeString(ctx, b, "&"))(ctx, b, field);
};
exports.bitwiseAnd = bitwiseAnd;
const equality = (ctx, b, field) => {
    return (0, exports.Binary)(exports.compare, exports.equality_alt_67)(ctx, b, field);
};
exports.equality = equality;
const compare = (ctx, b, field) => {
    return (0, exports.Binary)(exports.bitwiseShift, exports.compare_alt_68)(ctx, b, field);
};
exports.compare = compare;
const bitwiseShift = (ctx, b, field) => {
    return (0, exports.Binary)(exports.add, exports.bitwiseShift_alt_69)(ctx, b, field);
};
exports.bitwiseShift = bitwiseShift;
const add = (ctx, b, field) => {
    return (0, exports.Binary)(exports.mul, exports.add_alt_70)(ctx, b, field);
};
exports.add = add;
const mul = (ctx, b, field) => {
    return (0, exports.Binary)(exports.Unary, (ctx, b) => consumeClass(ctx, b, (c) => c === "*" || c === "/" || c === "%"))(ctx, b, field);
};
exports.mul = mul;
const Unary = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Unary_star_71)(ctx, b2, "prefixes");
    r = r && (0, exports.Suffix)(ctx, b2, "expression");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Unary", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Unary = Unary;
const Suffix = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.primary)(ctx, b2, "expression");
    r = r && (0, exports.Suffix_star_72)(ctx, b2, "suffixes");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Suffix", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Suffix = Suffix;
const Binary = (T, U) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = (0, exports.inter)(T, (0, exports.Operator)(U))(ctx, b2, "");
        if (r) {
            b.push((0, exports.CstNode)(b2, "Binary", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.Binary = Binary;
const Operator = (U) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = U(ctx, b2, "name");
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, "Operator", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.Operator = Operator;
const suffix = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.SuffixUnboxNotNull)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.SuffixCall)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.SuffixFieldAccess)(ctx, b2));
    pushGroupTo(b, b2, "suffix");
    return r;
};
exports.suffix = suffix;
const SuffixUnboxNotNull = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "!!");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "SuffixUnboxNotNull", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.SuffixUnboxNotNull = SuffixUnboxNotNull;
const SuffixCall = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ParameterList)(exports.expression)(ctx, b2, "params");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "SuffixCall", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.SuffixCall = SuffixCall;
const SuffixFieldAccess = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ".");
    r = r && (0, exports.Id)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "SuffixFieldAccess", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.SuffixFieldAccess = SuffixFieldAccess;
const primary = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Parens)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.MapLiteral)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.SetLiteral)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StructInstance)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.IntegerLiteral)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.BoolLiteral)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.InitOf)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.CodeOf)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Null)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.StringLiteral)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.Id)(ctx, b2));
    pushGroupTo(b, b2, "primary");
    return r;
};
exports.primary = primary;
const Null = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "null"))(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Null", field ?? ""));
    }
    return r;
};
exports.Null = Null;
const parens = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "(");
    r = r && (0, exports.expression)(ctx, b2);
    r = r && consumeString(ctx, b2, ")");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.parens = parens;
const Parens = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.parens)(ctx, b2, "child");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Parens", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Parens = Parens;
const StructInstance = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.TypeId)(ctx, b2, "type");
    r = r && (0, exports.StructInstanceFields)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StructInstance", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StructInstance = StructInstance;
const StructInstanceFields = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "{");
    r = r && (0, exports.StructInstanceFields_optional_73)(ctx, b2, "fields");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StructInstanceFields", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StructInstanceFields = StructInstanceFields;
const MapLiteral = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "map"))(ctx, b2);
    r = r && (0, exports.typeArgs)(ctx, b2, "typeArgs");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.MapLiteral_optional_74)(ctx, b2, "fields");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "MapLiteral", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.MapLiteral = MapLiteral;
const mapField = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.expression)(ctx, b2, "key");
    r = r && consumeString(ctx, b2, ":");
    r = r && (0, exports.expression)(ctx, b2, "value");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.mapField = mapField;
const SetLiteral = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "set");
    r = r && (0, exports.typeArgs)(ctx, b2, "typeArgs");
    r = r && consumeString(ctx, b2, "{");
    r = r && (0, exports.SetLiteral_optional_75)(ctx, b2, "fields");
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "SetLiteral", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.SetLiteral = SetLiteral;
const InitOf = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "initOf"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ParameterList)(exports.expression)(ctx, b2, "params");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "InitOf", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.InitOf = InitOf;
const CodeOf = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "codeOf");
    r = r && (0, exports.Id)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "CodeOf", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.CodeOf = CodeOf;
const StructFieldInitializer = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.StructFieldInitializer_optional_77)(ctx, b2, "init");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StructFieldInitializer", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StructFieldInitializer = StructFieldInitializer;
const ParameterList = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = consumeString(ctx, b2, "(");
        r = r && (0, exports.ParameterList_optional_78)(T)(ctx, b2);
        r = r && consumeString(ctx, b2, ")");
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, "ParameterList", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.ParameterList = ParameterList;
const Parameter = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id)(ctx, b2, "name");
    r = r && (0, exports.ascription)(ctx, b2, "type");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Parameter", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Parameter = Parameter;
const commaList = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = (0, exports.inter)(T, (ctx, b) => consumeString(ctx, b, ","))(ctx, b2);
        r = r && (0, exports.commaList_optional_79)(T)(ctx, b2);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.commaList = commaList;
const IntegerLiteral = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteral_alt_80)(ctx, b2, "value");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "IntegerLiteral", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteral = IntegerLiteral;
const IntegerLiteralDec = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteralDec_lex_81)(ctx, b2, "digits");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "IntegerLiteralDec", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralDec = IntegerLiteralDec;
const IntegerLiteralHex = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteralHex_lex_83)(ctx, b2, "digits");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "IntegerLiteralHex", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralHex = IntegerLiteralHex;
const IntegerLiteralBin = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteralBin_lex_85)(ctx, b2, "digits");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "IntegerLiteralBin", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralBin = IntegerLiteralBin;
const IntegerLiteralOct = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteralOct_lex_87)(ctx, b2, "digits");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "IntegerLiteralOct", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralOct = IntegerLiteralOct;
const underscored = (T) => {
    return (ctx, b, field) => {
        const p = ctx.p;
        const r = (0, exports.underscored_seq_91)(T)(ctx, []);
        if (r) {
            const text = ctx.s.substring(p, ctx.p);
            b.push((0, exports.CstLeaf)(text));
        }
        return r;
    };
};
exports.underscored = underscored;
const digit = (ctx, b, field) => {
    return consumeClass(ctx, b, (c) => c >= "0" && c <= "9");
};
exports.digit = digit;
const idPart = (ctx, b, field) => {
    return consumeClass(ctx, b, (c) => (c >= "a" && c <= "z") ||
        (c >= "A" && c <= "Z") ||
        (c >= "0" && c <= "9") ||
        c === "_");
};
exports.idPart = idPart;
const Id = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id_lex_96)(ctx, b2, "name");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Id", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Id = Id;
const FuncId = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FuncId_optional_97)(ctx, b2, "accessor");
    r = r && (0, exports.FuncId_stringify_102)(ctx, b2, "id");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "FuncId", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FuncId = FuncId;
const BoolLiteral = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.BoolLiteral_alt_103)(ctx, b2, "value");
    r = r && (0, exports.BoolLiteral_lookneg_104)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "BoolLiteral", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.BoolLiteral = BoolLiteral;
const StringLiteral = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.StringLiteral_lex_110)(ctx, b2, "value");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "StringLiteral", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StringLiteral = StringLiteral;
const escapeChar = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeClass(ctx, b2, (c) => c === "\\" ||
        c === '"' ||
        c === "n" ||
        c === "r" ||
        c === "t" ||
        c === "v" ||
        c === "b" ||
        c === "f");
    r = r || ((ctx.p = p), (0, exports.escapeChar_seq_118)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.escapeChar_seq_121)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.escapeChar_seq_124)(ctx, b2));
    pushGroupTo(b, b2, "escapeChar");
    return r;
};
exports.escapeChar = escapeChar;
const hexDigit = (ctx, b, field) => {
    return consumeClass(ctx, b, (c) => (c >= "0" && c <= "9") ||
        (c >= "a" && c <= "f") ||
        (c >= "A" && c <= "F"));
};
exports.hexDigit = hexDigit;
const keyword = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const newCtx = {
            ...ctx,
            space: undefined,
        };
        const r = (0, exports.keyword_seq_126)(T)(newCtx, b2);
        if (r) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        ctx.p = newCtx.p;
        (0, exports.skip)(ctx, b);
        return r;
    };
};
exports.keyword = keyword;
const reservedWord = (ctx, b, field) => {
    return (0, exports.keyword)(exports.reservedWord_alt_127)(ctx, b, field);
};
exports.reservedWord = reservedWord;
const space = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.space_alt_131)(ctx, b2);
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p), (0, exports.space_alt_131)(ctx, b2))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.space = space;
const Comment = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.multiLineComment)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.singleLineComment)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "Comment", field ?? ""));
    }
    return r;
};
exports.Comment = Comment;
const multiLineComment = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "/*");
    r = r && (0, exports.multiLineComment_stringify_135)(ctx, b2);
    r = r && consumeString(ctx, b2, "*/");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.multiLineComment = multiLineComment;
const singleLineComment = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "//");
    r = r && (0, exports.singleLineComment_stringify_137)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.singleLineComment = singleLineComment;
const JustImports = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.JustImports_star_138)(ctx, b2, "imports");
    r = r && (0, exports.JustImports_star_139)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, "JustImports", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.JustImports = JustImports;
const inter = (A, B) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = A(ctx, b2, "head");
        r = r && (0, exports.inter_star_141)(A, B)(ctx, b2, "tail");
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.inter = inter;
const Module_star_0 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.Import)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Module_star_0 = Module_star_0;
const Module_star_1 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.moduleItem)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Module_star_1 = Module_star_1;
const $Function_star_2 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.FunctionAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.$Function_star_2 = $Function_star_2;
const $Function_optional_3 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ascription)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.$Function_optional_3 = $Function_optional_3;
const $Function_alt_4 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FunctionDefinition)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.FunctionDeclaration)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.$Function_alt_4 = $Function_alt_4;
const AsmFunction_optional_5 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.shuffle)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.AsmFunction_optional_5 = AsmFunction_optional_5;
const AsmFunction_star_6 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.FunctionAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.AsmFunction_star_6 = AsmFunction_star_6;
const AsmFunction_optional_7 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ascription)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.AsmFunction_optional_7 = AsmFunction_optional_7;
const shuffle_star_8 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.Id)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.shuffle_star_8 = shuffle_star_8;
const shuffle_plus_9 = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.IntegerLiteralDec)(ctx, b2);
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p), (0, exports.IntegerLiteralDec)(ctx, b2))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.shuffle_plus_9 = shuffle_plus_9;
const shuffle_seq_10 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "->");
    r = r && (0, exports.shuffle_plus_9)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.shuffle_seq_10 = shuffle_seq_10;
const shuffle_optional_11 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.shuffle_seq_10)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.shuffle_optional_11 = shuffle_optional_11;
const NativeFunctionDecl_lex_12 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.FuncId)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.NativeFunctionDecl_lex_12 = NativeFunctionDecl_lex_12;
const NativeFunctionDecl_star_13 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.FunctionAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.NativeFunctionDecl_star_13 = NativeFunctionDecl_star_13;
const NativeFunctionDecl_optional_14 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ascription)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.NativeFunctionDecl_optional_14 = NativeFunctionDecl_optional_14;
const Constant_star_15 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.ConstantAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Constant_star_15 = Constant_star_15;
const Constant_alt_16 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ConstantDefinition)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.ConstantDeclaration)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.Constant_alt_16 = Constant_alt_16;
const ConstantAttribute_alt_17 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "virtual"))(ctx, b2);
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "override"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "abstract"))(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.ConstantAttribute_alt_17 = ConstantAttribute_alt_17;
const MessageDecl_seq_18 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "(");
    r = r && (0, exports.expression)(ctx, b2);
    r = r && consumeString(ctx, b2, ")");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.MessageDecl_seq_18 = MessageDecl_seq_18;
const MessageDecl_optional_19 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.MessageDecl_seq_18)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.MessageDecl_optional_19 = MessageDecl_optional_19;
const structFields_optional_20 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.inter)(exports.FieldDecl, (ctx, b) => consumeString(ctx, b, ";"))(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.structFields_optional_20 = structFields_optional_20;
const structFields_optional_21 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ";");
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.structFields_optional_21 = structFields_optional_21;
const FieldDecl_seq_22 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "=");
    r = r && (0, exports.expression)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FieldDecl_seq_22 = FieldDecl_seq_22;
const FieldDecl_optional_23 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FieldDecl_seq_22)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FieldDecl_optional_23 = FieldDecl_optional_23;
const Contract_star_24 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.ContractAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Contract_star_24 = Contract_star_24;
const Contract_optional_25 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ParameterList)(exports.Parameter)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.Contract_optional_25 = Contract_optional_25;
const Contract_optional_26 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.inheritedTraits)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.Contract_optional_26 = Contract_optional_26;
const Contract_star_27 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.contractItemDecl)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Contract_star_27 = Contract_star_27;
const Trait_star_28 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.ContractAttribute)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Trait_star_28 = Trait_star_28;
const Trait_optional_29 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.inheritedTraits)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.Trait_optional_29 = Trait_optional_29;
const Trait_star_30 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.traitItemDecl)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Trait_star_30 = Trait_star_30;
const FunctionAttribute_alt_31 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.GetAttribute)(ctx, b2);
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "mutates"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "extends"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "virtual"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "override"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "inline"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "abstract"))(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FunctionAttribute_alt_31 = FunctionAttribute_alt_31;
const GetAttribute_seq_32 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "(");
    r = r && (0, exports.expression)(ctx, b2);
    r = r && consumeString(ctx, b2, ")");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.GetAttribute_seq_32 = GetAttribute_seq_32;
const GetAttribute_optional_33 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.GetAttribute_seq_32)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.GetAttribute_optional_33 = GetAttribute_optional_33;
const ReceiverType_alt_34 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "bounced");
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "receive"))(ctx, b2));
    r =
        r ||
            ((ctx.p = p),
                (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "external"))(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.ReceiverType_alt_34 = ReceiverType_alt_34;
const receiverParam_alt_35 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Parameter)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.StringLiteral)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.receiverParam_alt_35 = receiverParam_alt_35;
const receiverParam_optional_36 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.receiverParam_alt_35)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.receiverParam_optional_36 = receiverParam_optional_36;
const assembly_stringify_37 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.assemblySequence)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.assembly_stringify_37 = assembly_stringify_37;
const assemblyItem_seq_38 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "{");
    r = r && (0, exports.assemblySequence)(ctx, b2);
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.assemblyItem_seq_38 = assemblyItem_seq_38;
const assemblyItem_star_39 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), consumeClass(ctx, b2, (c) => !(c === '"')))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.assemblyItem_star_39 = assemblyItem_star_39;
const assemblyItem_seq_40 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, '"');
    r = r && (0, exports.assemblyItem_star_39)(ctx, b2);
    r = r && consumeString(ctx, b2, '"');
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.assemblyItem_seq_40 = assemblyItem_seq_40;
const assemblyItem_alt_41 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeClass(ctx, b2, (c) => c === '"' || c === "{" || c === "}");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "//"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "/*"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.assemblyItem_alt_41 = assemblyItem_alt_41;
const assemblyItem_lookneg_42 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.assemblyItem_alt_41)(ctx, b);
    ctx.p = p;
    return !r;
};
exports.assemblyItem_lookneg_42 = assemblyItem_lookneg_42;
const assemblyItem_seq_43 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.assemblyItem_lookneg_42)(ctx, b2);
    r = r && (0, exports.consumeAny)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.assemblyItem_seq_43 = assemblyItem_seq_43;
const assemblyItem_plus_44 = (ctx, b, field) => {
    const b2 = [];
    const r = (0, exports.assemblyItem_seq_43)(ctx, b2);
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p), (0, exports.assemblyItem_seq_43)(ctx, b2))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.assemblyItem_plus_44 = assemblyItem_plus_44;
const TypeAs_seq_45 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "as"))(ctx, b2);
    r = r && (0, exports.Id)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeAs_seq_45 = TypeAs_seq_45;
const TypeAs_star_46 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.TypeAs_seq_45)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.TypeAs_star_46 = TypeAs_star_46;
const TypeOptional_star_47 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), consumeString(ctx, b2, "?"))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.TypeOptional_star_47 = TypeOptional_star_47;
const TypeGeneric_alt_48 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.MapKeyword)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.Bounced)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.TypeId)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.TypeGeneric_alt_48 = TypeGeneric_alt_48;
const TypeId_star_49 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p),
        consumeClass(ctx, b2, (c) => (c >= "a" && c <= "z") ||
            (c >= "A" && c <= "Z") ||
            (c >= "0" && c <= "9") ||
            c === "_"))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.TypeId_star_49 = TypeId_star_49;
const TypeId_seq_50 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeClass(ctx, b2, (c) => c >= "A" && c <= "Z");
    r = r && (0, exports.TypeId_star_49)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.TypeId_seq_50 = TypeId_seq_50;
const TypeId_stringify_51 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.TypeId_seq_50)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.TypeId_stringify_51 = TypeId_stringify_51;
const TypeId_lex_52 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.TypeId_stringify_51)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.TypeId_lex_52 = TypeId_lex_52;
const generic_optional_53 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = (0, exports.commaList)(T)(ctx, b2);
        r = r || ((ctx.p = p), true);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return r;
    };
};
exports.generic_optional_53 = generic_optional_53;
const statements_star_54 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.statement)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.statements_star_54 = statements_star_54;
const StatementLet_optional_55 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.ascription)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementLet_optional_55 = StatementLet_optional_55;
const StatementReturn_optional_56 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.expression)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementReturn_optional_56 = StatementReturn_optional_56;
const StatementAssign_alt_57 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.augmentedOp)(ctx, b2);
    r = r || ((ctx.p = p), consumeString(ctx, b2, "="));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementAssign_alt_57 = StatementAssign_alt_57;
const StatementCondition_alt_58 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FalseBranch)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.StatementCondition)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementCondition_alt_58 = StatementCondition_alt_58;
const StatementCondition_seq_59 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "else"))(ctx, b2);
    r = r && (0, exports.StatementCondition_alt_58)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementCondition_seq_59 = StatementCondition_seq_59;
const StatementCondition_optional_60 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.StatementCondition_seq_59)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementCondition_optional_60 = StatementCondition_optional_60;
const StatementTry_seq_61 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.keyword)((ctx, b) => consumeString(ctx, b, "catch"))(ctx, b2);
    r = r && consumeString(ctx, b2, "(");
    r = r && (0, exports.Id)(ctx, b2, "name");
    r = r && consumeString(ctx, b2, ")");
    r = r && (0, exports.statements)(ctx, b2, "body");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StatementTry_seq_61 = StatementTry_seq_61;
const StatementTry_optional_62 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.StatementTry_seq_61)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StatementTry_optional_62 = StatementTry_optional_62;
const semicolon_lookpos_63 = (ctx, b, field) => {
    const p = ctx.p;
    const r = consumeString(ctx, [], "}");
    ctx.p = p;
    return r;
};
exports.semicolon_lookpos_63 = semicolon_lookpos_63;
const optionalRest_seq_64 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ",");
    r = r && (0, exports.RestArgument)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.optionalRest_seq_64 = optionalRest_seq_64;
const Conditional_seq_65 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "?");
    r = r && (0, exports.or)(ctx, b2, "thenBranch");
    r = r && consumeString(ctx, b2, ":");
    r = r && (0, exports.Conditional)(ctx, b2, "elseBranch");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Conditional_seq_65 = Conditional_seq_65;
const Conditional_optional_66 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Conditional_seq_65)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.Conditional_optional_66 = Conditional_optional_66;
const equality_alt_67 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "!=");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "=="));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.equality_alt_67 = equality_alt_67;
const compare_alt_68 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "<=");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "<"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, ">="));
    r = r || ((ctx.p = p), consumeString(ctx, b2, ">"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.compare_alt_68 = compare_alt_68;
const bitwiseShift_alt_69 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "<<");
    r = r || ((ctx.p = p), consumeString(ctx, b2, ">>"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.bitwiseShift_alt_69 = bitwiseShift_alt_69;
const add_alt_70 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "+");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "-"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.add_alt_70 = add_alt_70;
const Unary_star_71 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p),
        (0, exports.Operator)((ctx, b) => consumeClass(ctx, b, (c) => c === "-" || c === "+" || c === "!" || c === "~"))(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Unary_star_71 = Unary_star_71;
const Suffix_star_72 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.suffix)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Suffix_star_72 = Suffix_star_72;
const StructInstanceFields_optional_73 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.commaList)(exports.StructFieldInitializer)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StructInstanceFields_optional_73 = StructInstanceFields_optional_73;
const MapLiteral_optional_74 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.commaList)(exports.mapField)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.MapLiteral_optional_74 = MapLiteral_optional_74;
const SetLiteral_optional_75 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.commaList)(exports.expression)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.SetLiteral_optional_75 = SetLiteral_optional_75;
const StructFieldInitializer_seq_76 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, ":");
    r = r && (0, exports.expression)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StructFieldInitializer_seq_76 = StructFieldInitializer_seq_76;
const StructFieldInitializer_optional_77 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.StructFieldInitializer_seq_76)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StructFieldInitializer_optional_77 = StructFieldInitializer_optional_77;
const ParameterList_optional_78 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = (0, exports.commaList)(T)(ctx, b2);
        r = r || ((ctx.p = p), true);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return r;
    };
};
exports.ParameterList_optional_78 = ParameterList_optional_78;
const commaList_optional_79 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = consumeString(ctx, b2, ",");
        r = r || ((ctx.p = p), true);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return r;
    };
};
exports.commaList_optional_79 = commaList_optional_79;
const IntegerLiteral_alt_80 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.IntegerLiteralHex)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.IntegerLiteralBin)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.IntegerLiteralOct)(ctx, b2));
    r = r || ((ctx.p = p), (0, exports.IntegerLiteralDec)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.IntegerLiteral_alt_80 = IntegerLiteral_alt_80;
const IntegerLiteralDec_lex_81 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.underscored)(exports.digit)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.IntegerLiteralDec_lex_81 = IntegerLiteralDec_lex_81;
const IntegerLiteralHex_seq_82 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "0");
    r = r && consumeClass(ctx, b2, (c) => c === "x" || c === "X");
    r = r && (0, exports.underscored)(exports.hexDigit)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralHex_seq_82 = IntegerLiteralHex_seq_82;
const IntegerLiteralHex_lex_83 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.IntegerLiteralHex_seq_82)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.IntegerLiteralHex_lex_83 = IntegerLiteralHex_lex_83;
const IntegerLiteralBin_seq_84 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "0");
    r = r && consumeClass(ctx, b2, (c) => c === "b" || c === "B");
    r =
        r &&
            (0, exports.underscored)((ctx, b) => consumeClass(ctx, b, (c) => c === "0" || c === "1"))(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralBin_seq_84 = IntegerLiteralBin_seq_84;
const IntegerLiteralBin_lex_85 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.IntegerLiteralBin_seq_84)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.IntegerLiteralBin_lex_85 = IntegerLiteralBin_lex_85;
const IntegerLiteralOct_seq_86 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "0");
    r = r && consumeClass(ctx, b2, (c) => c === "o" || c === "O");
    r =
        r &&
            (0, exports.underscored)((ctx, b) => consumeClass(ctx, b, (c) => c >= "0" && c <= "7"))(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.IntegerLiteralOct_seq_86 = IntegerLiteralOct_seq_86;
const IntegerLiteralOct_lex_87 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.IntegerLiteralOct_seq_86)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.IntegerLiteralOct_lex_87 = IntegerLiteralOct_lex_87;
const underscored_optional_88 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = consumeString(ctx, b2, "_");
        r = r || ((ctx.p = p), true);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return r;
    };
};
exports.underscored_optional_88 = underscored_optional_88;
const underscored_seq_89 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = (0, exports.underscored_optional_88)(T)(ctx, b2);
        r = r && T(ctx, b2);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.underscored_seq_89 = underscored_seq_89;
const underscored_star_90 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        let p = ctx.p;
        while (((p = ctx.p), (0, exports.underscored_seq_89)(T)(ctx, b2))) { }
        ctx.p = p;
        if (b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return true;
    };
};
exports.underscored_star_90 = underscored_star_90;
const underscored_seq_91 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = T(ctx, b2);
        r = r && (0, exports.underscored_star_90)(T)(ctx, b2);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.underscored_seq_91 = underscored_seq_91;
const Id_lookneg_92 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.reservedWord)(ctx, b);
    ctx.p = p;
    return !r;
};
exports.Id_lookneg_92 = Id_lookneg_92;
const Id_star_93 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.idPart)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.Id_star_93 = Id_star_93;
const Id_seq_94 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.Id_lookneg_92)(ctx, b2);
    r =
        r &&
            consumeClass(ctx, b2, (c) => (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || c === "_");
    r = r && (0, exports.Id_star_93)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.Id_seq_94 = Id_seq_94;
const Id_stringify_95 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.Id_seq_94)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.Id_stringify_95 = Id_stringify_95;
const Id_lex_96 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.Id_stringify_95)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.Id_lex_96 = Id_lex_96;
const FuncId_optional_97 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeClass(ctx, b2, (c) => c === "." || c === "~");
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FuncId_optional_97 = FuncId_optional_97;
const FuncId_plus_98 = (ctx, b, field) => {
    const b2 = [];
    const r = consumeClass(ctx, b2, (c) => !(c === "`" || c === "\r" || c === "\n"));
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p),
            consumeClass(ctx, b2, (c) => !(c === "`" || c === "\r" || c === "\n")))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FuncId_plus_98 = FuncId_plus_98;
const FuncId_seq_99 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "`");
    r = r && (0, exports.FuncId_plus_98)(ctx, b2);
    r = r && consumeString(ctx, b2, "`");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.FuncId_seq_99 = FuncId_seq_99;
const FuncId_plus_100 = (ctx, b, field) => {
    const b2 = [];
    const r = consumeClass(ctx, b2, (c) => !(c === " " ||
        c === "\t" ||
        c === "\r" ||
        c === "\n" ||
        c === "(" ||
        c === ")" ||
        c === "[" ||
        c === '"\\]"' ||
        c === "," ||
        c === "." ||
        c === ";" ||
        c === "~"));
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p),
            consumeClass(ctx, b2, (c) => !(c === " " ||
                c === "\t" ||
                c === "\r" ||
                c === "\n" ||
                c === "(" ||
                c === ")" ||
                c === "[" ||
                c === '"\\]"' ||
                c === "," ||
                c === "." ||
                c === ";" ||
                c === "~")))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FuncId_plus_100 = FuncId_plus_100;
const FuncId_alt_101 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.FuncId_seq_99)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.FuncId_plus_100)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.FuncId_alt_101 = FuncId_alt_101;
const FuncId_stringify_102 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.FuncId_alt_101)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.FuncId_stringify_102 = FuncId_stringify_102;
const BoolLiteral_alt_103 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "true");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "false"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.BoolLiteral_alt_103 = BoolLiteral_alt_103;
const BoolLiteral_lookneg_104 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.idPart)(ctx, b);
    ctx.p = p;
    return !r;
};
exports.BoolLiteral_lookneg_104 = BoolLiteral_lookneg_104;
const StringLiteral_seq_105 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "\\");
    r = r && (0, exports.escapeChar)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StringLiteral_seq_105 = StringLiteral_seq_105;
const StringLiteral_alt_106 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeClass(ctx, b2, (c) => !(c === '"' || c === "\\"));
    r = r || ((ctx.p = p), (0, exports.StringLiteral_seq_105)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.StringLiteral_alt_106 = StringLiteral_alt_106;
const StringLiteral_star_107 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.StringLiteral_alt_106)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.StringLiteral_star_107 = StringLiteral_star_107;
const StringLiteral_stringify_108 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.StringLiteral_star_107)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.StringLiteral_stringify_108 = StringLiteral_stringify_108;
const StringLiteral_seq_109 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, '"');
    r = r && (0, exports.StringLiteral_stringify_108)(ctx, b2);
    r = r && consumeString(ctx, b2, '"');
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.StringLiteral_seq_109 = StringLiteral_seq_109;
const StringLiteral_lex_110 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.StringLiteral_seq_109)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.StringLiteral_lex_110 = StringLiteral_lex_110;
const escapeChar_optional_111 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.escapeChar_optional_111 = escapeChar_optional_111;
const escapeChar_optional_112 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.escapeChar_optional_112 = escapeChar_optional_112;
const escapeChar_optional_113 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.escapeChar_optional_113 = escapeChar_optional_113;
const escapeChar_optional_114 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.escapeChar_optional_114 = escapeChar_optional_114;
const escapeChar_optional_115 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r || ((ctx.p = p), true);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.escapeChar_optional_115 = escapeChar_optional_115;
const escapeChar_seq_116 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r && (0, exports.escapeChar_optional_111)(ctx, b2);
    r = r && (0, exports.escapeChar_optional_112)(ctx, b2);
    r = r && (0, exports.escapeChar_optional_113)(ctx, b2);
    r = r && (0, exports.escapeChar_optional_114)(ctx, b2);
    r = r && (0, exports.escapeChar_optional_115)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_116 = escapeChar_seq_116;
const escapeChar_stringify_117 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.escapeChar_seq_116)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.escapeChar_stringify_117 = escapeChar_stringify_117;
const escapeChar_seq_118 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "u{");
    r = r && (0, exports.escapeChar_stringify_117)(ctx, b2);
    r = r && consumeString(ctx, b2, "}");
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_118 = escapeChar_seq_118;
const escapeChar_seq_119 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r && (0, exports.hexDigit)(ctx, b2);
    r = r && (0, exports.hexDigit)(ctx, b2);
    r = r && (0, exports.hexDigit)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_119 = escapeChar_seq_119;
const escapeChar_stringify_120 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.escapeChar_seq_119)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.escapeChar_stringify_120 = escapeChar_stringify_120;
const escapeChar_seq_121 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "u");
    r = r && (0, exports.escapeChar_stringify_120)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_121 = escapeChar_seq_121;
const escapeChar_seq_122 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.hexDigit)(ctx, b2);
    r = r && (0, exports.hexDigit)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_122 = escapeChar_seq_122;
const escapeChar_stringify_123 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.escapeChar_seq_122)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.escapeChar_stringify_123 = escapeChar_stringify_123;
const escapeChar_seq_124 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "x");
    r = r && (0, exports.escapeChar_stringify_123)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.escapeChar_seq_124 = escapeChar_seq_124;
const keyword_lookneg_125 = (T) => {
    return (ctx, b, field) => {
        const p = ctx.p;
        const r = (0, exports.idPart)(ctx, b);
        ctx.p = p;
        return !r;
    };
};
exports.keyword_lookneg_125 = keyword_lookneg_125;
const keyword_seq_126 = (T) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = T(ctx, b2);
        r = r && (0, exports.keyword_lookneg_125)(T)(ctx, b2);
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.keyword_seq_126 = keyword_seq_126;
const reservedWord_alt_127 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = consumeString(ctx, b2, "extend");
    r = r || ((ctx.p = p), consumeString(ctx, b2, "public"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "fun"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "let"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "return"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "receive"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "native"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "primitive"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "null"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "if"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "else"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "while"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "repeat"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "do"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "until"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "try"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "catch"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "foreach"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "as"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "map"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "mutates"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "extends"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "external"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "import"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "with"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "trait"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "initOf"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "override"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "abstract"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "virtual"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "inline"));
    r = r || ((ctx.p = p), consumeString(ctx, b2, "const"));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.reservedWord_alt_127 = reservedWord_alt_127;
const space_plus_128 = (ctx, b, field) => {
    const b2 = [];
    const r = consumeClass(ctx, b2, (c) => c === " " || c === "\t" || c === "\r" || c === "\n");
    if (r) {
        let p = ctx.p;
        while (((p = ctx.p),
            consumeClass(ctx, b2, (c) => c === " " || c === "\t" || c === "\r" || c === "\n"))) { }
        ctx.p = p;
    }
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.space_plus_128 = space_plus_128;
const space_stringify_129 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.space_plus_128)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.space_stringify_129 = space_stringify_129;
const space_lex_130 = (ctx, b, field) => {
    const b2 = [];
    const newCtx = {
        ...ctx,
        space: undefined,
    };
    const r = (0, exports.space_stringify_129)(newCtx, b2);
    if (r) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    ctx.p = newCtx.p;
    (0, exports.skip)(ctx, b);
    return r;
};
exports.space_lex_130 = space_lex_130;
const space_alt_131 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.space_lex_130)(ctx, b2);
    r = r || ((ctx.p = p), (0, exports.Comment)(ctx, b2));
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return r;
};
exports.space_alt_131 = space_alt_131;
const multiLineComment_lookneg_132 = (ctx, b, field) => {
    const p = ctx.p;
    const r = consumeString(ctx, b, "*/");
    ctx.p = p;
    return !r;
};
exports.multiLineComment_lookneg_132 = multiLineComment_lookneg_132;
const multiLineComment_seq_133 = (ctx, b, field) => {
    const b2 = [];
    const p = ctx.p;
    let r = (0, exports.multiLineComment_lookneg_132)(ctx, b2);
    r = r && (0, exports.consumeAny)(ctx, b2);
    if (r && b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    if (!r) {
        ctx.p = p;
    }
    return r;
};
exports.multiLineComment_seq_133 = multiLineComment_seq_133;
const multiLineComment_star_134 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.multiLineComment_seq_133)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.multiLineComment_star_134 = multiLineComment_star_134;
const multiLineComment_stringify_135 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.multiLineComment_star_134)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.multiLineComment_stringify_135 = multiLineComment_stringify_135;
const singleLineComment_star_136 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), consumeClass(ctx, b2, (c) => !(c === "\r" || c === "\n")))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.singleLineComment_star_136 = singleLineComment_star_136;
const singleLineComment_stringify_137 = (ctx, b, field) => {
    const p = ctx.p;
    const r = (0, exports.singleLineComment_star_136)(ctx, []);
    if (r) {
        const text = ctx.s.substring(p, ctx.p);
        b.push((0, exports.CstLeaf)(text));
    }
    return r;
};
exports.singleLineComment_stringify_137 = singleLineComment_stringify_137;
const JustImports_star_138 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.Import)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.JustImports_star_138 = JustImports_star_138;
const JustImports_star_139 = (ctx, b, field) => {
    const b2 = [];
    let p = ctx.p;
    while (((p = ctx.p), (0, exports.consumeAny)(ctx, b2))) { }
    ctx.p = p;
    if (b2.length > 0) {
        b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
    }
    return true;
};
exports.JustImports_star_139 = JustImports_star_139;
const inter_seq_140 = (A, B) => {
    return (ctx, b, field) => {
        const b2 = [];
        const p = ctx.p;
        let r = B(ctx, b2, "op");
        r = r && A(ctx, b2, "right");
        if (r && b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        if (!r) {
            ctx.p = p;
        }
        return r;
    };
};
exports.inter_seq_140 = inter_seq_140;
const inter_star_141 = (A, B) => {
    return (ctx, b, field) => {
        const b2 = [];
        let p = ctx.p;
        while (((p = ctx.p), (0, exports.inter_seq_140)(A, B)(ctx, b2))) { }
        ctx.p = p;
        if (b2.length > 0) {
            b.push((0, exports.CstNode)(b2, field ?? "", field ?? ""));
        }
        return true;
    };
};
exports.inter_star_141 = inter_star_141;
