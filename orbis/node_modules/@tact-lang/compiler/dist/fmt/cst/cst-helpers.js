"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.textOfId = exports.childLeafIdxWithText = exports.childLeafWithText = exports.childIdxByField = exports.childrenByField = exports.childByField = exports.nonLeafChild = exports.childrenByType = exports.childIdxByType = exports.childByType = exports.visit = void 0;
exports.parseCode = parseCode;
exports.countNewlines = countNewlines;
exports.trailingNewlines = trailingNewlines;
exports.isComment = isComment;
exports.isInlineComment = isInlineComment;
exports.filterComments = filterComments;
exports.containsComments = containsComments;
exports.commentText = commentText;
const cst_parser_1 = require("./cst-parser");
const process_comments_1 = require("./process-comments");
const simplify_cst_1 = require("./simplify-cst");
function parseCode(code) {
    const ctx = (0, cst_parser_1.createContext)(code, cst_parser_1.space);
    const b = [];
    (0, cst_parser_1.skip)(ctx, b);
    const res = (0, cst_parser_1.Module)(ctx, b);
    if (!res) {
        return undefined;
    }
    const root = (0, cst_parser_1.CstNode)(b, "Root");
    const recreatedCode = (0, exports.visit)(root);
    if (recreatedCode !== code) {
        return undefined;
    }
    const processDocComments = (0, process_comments_1.getProcessDocComments)();
    return processDocComments((0, simplify_cst_1.simplifyCst)(root));
}
const visit = (node) => {
    if (node.$ === "leaf")
        return node.text;
    return node.children.map((it) => (0, exports.visit)(it)).join("");
};
exports.visit = visit;
const childByType = (node, type) => {
    if (node.$ === "leaf") {
        return undefined;
    }
    const found = node.children.find((c) => c.$ === "node" && c.type === type);
    if (found?.$ === "node") {
        return found;
    }
    return undefined;
};
exports.childByType = childByType;
const childIdxByType = (node, type) => {
    if (node.$ === "leaf") {
        return -1;
    }
    return node.children.findIndex((c) => c.$ === "node" && c.type === type);
};
exports.childIdxByType = childIdxByType;
const childrenByType = (node, type) => {
    if (node.$ === "leaf") {
        return [];
    }
    return node.children
        .filter((c) => c.$ === "node" && c.type === type)
        .filter((c) => c.$ === "node");
};
exports.childrenByType = childrenByType;
const nonLeafChild = (node) => {
    if (!node || node.$ === "leaf") {
        return undefined;
    }
    return node.children.find((c) => c.$ === "node");
};
exports.nonLeafChild = nonLeafChild;
const childByField = (node, field) => {
    if (node.$ === "leaf") {
        return undefined;
    }
    const res = node.children.find((c) => c.$ === "node" && c.field === field);
    if (res && res.$ === "node") {
        return res;
    }
    return undefined;
};
exports.childByField = childByField;
const childrenByField = (node, field) => {
    if (node.$ === "leaf") {
        return [];
    }
    return node.children
        .filter((c) => c.$ === "node")
        .filter((c) => c.field === field);
};
exports.childrenByField = childrenByField;
const childIdxByField = (node, field) => {
    if (node.$ === "leaf") {
        return -1;
    }
    return node.children.findIndex((c) => c.$ === "node" && c.field === field);
};
exports.childIdxByField = childIdxByField;
const childLeafWithText = (node, text) => {
    if (!node || node.$ === "leaf") {
        return undefined;
    }
    const res = node.children.find((c) => c.$ === "leaf" && c.text === text);
    if (res && res.$ === "leaf") {
        return res;
    }
    return undefined;
};
exports.childLeafWithText = childLeafWithText;
const childLeafIdxWithText = (node, text) => {
    if (!node || node.$ === "leaf") {
        return -1;
    }
    return node.children.findIndex((c) => c.$ === "leaf" && c.text === text);
};
exports.childLeafIdxWithText = childLeafIdxWithText;
const textOfId = (node) => {
    if (node.$ === "leaf")
        return node.text;
    if (node.type === "Id" || node.type === "TypeId") {
        const name = (0, exports.childByField)(node, "name");
        if (!name)
            return "";
        const first = name.children.at(0);
        return first && first.$ === "leaf" ? first.text : "";
    }
    return "";
};
exports.textOfId = textOfId;
function countNewlines(leaf) {
    if (!leaf || leaf.$ !== "leaf")
        return 0;
    return leaf.text.split("").filter((it) => it === "\n").length;
}
function trailingNewlines(node) {
    if (node.$ === "leaf")
        return 0;
    if (node.children.length === 0) {
        return 0;
    }
    const lastChild = node.children.at(-1);
    if (!lastChild)
        return 0;
    if (lastChild.$ === "leaf") {
        if (lastChild.text.includes("\n")) {
            return countNewlines(lastChild);
        }
        return 0;
    }
    return trailingNewlines(lastChild);
}
function isComment(node) {
    return node.$ === "node" && node.type === "Comment";
}
function isInlineComment(node) {
    return (node.$ === "node" &&
        node.type === "Comment" &&
        (0, exports.visit)(node).startsWith("//"));
}
function filterComments(nodes) {
    return nodes
        .filter((it) => it.$ === "node")
        .filter((it) => it.type === "Comment");
}
function containsComments(nodes) {
    return nodes.some((it) => isComment(it));
}
function commentText(node) {
    const firstChild = node.children.at(0);
    if (!firstChild)
        return "";
    const textChild = node.children.at(1);
    const text = textChild ? (0, exports.visit)(textChild) : "";
    if (firstChild.$ === "leaf" && firstChild.text === "//") {
        if (text.startsWith("/")) {
            return text.slice(1).trim();
        }
        return text.trim();
    }
    if (firstChild.$ === "leaf" && firstChild.text === "/*") {
        return text.trim();
    }
    return "";
}
