"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatField = exports.formatMessage = exports.formatStruct = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const helpers_1 = require("./helpers");
const format_expressions_1 = require("./format-expressions");
const format_doc_comments_1 = require("./format-doc-comments");
const format_types_1 = require("./format-types");
const format_comments_1 = require("./format-comments");
const formatStruct = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    code.add("struct").space().add((0, helpers_1.declName)(node));
    formatFields(code, node);
};
exports.formatStruct = formatStruct;
const formatMessage = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    code.add("message");
    // message(0x100) Foo {}
    //         ^^^^^ this
    const opcodeOpt = (0, cst_helpers_1.childByField)(node, "opcode");
    if (opcodeOpt) {
        code.add("(");
        const expression = (0, cst_helpers_1.nonLeafChild)(opcodeOpt);
        if (expression) {
            (0, format_expressions_1.formatExpression)(code, expression);
        }
        code.add(")");
    }
    code.space().add((0, helpers_1.declName)(node));
    formatFields(code, node);
};
exports.formatMessage = formatMessage;
const formatFields = (code, node) => {
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    const children = node.children.slice(0, endIndex);
    // struct can contain only comments, so we need to handle this case properly
    const hasComments = (0, cst_helpers_1.containsComments)(children);
    const fieldsNode = (0, cst_helpers_1.childByField)(node, "fields");
    if (!fieldsNode && !hasComments) {
        code.space().add("{}");
        // format inline comments after `}`
        (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
        return;
    }
    const fields = fieldsNode ? (0, cst_helpers_1.childrenByType)(fieldsNode, "FieldDecl") : [];
    const firstField = fields.at(0);
    const oneLiner = fields.length === 1 &&
        firstField &&
        (0, cst_helpers_1.childLeafWithText)(fieldsNode, ";") === undefined &&
        !hasComments;
    if (oneLiner) {
        code.space().add("{").space();
        (0, exports.formatField)(code, firstField, false);
        code.space().add("}");
        // format inline comments after `}`
        (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
        return;
    }
    code.space().add("{").newLine().indent();
    for (const child of children) {
        if (child.$ === "leaf")
            continue;
        if (child.type === "Comment") {
            code.apply(format_comments_1.formatComment, child);
            code.newLine();
        }
        if (child.field === "fields") {
            const fields = child.children;
            let needNewline = false;
            let needNewlineBetween = false;
            for (const field of fields) {
                if (field.$ === "leaf") {
                    if ((0, helpers_1.containsSeveralNewlines)(field.text)) {
                        needNewlineBetween = true;
                    }
                    continue;
                }
                if (needNewlineBetween) {
                    code.newLine();
                    needNewlineBetween = false;
                }
                if (field.type === "Comment") {
                    if (needNewline) {
                        code.newLine();
                    }
                    code.apply(format_comments_1.formatComment, field);
                    code.newLine();
                    needNewline = false;
                }
                else if (field.type === "FieldDecl") {
                    if (needNewline) {
                        code.newLine();
                    }
                    (0, exports.formatField)(code, field, true);
                    needNewline = true;
                }
            }
            if (needNewline) {
                code.newLine();
            }
        }
    }
    code.dedent().add("}");
    // format inline comments after `}`
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatField = (code, decl, needSemicolon) => {
    (0, format_doc_comments_1.formatDocComments)(code, decl);
    // foo : Int = 100;
    // ^^^ ^^^^^   ^^^
    // |   |       |
    // |   |       initOpt
    // |   type
    // name
    const name = (0, cst_helpers_1.childByField)(decl, "name");
    const type = (0, cst_helpers_1.childByField)(decl, "type");
    const initOpt = (0, cst_helpers_1.childByField)(decl, "expression");
    if (!name || !type) {
        throw new Error("Invalid field declaration");
    }
    // foo: Int
    code.apply(helpers_1.formatId, name).apply(format_types_1.formatAscription, type);
    if (initOpt) {
        // foo: Int = 100;
        //            ^^^ this
        const value = (0, cst_helpers_1.nonLeafChild)(initOpt);
        if (value) {
            //  = 100
            code.space().add("=").space().apply(format_expressions_1.formatExpression, value);
        }
    }
    code.addIf(needSemicolon, ";");
    // since `;` is not a part of the field, we process all comments after type
    //
    // foo: Int; // 100
    //      ^^^ after this type
    const endIndex = (0, cst_helpers_1.childIdxByField)(decl, "type");
    (0, format_comments_1.formatTrailingComments)(code, decl, endIndex, true);
};
exports.formatField = formatField;
