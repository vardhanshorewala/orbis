"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatAscription = exports.formatType = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const helpers_1 = require("./helpers");
const format_comments_1 = require("./format-comments");
const formatType = (code, node) => {
    switch (node.type) {
        case "TypeRegular": {
            formatTypeRegular(code, node);
            break;
        }
        case "TypeGeneric": {
            formatTypeGeneric(code, node);
            break;
        }
        case "TypeAs": {
            formatTypeAs(code, node);
            break;
        }
        case "TypeOptional": {
            formatTypeOptional(code, node);
            break;
        }
        case "TypeId": {
            code.add((0, cst_helpers_1.textOfId)(node));
            break;
        }
        default: {
            code.add((0, cst_helpers_1.visit)(node).trim());
        }
    }
};
exports.formatType = formatType;
const formatAscription = (code, node) => {
    // : Int
    //   ^^^ this
    const type = (0, cst_helpers_1.childByType)(node, "TypeAs");
    if (!type) {
        throw new Error("Invalid ascription");
    }
    code.add(":").space();
    (0, exports.formatType)(code, type);
};
exports.formatAscription = formatAscription;
const formatTypeRegular = (code, node) => {
    const child = (0, cst_helpers_1.childByField)(node, "child");
    if (!child) {
        throw new Error("Invalid regular type");
    }
    code.add((0, cst_helpers_1.textOfId)(child));
    (0, format_comments_1.formatTrailingComments)(code, child, 0, true);
};
const formatTypeGeneric = (code, node) => {
    // map<Int, String>
    // ^^^ ^^^^^^^^^^^
    // |   |
    // |   args
    // name
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const args = (0, cst_helpers_1.childByField)(node, "args");
    if (!name || !args) {
        throw new Error("Invalid generic type");
    }
    (0, exports.formatType)(code, name);
    // ["Int", ", ", "String"] -> ["Int", "String"]
    const typeArgs = (0, cst_helpers_1.childrenByType)(args, "TypeAs");
    if (typeArgs.length === 0) {
        // bounced type
        typeArgs.push(...(0, cst_helpers_1.childrenByType)(args, "TypeOptional"));
    }
    if (typeArgs.length > 0) {
        code.add("<");
        typeArgs.forEach((arg, i) => {
            (0, exports.formatType)(code, arg);
            if (i < typeArgs.length - 1) {
                code.add(",").space();
            }
        });
        code.add(">");
    }
};
const formatTypeAs = (code, node) => {
    const type = (0, cst_helpers_1.childByField)(node, "type");
    if (!type) {
        throw new Error("Invalid 'as' type");
    }
    (0, exports.formatType)(code, type);
    // Int as int64
    //     ^^^^^^^^ this
    const asTypeOpt = (0, cst_helpers_1.childByField)(node, "as");
    if (asTypeOpt) {
        const children = (0, cst_helpers_1.nonLeafChild)(asTypeOpt);
        if (children) {
            code.space().add("as").space();
            code.apply(helpers_1.formatId, children);
        }
    }
};
const formatTypeOptional = (code, node) => {
    const type = (0, cst_helpers_1.childByType)(node, "TypeRegular");
    if (type) {
        (0, exports.formatType)(code, type);
    }
    const typeGeneric = (0, cst_helpers_1.childByType)(node, "TypeGeneric");
    if (typeGeneric) {
        (0, exports.formatType)(code, typeGeneric);
    }
    // Foo?
    //    ^ this
    const optionals = (0, cst_helpers_1.childrenByType)(node, "optionals");
    for (const _ of optionals) {
        code.add("?");
    }
};
