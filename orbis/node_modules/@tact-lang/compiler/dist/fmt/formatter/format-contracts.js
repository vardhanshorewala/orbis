"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatTrait = exports.formatContract = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const helpers_1 = require("./helpers");
const format_declarations_1 = require("./format-declarations");
const format_statements_1 = require("./format-statements");
const format_expressions_1 = require("./format-expressions");
const format_doc_comments_1 = require("./format-doc-comments");
const format_comments_1 = require("./format-comments");
const format_structs_1 = require("./format-structs");
const formatContract = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    formatContractTraitAttributes(code, node);
    code.add("contract").space().add((0, helpers_1.declName)(node));
    formatContractParameters(code, node);
    formatInheritedTraits(code, node);
    formatContractTraitBody(code, node, (code, decl) => {
        switch (decl.type) {
            case "ContractInit": {
                formatContractInit(code, decl);
                break;
            }
            case "Receiver": {
                formatReceiver(code, decl);
                break;
            }
            case "$Function": {
                (0, format_declarations_1.formatFunction)(code, decl);
                break;
            }
            case "Constant": {
                (0, format_declarations_1.formatConstant)(code, decl);
                break;
            }
            case "FieldDecl": {
                (0, format_structs_1.formatField)(code, decl, true);
                break;
            }
            default: {
                throw new Error(`Unknown contract declaration type: ${decl.type}`);
            }
        }
    });
};
exports.formatContract = formatContract;
const formatTrait = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    formatContractTraitAttributes(code, node);
    code.add("trait").space().add((0, helpers_1.declName)(node));
    formatInheritedTraits(code, node);
    formatContractTraitBody(code, node, (code, decl) => {
        switch (decl.type) {
            case "Receiver": {
                formatReceiver(code, decl);
                break;
            }
            case "$Function": {
                (0, format_declarations_1.formatFunction)(code, decl);
                break;
            }
            case "Constant": {
                (0, format_declarations_1.formatConstant)(code, decl);
                break;
            }
            case "FieldDecl": {
                (0, format_structs_1.formatField)(code, decl, true);
                break;
            }
            default: {
                throw new Error(`Unknown trait declaration type: ${decl.type}`);
            }
        }
    });
};
exports.formatTrait = formatTrait;
const formatContractInit = (code, decl) => {
    (0, format_doc_comments_1.formatDocComments)(code, decl);
    code.add("init");
    // init(foo: Int) {}
    //      ^^^^^^^^
    const paramsOpt = (0, cst_helpers_1.childByField)(decl, "parameters");
    if (paramsOpt) {
        (0, helpers_1.formatSeparatedList)(code, paramsOpt, format_declarations_1.formatParameter);
    }
    const body = (0, cst_helpers_1.childByField)(decl, "body");
    if (!body) {
        throw new Error("Invalid contract init declaration");
    }
    code.space();
    (0, format_statements_1.formatStatements)(code, body);
};
const formatReceiver = (code, decl) => {
    (0, format_doc_comments_1.formatDocComments)(code, decl);
    // receive(param: Message) {}
    // ^^^^^^^ ^^^^^^^^^^^^^^  ^^
    // |       |               |
    // |       |               body
    // |       paramOpt
    // type
    const type = (0, cst_helpers_1.childByField)(decl, "type");
    const paramOpt = (0, cst_helpers_1.childByField)(decl, "param");
    const body = (0, cst_helpers_1.childByField)(decl, "body");
    if (!type || !body) {
        throw new Error("Invalid receiver declaration");
    }
    // receive/external/bounced
    const receiverKind = (0, cst_helpers_1.childByField)(type, "name");
    if (!receiverKind) {
        throw new Error("Invalid receiver type");
    }
    code.add((0, cst_helpers_1.visit)(receiverKind));
    if (paramOpt) {
        code.add("(");
        if (paramOpt.type === "Parameter") {
            // receive(param: Slice) {}
            //         ^^^^^^^^^^^^ this
            (0, format_declarations_1.formatParameter)(code, paramOpt);
        }
        else if (paramOpt.type === "StringLiteral") {
            // receive("hello") {}
            //         ^^^^^^^ this
            (0, format_expressions_1.formatExpression)(code, paramOpt);
        }
        code.add(")");
    }
    else {
        code.add("()");
    }
    code.space();
    (0, format_statements_1.formatStatements)(code, body);
};
const formatContractTraitAttribute = (code, attr) => {
    const name = (0, cst_helpers_1.childByField)(attr, "name");
    if (!name)
        return;
    code.add("@interface").add("(").apply(format_expressions_1.formatExpression, name).add(")");
};
const formatContractTraitAttributes = (code, node) => {
    // @interface("name")
    // ^^^^^^^^^^^^^^^^^^ this
    // contract Foo {}
    const attributesNode = (0, cst_helpers_1.childByField)(node, "attributes");
    if (!attributesNode)
        return;
    const attributes = (0, cst_helpers_1.childrenByType)(attributesNode, "ContractAttribute");
    attributes.forEach((attr, i) => {
        formatContractTraitAttribute(code, attr);
        if (i < attributes.length - 1) {
            code.newLine();
        }
    });
    if (attributes.length > 0) {
        code.newLine();
    }
};
const formatInheritedTraits = (code, node) => {
    // contract Foo with Bar, Baz {}
    //              ^^^^^^^^^^^^^ this
    const traitsNode = (0, cst_helpers_1.childByField)(node, "traits");
    if (!traitsNode)
        return;
    code.space().add("with");
    // ["with", " ", "Bar", ", ", "Baz"]
    //               ^ starts from here
    const namesIndex = (0, cst_helpers_1.childIdxByType)(traitsNode, "Id");
    (0, helpers_1.formatSeparatedList)(code, traitsNode, helpers_1.formatId, {
        wrapperLeft: "",
        wrapperRight: "",
        startIndex: namesIndex,
        endIndex: 0,
        spaceBeforeIfNotMultiline: true,
    });
};
const formatContractParameters = (code, node) => {
    // contract Foo(value: Int) {}
    //             ^^^^^^^^^^^^ this
    const params = (0, cst_helpers_1.childByField)(node, "parameters");
    if (!params)
        return;
    (0, helpers_1.formatSeparatedList)(code, params, format_declarations_1.formatParameter);
};
function formatContractTraitBody(code, node, formatDeclaration) {
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    const children = node.children.slice(0, endIndex);
    // contract or trait can contain only comments, so we need to handle this case properly
    const hasComments = (0, cst_helpers_1.containsComments)(children);
    const declarationsNode = (0, cst_helpers_1.childByField)(node, "declarations");
    if (!declarationsNode && !hasComments) {
        code.space().add("{}");
        // format inline comments after `}`
        (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
        return;
    }
    code.space().add("{").newLine().indent();
    const declarations = declarationsNode?.children ?? [];
    let needNewLine = false;
    let previousDeclarationType = undefined;
    for (const decl of declarations) {
        if (decl.$ === "leaf") {
            if ((0, helpers_1.containsSeveralNewlines)(decl.text)) {
                needNewLine = true;
            }
            continue;
        }
        if (needNewLine) {
            code.newLine();
            needNewLine = false;
            previousDeclarationType = undefined; // don't need to add extra newline
        }
        if (decl.type === "Comment") {
            (0, format_comments_1.formatComment)(code, decl);
        }
        else {
            const otherKind = previousDeclarationType !== decl.type;
            const afterNonFieldOrConstant = previousDeclarationType !== "FieldDecl" &&
                previousDeclarationType !== "Constant";
            if (previousDeclarationType !== undefined &&
                (otherKind || afterNonFieldOrConstant)) {
                // add extra new line between declarations except fields and constants
                code.newLine();
            }
            formatDeclaration(code, decl);
            previousDeclarationType = decl.type;
        }
        code.newLine();
        const newlines = (0, cst_helpers_1.trailingNewlines)(decl);
        if (newlines > 1) {
            code.newLine();
            previousDeclarationType = undefined; // don't need to add extra newline
        }
    }
    if (!declarationsNode) {
        // empty contract
        const openBraceIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "{");
        const closeBraceIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
        // output comments between `{` and `}`
        const bodyNodes = node.children.slice(openBraceIndex + 1, closeBraceIndex);
        const comments = (0, cst_helpers_1.filterComments)(bodyNodes);
        (0, format_comments_1.formatLineComments)(code, comments);
    }
    code.trimNewlines().newLine();
    code.dedent().add("}");
    // format inline comments after `}`
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
}
