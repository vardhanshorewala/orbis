"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatExpression = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const code_builder_1 = require("./code-builder");
const helpers_1 = require("./helpers");
const format_types_1 = require("./format-types");
const format_comments_1 = require("./format-comments");
const format_doc_comments_1 = require("./format-doc-comments");
const formatExpression = (code, node) => {
    if (node.$ !== "node") {
        code.add((0, cst_helpers_1.visit)(node));
        return;
    }
    switch (node.type) {
        case "expression": {
            const child = (0, cst_helpers_1.nonLeafChild)(node);
            if (child) {
                (0, exports.formatExpression)(code, child);
            }
            return;
        }
        case "Operator": {
            const name = node.children.at(0);
            if (!name) {
                return;
            }
            code.add((0, cst_helpers_1.visit)(name).trim());
            return;
        }
        // TODO: better handling of literals
        case "StringLiteral": {
            code.add((0, cst_helpers_1.visit)(node).trim());
            return;
        }
        case "IntegerLiteral": {
            code.add((0, cst_helpers_1.visit)(node).trim());
            return;
        }
        case "IntegerLiteralDec": {
            code.add((0, cst_helpers_1.visit)(node).trim());
            return;
        }
        case "BoolLiteral": {
            code.add((0, cst_helpers_1.visit)(node).trim());
            return;
        }
        case "Null": {
            code.add("null");
            return;
        }
        case "StructInstance": {
            formatStructInstance(code, node);
            return;
        }
        case "SuffixFieldAccess": {
            formatSuffixFieldAccess(code, node);
            return;
        }
        case "SuffixUnboxNotNull": {
            formatSuffixUnboxNotNull(code, node);
            return;
        }
        case "SuffixCall": {
            formatSuffixCall(code, node);
            return;
        }
        case "Parens": {
            const child = (0, cst_helpers_1.childByField)(node, "child");
            const expression = (0, cst_helpers_1.nonLeafChild)(child);
            code.add("(").applyOpt(exports.formatExpression, expression).add(")");
            const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(child, ")");
            (0, format_comments_1.formatTrailingComments)(code, child, endIndex, true);
            return;
        }
        case "condition": {
            const expression = (0, cst_helpers_1.nonLeafChild)(node);
            code.add("(").applyOpt(exports.formatExpression, expression).add(")");
            return;
        }
        case "Conditional": {
            formatConditional(code, node);
            return;
        }
        case "Binary": {
            formatBinary(code, node);
            return;
        }
        case "Unary": {
            formatUnary(code, node);
            return;
        }
        case "ParameterList": {
            (0, helpers_1.formatSeparatedList)(code, node, exports.formatExpression);
            return;
        }
        case "Suffix": {
            formatSuffix(code, node);
            return;
        }
        case "InitOf": {
            formatInitOf(code, node);
            return;
        }
        case "CodeOf": {
            formatCodeOf(code, node);
            return;
        }
        case "Id": {
            code.apply(helpers_1.formatId, node);
            return;
        }
        case "MapLiteral": {
            formatMapLiteral(code, node);
            return;
        }
    }
    code.add((0, cst_helpers_1.visit)(node).trim());
};
exports.formatExpression = formatExpression;
const formatBinary = (code, node) => {
    const lineLengthBeforeLeft = code.lineLength();
    let indented = false;
    const processBinaryTail = (code, node) => {
        if (node.$ === "leaf")
            return;
        let newlinesCount = 0;
        for (const child of node.children) {
            if (child.$ === "leaf")
                continue;
            if (child.type === "Operator") {
                code.space();
            }
            code.apply(exports.formatExpression, child);
            if (child.type === "Operator") {
                newlinesCount = (0, cst_helpers_1.trailingNewlines)(child);
                const commentsStart = child.children.findIndex((it) => (0, cst_helpers_1.isComment)(it));
                const commentsEnd = child.children.length -
                    1 -
                    [...child.children]
                        .reverse()
                        .findIndex((it) => (0, cst_helpers_1.isComment)(it)) +
                    1;
                const comments = child.children.slice(commentsStart, commentsEnd);
                if ((0, cst_helpers_1.containsComments)(comments)) {
                    if (newlinesCount === 0) {
                        // inline comments after operator
                        code.space();
                    }
                    const preCommentsNewlines = (0, cst_helpers_1.countNewlines)(child.children[commentsStart - 1]);
                    const postCommentsNewlines = (0, cst_helpers_1.countNewlines)(child.children[commentsEnd]);
                    if (preCommentsNewlines > 0) {
                        code.newLines(preCommentsNewlines);
                    }
                    else {
                        code.space();
                    }
                    for (const comment of comments) {
                        if (comment.$ === "leaf") {
                            const newlines = (0, cst_helpers_1.countNewlines)(comment);
                            code.newLines(newlines);
                            continue;
                        }
                        if (comment.type === "Comment") {
                            (0, format_comments_1.formatComment)(code, comment);
                        }
                    }
                    code.newLines(postCommentsNewlines - 1);
                    newlinesCount = 1;
                }
                else if (newlinesCount === 0) {
                    code.space();
                }
            }
            if (newlinesCount) {
                if (!indented && lineLengthBeforeLeft > 0) {
                    code.indentCustom(lineLengthBeforeLeft);
                    indented = true;
                }
                code.newLines(newlinesCount);
                newlinesCount = 0;
            }
        }
    };
    const head = (0, cst_helpers_1.childByField)(node, "head");
    const tail = (0, cst_helpers_1.childByField)(node, "tail");
    if (!head || !tail) {
        return;
    }
    code.apply(exports.formatExpression, head);
    code.apply(processBinaryTail, tail);
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (indented) {
        code.dedent();
    }
};
const formatUnary = (code, node) => {
    // ! foo
    // ^ ^^^
    // | |
    // | expression
    // |
    // prefixesNode
    const prefixesNode = (0, cst_helpers_1.childByField)(node, "prefixes");
    const expression = (0, cst_helpers_1.childByField)(node, "expression");
    if (!expression) {
        throw new Error("Invalid unary expression");
    }
    const prefixes = prefixesNode?.children ?? [];
    for (const prefix of prefixes) {
        (0, exports.formatExpression)(code, prefix);
    }
    (0, exports.formatExpression)(code, expression);
};
function isNestedConditional(node) {
    if (node.type === "Parens") {
        const child = (0, cst_helpers_1.childByField)(node, "child");
        const expression = (0, cst_helpers_1.nonLeafChild)(child);
        if (!expression)
            return false;
        return isNestedConditional(expression);
    }
    return node.type === "Conditional";
}
const formatConditional = (code, node) => {
    // foo ? bar : baz
    // ^^^ ^^^^^^^^^^^
    // |   |
    // |   tailOpt
    // head
    const head = node.children.at(0);
    const tailOpt = (0, cst_helpers_1.childByField)(node, "tail");
    if (!head) {
        throw new Error("Invalid conditional expression");
    }
    (0, exports.formatExpression)(code, head);
    if (!tailOpt)
        return; // Incomplete ternary
    const thenBranch = tailOpt.children.find((it) => it.$ === "node");
    const elseBranch = (0, cst_helpers_1.childByField)(tailOpt, "elseBranch");
    if (!thenBranch || !elseBranch) {
        throw new Error("Invalid conditional branches");
    }
    const trueBranchCode = new code_builder_1.CodeBuilder()
        .apply(exports.formatExpression, thenBranch)
        .toString();
    const falseBranchCode = new code_builder_1.CodeBuilder()
        .apply(exports.formatExpression, elseBranch)
        .toString();
    const branchesWidth = trueBranchCode.length + falseBranchCode.length;
    const nestedConditional = isNestedConditional(thenBranch) || isNestedConditional(elseBranch);
    const multiline = branchesWidth > 70 || nestedConditional;
    if (multiline) {
        // format as:
        // bar
        //     ? trueBranch
        //     : falseBranch
        // prettier-ignore
        code.newLine().indent()
            .add("?").space().apply(exports.formatExpression, thenBranch)
            .newLine()
            .add(":").space().apply(exports.formatExpression, elseBranch)
            .dedent();
    }
    else {
        // format as:
        // bar ? trueBranch : falseBranch
        // prettier-ignore
        code.space().add("?").space()
            .apply(exports.formatExpression, thenBranch)
            .space().add(":").space()
            .apply(exports.formatExpression, elseBranch);
    }
    // trailing comments are processed in certain expression formatter
};
const formatInitOf = (code, node) => {
    code.add("initOf");
    // initOf JettonWallet(0, sender)
    //        ^^^^^^^^^^^^ ^^^^^^^^^
    //        |            |
    //        |            params
    //        name
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const params = (0, cst_helpers_1.childByField)(node, "params");
    if (!name || !params) {
        throw new Error("Invalid initOf expression");
    }
    code.space().apply(helpers_1.formatId, name);
    (0, helpers_1.formatSeparatedList)(code, params, exports.formatExpression);
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(params, ")");
    (0, format_comments_1.formatTrailingComments)(code, params, endIndex, true);
};
const formatCodeOf = (code, node) => {
    code.add("codeOf");
    // codeOf JettonWallet
    //        ^^^^^^^^^^^^ this
    const name = (0, cst_helpers_1.childByField)(node, "name");
    if (!name) {
        throw new Error("Invalid codeOf expression");
    }
    code.space().apply(helpers_1.formatId, name);
    // trailing comments are processed in `formatId`
};
const formatStructInstance = (code, node) => {
    // Foo { value: 100 }
    // ^^^ ^^^^^^^^^^^^^^
    // |   |
    // |   fields
    // type
    const type = (0, cst_helpers_1.childByField)(node, "type");
    const fields = (0, cst_helpers_1.childByType)(node, "StructInstanceFields");
    if (!type || !fields) {
        throw new Error("Invalid struct instance");
    }
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(fields, "}");
    code.apply(format_types_1.formatType, type).space();
    (0, helpers_1.formatSeparatedList)(code, fields, (code, field) => {
        (0, format_doc_comments_1.formatDocComments)(code, field);
        // `value: 100` or just `value`
        const name = (0, cst_helpers_1.childByField)(field, "name");
        if (!name)
            throw new Error("Invalid field initializer");
        code.add((0, cst_helpers_1.textOfId)(name));
        // value: 100
        //      ^^^^^ this
        const initOpt = (0, cst_helpers_1.childByField)(field, "init");
        if (initOpt) {
            const expression = (0, cst_helpers_1.nonLeafChild)(initOpt);
            if (expression === undefined)
                return;
            if ((0, helpers_1.idText)(name) === (0, helpers_1.idText)(expression)) {
                // value: value -> value
                return;
            }
            code.add(":").space();
            (0, exports.formatExpression)(code, expression);
        }
    }, {
        startIndex: 1,
        endIndex,
        wrapperLeft: "{",
        wrapperRight: "}",
        extraWrapperSpace: " ",
        provideTrailingComments: (field) => {
            if (field.$ !== "node")
                return [];
            // value: 100
            //      ^^^^^ this
            const initOpt = (0, cst_helpers_1.childByField)(field, "init");
            const searchField = initOpt ? "init" : "name";
            const endIndex = (0, cst_helpers_1.childIdxByField)(field, searchField);
            return (0, cst_helpers_1.filterComments)(field.children.slice(endIndex));
        },
    });
    (0, format_comments_1.formatTrailingComments)(code, fields, endIndex, true);
};
const findTrailingComments = (node) => {
    if (node.$ === "leaf")
        return [];
    if (node.children.some((it) => (0, cst_helpers_1.isComment)(it))) {
        // backtrace from the end to find only comments that are not part of the expression
        // for example,
        // 100 // comment
        //     ^^^^^^^^^^ needed comment
        //
        // 100 + /* foo */ 200
        //       ^^^^^^^^^ inside expression
        let lastIndex = node.children.length - 1;
        for (let i = lastIndex; i >= 0; i--) {
            const child = node.children[i];
            if (!child)
                continue;
            if (child.$ === "leaf" && child.text.includes("\n"))
                continue;
            if (child.$ === "node" && child.type === "Comment")
                continue;
            lastIndex = i;
            break;
        }
        // return only trailing comments
        return node.children.slice(lastIndex);
    }
    const lastChildren = node.children.at(-1);
    if (!lastChildren)
        return [];
    return findTrailingComments(lastChildren);
};
const hasTrailingCommentOnNextLine = (node) => {
    if (node.$ === "leaf")
        return false;
    const trailingComments = findTrailingComments(node);
    const multiline = trailingComments.some((it) => it.$ === "leaf" && it.text.includes("\n"));
    const hasComments = trailingComments.some((it) => (0, cst_helpers_1.isComment)(it));
    return multiline && hasComments;
};
const formatSuffix = (code, node) => {
    const suffixes = (0, cst_helpers_1.childByField)(node, "suffixes");
    if (!suffixes)
        return;
    const infos = [];
    let suffixesList = suffixes.type === "SuffixFieldAccess" ||
        suffixes.type === "SuffixCall" ||
        suffixes.type === "SuffixUnboxNotNull"
        ? [suffixes]
        : suffixes.children;
    // foo.bar()
    // ^^^
    const firstExpression = node.children.at(0);
    if (!firstExpression)
        return;
    // foo.bar()
    //        ^^
    const firstSuffix = suffixesList.at(0);
    const secondSuffix = suffixesList.at(1);
    // first call suffix attached to the first expression
    const firstSuffixIsCallOrNotNull = firstSuffix &&
        firstSuffix.$ === "node" &&
        (firstSuffix.type === "SuffixCall" ||
            firstSuffix.type === "SuffixUnboxNotNull");
    if (firstSuffixIsCallOrNotNull) {
        suffixesList = suffixesList.slice(1);
    }
    for (const suffix of suffixesList) {
        if (suffix.$ !== "node")
            continue;
        if (suffix.type === "SuffixFieldAccess") {
            const name = (0, cst_helpers_1.childByField)(suffix, "name");
            if (name) {
                infos.push({
                    nodes: [suffix],
                    hasLeadingNewline: name.children.some((it) => it.$ === "leaf" && it.text.includes("\n")),
                    leadingComments: [],
                    trailingComments: [],
                });
            }
        }
        if (suffix.type === "SuffixCall" && infos.length > 0) {
            const lastInfo = infos.at(-1);
            if (lastInfo) {
                lastInfo.nodes.push(suffix);
                const params = (0, cst_helpers_1.childByField)(suffix, "params");
                lastInfo.hasLeadingNewline =
                    params?.children.some((it) => it.$ === "leaf" && it.text.includes("\n")) ?? false;
            }
        }
        if (suffix.type === "SuffixUnboxNotNull" && infos.length > 0) {
            const lastInfo = infos.at(-1);
            if (lastInfo) {
                lastInfo.nodes.push(suffix);
            }
        }
    }
    const indent = infos.slice(0, -1).some((call) => call.hasLeadingNewline)
        ? 4
        : 0;
    (0, exports.formatExpression)(code, firstExpression);
    if (firstSuffixIsCallOrNotNull) {
        (0, exports.formatExpression)(code, firstSuffix);
        if (secondSuffix &&
            secondSuffix.$ === "node" &&
            secondSuffix.type === "SuffixUnboxNotNull") {
            (0, exports.formatExpression)(code, secondSuffix);
        }
    }
    const shouldBeMultiline = indent > 0 ||
        infos
            .slice(0, -1)
            .some((call) => call.leadingComments.length > 0 ||
            call.trailingComments.length > 0) ||
        hasTrailingCommentOnNextLine(firstExpression);
    if (shouldBeMultiline) {
        code.indent();
        code.newLine();
        infos.forEach((info, index) => {
            for (const child of info.nodes) {
                code.apply(exports.formatExpression, child);
            }
            if (index !== infos.length - 1) {
                code.newLine();
            }
        });
        code.dedent();
    }
    else {
        for (const info of infos) {
            for (const child of info.nodes) {
                code.apply(exports.formatExpression, child);
            }
        }
    }
    return;
};
const formatSuffixFieldAccess = (code, node) => {
    const name = (0, cst_helpers_1.childByField)(node, "name");
    if (!name) {
        throw new Error("Invalid field access expression");
    }
    code.add(".");
    code.apply(helpers_1.formatId, name);
    // trailing comments are processed in `formatId`
};
const formatSuffixUnboxNotNull = (code, node) => {
    code.add("!!");
    (0, format_comments_1.formatTrailingComments)(code, node, 1, true);
};
const formatSuffixCall = (code, node) => {
    const args = (0, cst_helpers_1.childByField)(node, "params");
    if (!args) {
        throw new Error("Invalid call expression");
    }
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(args, ")");
    (0, helpers_1.formatSeparatedList)(code, args, exports.formatExpression, { endIndex });
    (0, format_comments_1.formatTrailingComments)(code, args, endIndex, true);
};
const formatTypeArgs = (code, node) => {
    // <Int , String, Foo>
    //  ^^^ ^^^^^^^^^^^^^
    //  |   |
    //  |   tail
    //  head
    const head = (0, cst_helpers_1.childByField)(node, "head");
    const tail = (0, cst_helpers_1.childByField)(node, "tail");
    if (!head) {
        throw new Error("Invalid type args");
    }
    code.add("<");
    code.apply(format_types_1.formatType, head);
    if (tail) {
        const right = (0, cst_helpers_1.childrenByField)(tail, "right");
        right.forEach((type) => {
            code.add(", ");
            code.apply(format_types_1.formatType, type);
        });
    }
    code.add(">");
};
const formatMapLiteral = (code, node) => {
    // map<Int, Int> { }
    // ^^^^^^^^^^^^^ ^ ^
    // |             | |
    // |             | closeBrace
    // |             openBrace
    // typeArgs
    const typeArgs = (0, cst_helpers_1.childByField)(node, "typeArgs");
    const openBrace = (0, cst_helpers_1.childLeafIdxWithText)(node, "{");
    const closeBrace = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    if (!typeArgs || openBrace === -1 || closeBrace === -1) {
        throw new Error("Invalid map literal");
    }
    code.add("map");
    code.apply(formatTypeArgs, typeArgs);
    code.add(" ");
    (0, helpers_1.formatSeparatedList)(code, node, (code, item) => {
        const key = (0, cst_helpers_1.childByField)(item, "key");
        const value = (0, cst_helpers_1.childByField)(item, "value");
        if (!key || !value) {
            throw new Error("Invalid map literal field");
        }
        code.apply(exports.formatExpression, key);
        code.add(": ");
        code.apply(exports.formatExpression, value);
    }, {
        startIndex: openBrace,
        endIndex: closeBrace,
        wrapperLeft: "{",
        wrapperRight: "}",
        extraWrapperSpace: " ",
        provideTrailingComments: (field) => {
            if (field.$ !== "node")
                return [];
            // 10: 20
            //     ^^ this
            const value = (0, cst_helpers_1.childByField)(field, "value");
            if (!value)
                return [];
            const endIndex = (0, cst_helpers_1.childIdxByField)(field, "value");
            return (0, cst_helpers_1.filterComments)(field.children.slice(endIndex));
        },
    });
};
