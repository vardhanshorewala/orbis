"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatConstant = exports.formatPrimitiveType = exports.formatAsmFunction = exports.formatNativeFunction = exports.formatFunction = exports.formatParameter = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const helpers_1 = require("./helpers");
const format_types_1 = require("./format-types");
const format_statements_1 = require("./format-statements");
const format_expressions_1 = require("./format-expressions");
const format_doc_comments_1 = require("./format-doc-comments");
const format_comments_1 = require("./format-comments");
const formatParameter = (code, param) => {
    // value: Foo
    // ^^^^^  ^^^
    // |      |
    // |      type
    // name
    const name = (0, cst_helpers_1.childByField)(param, "name");
    const type = (0, cst_helpers_1.childByField)(param, "type");
    if (!name || !type) {
        throw new Error("Invalid parameter");
    }
    code.apply(helpers_1.formatId, name);
    (0, format_types_1.formatAscription)(code, type);
};
exports.formatParameter = formatParameter;
const formatFunction = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    // fun foo(value: Int): Bool {}
    //     ^^^ ^^^^^^^^^^ ^^^^^^ ^^
    //     |   |          |      |
    //     |   |          |      bodyOpt
    //     |   |          returnTypeOpt
    //     |   parameters
    //     name
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const parameters = (0, cst_helpers_1.childByField)(node, "parameters");
    const returnTypeOpt = (0, cst_helpers_1.childByField)(node, "returnType");
    const bodyOpt = (0, cst_helpers_1.childByField)(node, "body");
    if (!name || !parameters) {
        throw new Error("Invalid function node");
    }
    // inline extends fun foo(self: Int) {}
    // ^^^^^^^^^^^^^^ this
    const attributes = (0, cst_helpers_1.childByField)(node, "attributes");
    if (attributes) {
        formatAttributes(code, attributes);
    }
    code.add("fun").space().apply(helpers_1.formatId, name);
    (0, helpers_1.formatSeparatedList)(code, parameters, exports.formatParameter);
    if (returnTypeOpt) {
        (0, format_types_1.formatAscription)(code, returnTypeOpt);
    }
    if (bodyOpt && bodyOpt.type === "FunctionDefinition") {
        code.space();
        const innerBody = (0, cst_helpers_1.childByField)(bodyOpt, "body");
        if (innerBody) {
            (0, format_statements_1.formatStatements)(code, innerBody);
        }
    }
    else {
        code.add(";");
        // process trailing comments after `;`
        const semicolonIndex = (0, cst_helpers_1.childLeafIdxWithText)(bodyOpt, ";");
        (0, format_comments_1.formatTrailingComments)(code, bodyOpt, semicolonIndex, true);
    }
};
exports.formatFunction = formatFunction;
const formatAttribute = (code, attr) => {
    // get(100)
    // ^^^
    const attrName = (0, cst_helpers_1.childByField)(attr, "name");
    if (!attrName)
        return;
    if (attrName.type === "GetAttribute") {
        code.add("get");
        // get(0x1000) fun foo() {}
        //    ^^^^^^^^ this
        const methodIdOpt = (0, cst_helpers_1.childByField)(attrName, "methodId");
        if (methodIdOpt) {
            // get(0x1000) fun foo() {}
            //     ^^^^^^ this
            const value = (0, cst_helpers_1.nonLeafChild)(methodIdOpt);
            if (value) {
                code.add("(").apply(format_expressions_1.formatExpression, value).add(")");
            }
        }
    }
    else {
        code.add((0, helpers_1.idText)(attr));
    }
    code.space();
};
const formatNativeFunction = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    // @name("native_name")
    // ^^^^^ ^^^^^^^^^^^^^
    // |     |
    // |     nativeName
    // name
    //
    // inline native foo(param: Int): Int {}
    // ^^^^^^         ^^^ ^^^^^^^^^^ ^^^^^ ^^
    // attributesOpt  |   |          |     |
    //                |   |          |     body
    //                |   |          returnTypeOpt
    //                |   parameters
    //                name
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const nativeName = (0, cst_helpers_1.childByField)(node, "nativeName");
    const parameters = (0, cst_helpers_1.childByField)(node, "parameters");
    const returnTypeOpt = (0, cst_helpers_1.childByField)(node, "returnType");
    const attributesOpt = (0, cst_helpers_1.childByField)(node, "attributes");
    if (!name || !nativeName || !parameters) {
        throw new Error("Invalid native function declaration");
    }
    code.add("@name").add("(").apply(format_expressions_1.formatExpression, nativeName).add(")");
    // inline comments after `@name()`
    const comments = (0, helpers_1.getCommentsBetween)(node, nativeName, attributesOpt ?? name);
    (0, format_comments_1.formatComments)(code, comments, true);
    code.newLine();
    if (attributesOpt) {
        formatAttributes(code, attributesOpt);
    }
    code.add("native").space().apply(helpers_1.formatId, name);
    (0, helpers_1.formatSeparatedList)(code, parameters, exports.formatParameter);
    if (returnTypeOpt) {
        (0, format_types_1.formatAscription)(code, returnTypeOpt);
    }
    code.add(";");
    // process trailing comments after `;`
    const semicolonIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, ";");
    (0, format_comments_1.formatTrailingComments)(code, node, semicolonIndex, true);
};
exports.formatNativeFunction = formatNativeFunction;
const formatAsmFunction = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    // asm(a, b) inline fun foo(param: Int): Int { FOO }
    //    ^^^^^^ ^^^^^^     ^^^ ^^^^^^^^^^ ^^^^^   ^^^^
    //    |      |          |   |          |       |
    //    |      |          |   |          |       instructions
    //    |      |          |   |          returnTypeOpt
    //    |      |          |   parameters
    //    |      |          name
    //    |      attributes
    //    shuffle
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const parameters = (0, cst_helpers_1.childByField)(node, "parameters");
    const returnTypeOpt = (0, cst_helpers_1.childByField)(node, "returnType");
    const attributes = (0, cst_helpers_1.childByField)(node, "attributes");
    const shuffle = (0, cst_helpers_1.childByField)(node, "shuffle");
    const instructions = (0, cst_helpers_1.childByField)(node, "instructions");
    if (!name || !parameters || !instructions) {
        throw new Error("Invalid asm function declaration");
    }
    code.add("asm");
    if (shuffle) {
        formatAsmShuffle(code, shuffle);
    }
    code.space();
    if (attributes) {
        formatAttributes(code, attributes);
    }
    code.add("fun").space().apply(helpers_1.formatId, name);
    (0, helpers_1.formatSeparatedList)(code, parameters, exports.formatParameter);
    if (returnTypeOpt) {
        (0, format_types_1.formatAscription)(code, returnTypeOpt);
    }
    code.space().add("{");
    // format instructions as is, without any changes
    const openBraceIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "{");
    const instructionsIndex = (0, cst_helpers_1.childIdxByField)(node, "instructions");
    for (let i = openBraceIndex + 1; i <= instructionsIndex; i++) {
        const child = node.children[i];
        if (typeof child !== "undefined") {
            code.add((0, cst_helpers_1.visit)(child));
        }
    }
    code.add("}");
    // process trailing comments after `}`
    const braceIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    (0, format_comments_1.formatTrailingComments)(code, node, braceIndex, true);
};
exports.formatAsmFunction = formatAsmFunction;
const formatAsmShuffle = (code, node) => {
    // (a, b -> 1, 2)
    //  ^^^^ ^^^^^^^
    //  |    |
    //  |    to
    //  ids
    const ids = (0, cst_helpers_1.childByField)(node, "ids");
    const to = (0, cst_helpers_1.childByField)(node, "to");
    code.add("(");
    if (ids) {
        (0, helpers_1.formatSeparatedList)(code, ids, (code, id) => {
            code.apply(helpers_1.formatId, id);
        }, {
            wrapperLeft: "",
            wrapperRight: "",
            startIndex: 0,
            endIndex: 0,
            separator: "",
        });
    }
    if (to) {
        if (ids) {
            code.space();
        }
        code.add("->").space();
        (0, helpers_1.formatSeparatedList)(code, to, (code, value) => {
            (0, format_expressions_1.formatExpression)(code, value);
        }, {
            wrapperLeft: "",
            wrapperRight: "",
            startIndex: 0,
            endIndex: 0,
            separator: "",
        });
    }
    code.add(")");
};
const formatAttributes = (code, attributes) => {
    const attrs = (0, cst_helpers_1.childrenByType)(attributes, "FunctionAttribute");
    for (const attr of attrs) {
        formatAttribute(code, attr);
    }
};
const formatPrimitiveType = (code, node) => {
    (0, format_doc_comments_1.formatDocComments)(code, node);
    // primitive Foo;
    // ^^^^^^^^^ ^^^
    // |         |
    // |         name
    // keyword
    const name = (0, cst_helpers_1.childByField)(node, "name");
    if (!name) {
        throw new Error("Invalid primitive type declaration");
    }
    code.add("primitive").space().apply(helpers_1.formatId, name).add(";");
    // process trailing comments after `;`
    const semicolonIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, ";");
    (0, format_comments_1.formatTrailingComments)(code, node, semicolonIndex, true);
};
exports.formatPrimitiveType = formatPrimitiveType;
const formatConstant = (code, decl) => {
    (0, format_doc_comments_1.formatDocComments)(code, decl);
    // const Foo : Int = 100;
    //       ^^^ ^^^^^ ^^^^^
    //       |   |     |
    //       |   |     bodyOpt
    //       |   type
    //       name
    const name = (0, cst_helpers_1.childByField)(decl, "name");
    const type = (0, cst_helpers_1.childByField)(decl, "type");
    const bodyOpt = (0, cst_helpers_1.childByField)(decl, "body");
    if (!name || !type) {
        throw new Error("Invalid constant declaration");
    }
    const attributes = (0, cst_helpers_1.childByField)(decl, "attributes");
    if (attributes) {
        formatConstantAttributes(code, attributes);
    }
    // const FOO: Int
    code.add("const")
        .space()
        .apply(helpers_1.formatId, name)
        .apply(format_types_1.formatAscription, type);
    if (bodyOpt && bodyOpt.type === "ConstantDefinition") {
        // const Foo: Int = 100;
        //               ^^^^^^^ this
        code.space().add("=").space();
        // const Foo: Int = 100;
        //                  ^^^ this
        const value = (0, cst_helpers_1.nonLeafChild)(bodyOpt);
        if (value) {
            code.apply(format_expressions_1.formatExpression, value).add(";");
        }
    }
    else if (!bodyOpt || bodyOpt.type === "ConstantDeclaration") {
        // const Foo: Int;
        //               ^ this
        code.add(";");
    }
    // process trailing comments after `;`
    const semicolonIndex = (0, cst_helpers_1.childLeafIdxWithText)(bodyOpt, ";");
    (0, format_comments_1.formatTrailingComments)(code, bodyOpt, semicolonIndex, true);
};
exports.formatConstant = formatConstant;
const formatConstantAttributes = (code, attributes) => {
    const attrs = (0, cst_helpers_1.childrenByType)(attributes, "ConstantAttribute");
    for (const attr of attrs) {
        formatConstantAttribute(code, attr);
    }
};
const formatConstantAttribute = (code, attr) => {
    const attrName = (0, cst_helpers_1.childByField)(attr, "name");
    if (!attrName)
        return;
    code.add((0, helpers_1.idText)(attr)).space();
};
