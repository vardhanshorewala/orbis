"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = void 0;
const code_builder_1 = require("./code-builder");
const format_declarations_1 = require("./format-declarations");
const format_statements_1 = require("./format-statements");
const format_expressions_1 = require("./format-expressions");
const cst_helpers_1 = require("../cst/cst-helpers");
const format_contracts_1 = require("./format-contracts");
const format_structs_1 = require("./format-structs");
const helpers_1 = require("./helpers");
const format_comments_1 = require("./format-comments");
const format_imports_1 = require("./format-imports");
const format = (node) => {
    const code = new code_builder_1.CodeBuilder();
    formatNode(code, node);
    return code.toString();
};
exports.format = format;
const formatNode = (code, node) => {
    if (node.$ === "leaf") {
        code.add(node.text);
        return;
    }
    switch (node.type) {
        case "Root": {
            if (node.children.length === 0) {
                return;
            }
            let needNewLine = false;
            node.children.forEach((child, index) => {
                if (child.$ === "leaf") {
                    // don't add extra leading lines
                    if (index !== 0 && (0, helpers_1.containsSeveralNewlines)(child.text)) {
                        needNewLine = true;
                    }
                    return;
                }
                if (needNewLine) {
                    code.newLine();
                    needNewLine = false;
                }
                if (child.type === "Comment") {
                    (0, format_comments_1.formatComment)(code, child);
                    code.newLine();
                    return;
                }
                formatNode(code, child);
                if (index < node.children.length - 2) {
                    code.newLine();
                }
            });
            code.trimNewlines().newLine();
            break;
        }
        case "Module": {
            const imports = (0, cst_helpers_1.childByField)(node, "imports");
            if (imports) {
                (0, format_imports_1.formatImports)(code, imports);
            }
            const itemsNode = (0, cst_helpers_1.childByField)(node, "items");
            if (!itemsNode) {
                break;
            }
            let needNewLine = false;
            const items = itemsNode.children;
            items.forEach((item, index) => {
                if (item.$ === "leaf") {
                    if ((0, helpers_1.containsSeveralNewlines)(item.text)) {
                        needNewLine = true;
                    }
                    return;
                }
                if (needNewLine) {
                    code.newLine();
                    needNewLine = false;
                }
                if (item.type === "Comment") {
                    // floating comment
                    code.add((0, cst_helpers_1.visit)(item));
                    code.newLine();
                    return;
                }
                if ((0, helpers_1.hasIgnoreDirective)(item)) {
                    code.add((0, cst_helpers_1.visit)(item).trim());
                }
                else {
                    formatNode(code, item);
                }
                if (index < items.length - 1) {
                    code.newLine();
                }
                const newlines = (0, cst_helpers_1.trailingNewlines)(item);
                if (newlines > 1) {
                    code.newLine();
                }
            });
            break;
        }
        case "PrimitiveTypeDecl": {
            (0, format_declarations_1.formatPrimitiveType)(code, node);
            break;
        }
        case "$Function": {
            (0, format_declarations_1.formatFunction)(code, node);
            break;
        }
        case "NativeFunctionDecl": {
            (0, format_declarations_1.formatNativeFunction)(code, node);
            break;
        }
        case "AsmFunction": {
            (0, format_declarations_1.formatAsmFunction)(code, node);
            break;
        }
        case "Contract": {
            (0, format_contracts_1.formatContract)(code, node);
            break;
        }
        case "Trait": {
            (0, format_contracts_1.formatTrait)(code, node);
            break;
        }
        case "StructDecl": {
            (0, format_structs_1.formatStruct)(code, node);
            break;
        }
        case "MessageDecl": {
            (0, format_structs_1.formatMessage)(code, node);
            break;
        }
        case "Constant": {
            (0, format_declarations_1.formatConstant)(code, node);
            break;
        }
        case "Comment": {
            (0, format_comments_1.formatComment)(code, node);
            break;
        }
        case "StatementDestruct":
        case "StatementRepeat":
        case "StatementUntil":
        case "StatementTry":
        case "StatementForEach":
        case "StatementLet":
        case "StatementReturn":
        case "StatementExpression":
        case "StatementAssign":
        case "StatementCondition":
        case "StatementWhile":
        case "StatementBlock": {
            (0, format_statements_1.formatStatement)(code, node, true);
            break;
        }
        default: {
            if (node.group === "expression") {
                (0, format_expressions_1.formatExpression)(code, node);
            }
            else {
                code.add((0, cst_helpers_1.visit)(node).trim());
            }
        }
    }
};
