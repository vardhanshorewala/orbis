"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatStatement = exports.formatStatements = void 0;
const cst_helpers_1 = require("../cst/cst-helpers");
const format_expressions_1 = require("./format-expressions");
const format_types_1 = require("./format-types");
const helpers_1 = require("./helpers");
const format_comments_1 = require("./format-comments");
const formatStatements = (code, node) => {
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    const statements = node.children
        .slice(0, endIndex)
        .filter((it) => it.$ === "node");
    if (statements.length === 0) {
        code.add("{}");
        (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
        return;
    }
    const firstStatement = statements.at(0);
    if (isSingleLineStatement(node) && firstStatement) {
        code.add("{").space();
        (0, exports.formatStatement)(code, firstStatement, false);
        code.space().add("}");
        return;
    }
    // don't add newline, see further comment
    code.add("{");
    // Block may have leading header comments after `{`:
    // ```
    // { // comment
    //   ^^^^^^^^^^ this
    //     let a = 100;
    // }
    // ```
    //
    // This flag tracks when we found the first new line,
    // in which case all further comments are NOT the leading heading
    let seenFirstNewline = false;
    let needNewLine = false;
    let skipNextStatement = false;
    for (let i = 0; i < endIndex; i++) {
        const statement = node.children.at(i);
        if (statement?.$ === "leaf") {
            if (!seenFirstNewline && statement.text.includes("\n")) {
                // add initial new line after `{`
                code.newLine().indent();
                seenFirstNewline = true;
                continue;
            }
            // don't add extra leading line
            if (i !== 1 && (0, helpers_1.containsSeveralNewlines)(statement.text)) {
                needNewLine = true;
                skipNextStatement = false;
            }
            continue;
        }
        if (needNewLine) {
            code.newLine();
            needNewLine = false;
        }
        if (statement?.type === "Comment") {
            if (!seenFirstNewline) {
                // found inline comment after `{`, need to add space before it
                code.space();
            }
            (0, format_comments_1.formatComment)(code, statement);
            if ((0, helpers_1.isIgnoreDirective)(statement)) {
                skipNextStatement = true;
            }
            if (!seenFirstNewline) {
                // don't add new line for inline comment
                continue;
            }
        }
        else if (statement?.group === "statement") {
            if (!seenFirstNewline) {
                // add initial new line after `{`
                code.newLine().indent();
                seenFirstNewline = true;
            }
            if (skipNextStatement) {
                code.add((0, cst_helpers_1.visit)(statement).trim());
            }
            else {
                (0, exports.formatStatement)(code, statement, true);
            }
            const newlines = (0, cst_helpers_1.trailingNewlines)(statement);
            if (newlines > 1) {
                needNewLine = true;
                skipNextStatement = false;
            }
        }
        code.newLine();
    }
    code.dedent().add("}");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
exports.formatStatements = formatStatements;
const formatStatement = (code, node, needSemicolon) => {
    switch (node.type) {
        case "StatementLet": {
            formatLetStatement(code, node, needSemicolon);
            break;
        }
        case "StatementDestruct": {
            formatDestructStatement(code, node, needSemicolon);
            break;
        }
        case "StatementReturn": {
            formatReturnStatement(code, node, needSemicolon);
            break;
        }
        case "StatementExpression": {
            formatExpressionStatement(code, node, needSemicolon);
            break;
        }
        case "StatementAssign": {
            formatAssignStatement(code, node, needSemicolon);
            break;
        }
        case "StatementCondition": {
            formatConditionStatement(code, node);
            break;
        }
        case "StatementWhile": {
            formatWhileStatement(code, node);
            break;
        }
        case "StatementRepeat": {
            formatRepeatStatement(code, node);
            break;
        }
        case "StatementUntil": {
            formatUntilStatement(code, node, needSemicolon);
            break;
        }
        case "StatementTry": {
            formatTryStatement(code, node);
            break;
        }
        case "StatementForEach": {
            formatForEachStatement(code, node);
            break;
        }
        case "StatementBlock": {
            const body = (0, cst_helpers_1.childByField)(node, "body");
            if (body) {
                (0, exports.formatStatements)(code, body);
            }
            break;
        }
        default: {
            throw new Error(`Unsupported statement type: ${node.type}`);
        }
    }
};
exports.formatStatement = formatStatement;
function formatInBetweenComments(code, comments, commentsAndNewlines) {
    if (comments.length > 0) {
        const multiline = (0, helpers_1.multilineComments)(commentsAndNewlines);
        if (multiline) {
            code.indent();
            code.newLine();
        }
        else {
            code.space();
        }
        for (const comment of commentsAndNewlines) {
            if (comment.$ !== "node" || comment.type !== "Comment")
                continue;
            (0, format_comments_1.formatComment)(code, comment);
        }
        if (multiline) {
            code.newLine();
            code.dedent();
        }
        else {
            code.space();
        }
        return true;
    }
    return false;
}
function formatCommentsBetweenAssignAndValue(code, node, assign, init) {
    const commentsAndNewlines = (0, helpers_1.getLeafsBetween)(node, assign, init);
    const comments = (0, cst_helpers_1.filterComments)(commentsAndNewlines);
    return formatInBetweenComments(code, comments, commentsAndNewlines);
}
const formatLetStatement = (code, node, needSemicolon) => {
    // let name : Int = 100;
    //     ^^^^ ^^^^^ ^ ^^^
    //     |    |     | |
    //     |    |     | init
    //     |    |     assign
    //     |    typeOpt
    //     name
    const name = (0, cst_helpers_1.childByField)(node, "name");
    const typeOpt = (0, cst_helpers_1.childByField)(node, "type");
    const init = (0, cst_helpers_1.childByField)(node, "init");
    const assign = (0, cst_helpers_1.childLeafWithText)(node, "=");
    if (!name || !init || !assign) {
        throw new Error("Invalid let statement");
    }
    code.add("let").space().apply(helpers_1.formatId, name);
    if (typeOpt) {
        (0, format_comments_1.formatInlineComments)(node, code, name, typeOpt, true);
        (0, format_types_1.formatAscription)(code, typeOpt);
        (0, format_comments_1.formatInlineComments)(node, code, typeOpt, assign, true);
    }
    else {
        (0, format_comments_1.formatInlineComments)(node, code, name, assign, true);
    }
    code.space().add("=");
    const hasMultilineComment = formatCommentsBetweenAssignAndValue(code, node, assign, init);
    const needIndentAndNewline = multilineExpression(init);
    if (needIndentAndNewline || hasMultilineComment) {
        if (needIndentAndNewline) {
            code.newLine();
        }
        code.indent();
    }
    else {
        code.space();
    }
    (0, format_expressions_1.formatExpression)(code, init);
    code.addIf(needSemicolon, ";");
    if (hasMultilineComment || needIndentAndNewline) {
        code.dedent();
    }
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "init");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const multilineExpression = (expr) => {
    if (expr.type !== "Binary")
        return false;
    const tail = (0, cst_helpers_1.childByField)(expr, "tail");
    if (!tail)
        return false;
    const exprRight = (0, cst_helpers_1.childByField)(expr, "right");
    if (exprRight && exprRight.type !== "Binary") {
        // don't wrap multiline with single binary
        return false;
    }
    if (tail.children.length > 2) {
        return (0, cst_helpers_1.visit)(expr).includes("\n");
    }
    const operator = (0, cst_helpers_1.childByField)(tail, "op");
    if (operator && (0, cst_helpers_1.containsComments)(operator.children)) {
        return true;
    }
    const right = (0, cst_helpers_1.childByField)(tail, "right");
    if (right?.type !== "Binary")
        return false; // don't wrap multiline with single binary
    return (0, cst_helpers_1.visit)(expr).includes("\n");
};
const formatReturnStatement = (code, node, needSemicolon) => {
    // return 100;
    // ^^^^^^ ^^^
    // |      |
    // |      exprOpt
    // |
    // returnKeyword
    const returnKeyword = (0, cst_helpers_1.childLeafWithText)(node, "return");
    if (!returnKeyword) {
        throw new Error("Invalid return statement");
    }
    const exprOpt = (0, cst_helpers_1.childByField)(node, "expression");
    code.add("return");
    if (exprOpt) {
        const hasMultilineComment = formatCommentsBetweenAssignAndValue(code, node, returnKeyword, exprOpt);
        const needIndentAndNewline = multilineExpression(exprOpt);
        if (needIndentAndNewline || hasMultilineComment) {
            if (needIndentAndNewline) {
                code.newLine();
            }
            code.indent();
        }
        else {
            code.space();
        }
        (0, format_expressions_1.formatExpression)(code, exprOpt);
        if (hasMultilineComment || needIndentAndNewline) {
            code.dedent();
        }
    }
    code.addIf(needSemicolon, ";");
    const endIndex = exprOpt ? (0, cst_helpers_1.childIdxByField)(node, "expression") : 0; // index of return
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatExpressionStatement = (code, node, needSemicolon) => {
    // 10;
    // ^^ expression
    const expression = (0, cst_helpers_1.childByField)(node, "expression");
    if (!expression) {
        throw new Error("Invalid expression statement");
    }
    (0, format_expressions_1.formatExpression)(code, expression);
    code.addIf(needSemicolon, ";");
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "expression");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatAssignStatement = (code, node, needSemicolon) => {
    // value += 100;
    // ^^^^^ ^^ ^^^
    // |     |  |
    // |     |  right
    // |     |
    // |     operator
    // left
    const left = (0, cst_helpers_1.childByField)(node, "left");
    const operator = (0, cst_helpers_1.childByField)(node, "operator");
    const right = (0, cst_helpers_1.childByField)(node, "right");
    if (!left || !right || !operator) {
        throw new Error("Invalid assign statement");
    }
    (0, format_expressions_1.formatExpression)(code, left);
    code.space();
    const assign = operator.children.at(0);
    if (assign && assign.$ === "leaf") {
        code.add(assign.text);
    }
    else {
        code.add("=");
    }
    const comments = operator.children
        .filter((it) => it.$ === "node")
        .filter((it) => (0, cst_helpers_1.isComment)(it));
    const hasMultilineComment = formatInBetweenComments(code, comments, operator.children);
    const needIndentAndNewline = multilineExpression(right);
    if (needIndentAndNewline || hasMultilineComment) {
        if (needIndentAndNewline) {
            code.newLine();
        }
        code.indent();
    }
    else {
        code.space();
    }
    (0, format_expressions_1.formatExpression)(code, right);
    code.addIf(needSemicolon, ";");
    if (hasMultilineComment || needIndentAndNewline) {
        code.dedent();
    }
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "right");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatConditionStatement = (code, node) => {
    // if (true) {} else {}
    // ^^ ^^^^^^ ^^ ^^^^^^^
    // |  |      |  |
    // |  |      |  falseBranchOpt
    // |  |      trueBranch
    // |  condition
    // ifKeyword
    const ifKeyword = (0, cst_helpers_1.childLeafWithText)(node, "if");
    const condition = (0, cst_helpers_1.childByField)(node, "condition");
    const trueBranch = (0, cst_helpers_1.childByField)(node, "trueBranch");
    const falseBranchOpt = (0, cst_helpers_1.childByField)(node, "falseBranch");
    if (!condition || !trueBranch || !ifKeyword) {
        throw new Error("Invalid condition statement");
    }
    code.add("if").space();
    (0, format_comments_1.formatInlineComments)(node, code, ifKeyword, condition, false);
    (0, format_expressions_1.formatExpression)(code, condition);
    code.space();
    (0, exports.formatStatements)(code, trueBranch);
    const trueBranchEndIndex = (0, cst_helpers_1.childLeafIdxWithText)(trueBranch, "}");
    const trueBranchLeafs = trueBranch.children.slice(trueBranchEndIndex + 1);
    // if (true) {
    //     ...
    // }
    // // comment here
    // else { ... }
    const trueBranchComments = (0, cst_helpers_1.filterComments)(trueBranchLeafs);
    if (falseBranchOpt) {
        if (isSingleLineStatement(trueBranch) ||
            trueBranchComments.length > 0) {
            // add a new line to format like this:
            // if (true) { return 10 }
            // else { return 20 }
            code.newLine();
        }
        else {
            code.space();
        }
        code.add("else").space();
        const branch = (0, cst_helpers_1.nonLeafChild)(falseBranchOpt);
        if (!branch)
            return;
        if (branch.type === "StatementCondition") {
            formatConditionStatement(code, branch);
        }
        else {
            const body = (0, cst_helpers_1.childByField)(branch, "body");
            if (body) {
                (0, exports.formatStatements)(code, body);
            }
        }
    }
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, falseBranchOpt ? "falseBranch" : "trueBranch");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatWhileStatement = (code, node) => {
    formatLoopStatement(code, node, "while");
};
const formatRepeatStatement = (code, node) => {
    formatLoopStatement(code, node, "repeat");
};
const formatLoopStatement = (code, node, kind) => {
    // while (true) {}
    //        ^^^^  ^^
    //        |     |
    //        |     body
    //        condition
    // or
    // repeat(true) {}
    //        ^^^^  ^^
    //        |     |
    //        |     body
    //        condition
    const condition = (0, cst_helpers_1.childByField)(node, "condition");
    const body = (0, cst_helpers_1.childByField)(node, "body");
    if (!condition || !body) {
        throw new Error("Invalid while statement");
    }
    // prettier-ignore
    code.add(kind).space()
        .apply(format_expressions_1.formatExpression, condition)
        .space()
        .apply(exports.formatStatements, body);
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "body");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatDestructField = (code, field) => {
    if (field.type === "RegularField") {
        // foo: bar
        // ^^^  ^^^
        // |    |
        // |    fieldName
        // varName
        const fieldName = (0, cst_helpers_1.childByField)(field, "fieldName");
        const varName = (0, cst_helpers_1.childByField)(field, "varName");
        if (!fieldName || !varName) {
            throw new Error("Invalid regular field in destruct");
        }
        code.apply(helpers_1.formatId, fieldName)
            .add(":")
            .space()
            .apply(helpers_1.formatId, varName);
    }
    else if (field.type === "PunnedField") {
        // foo
        // ^^^ this
        const name = (0, cst_helpers_1.childByField)(field, "name");
        if (!name) {
            throw new Error("Invalid punned field in destruct");
        }
        code.apply(helpers_1.formatId, name);
    }
};
const formatDestructStatement = (code, node, needSemicolon) => {
    // let Foo { arg, foo: param, .. } = foo();
    //     ^^^   ^^^^^^^^^^^^^^^  ^^   ^ ^^^^^
    //     |     |                |    | |
    //     |     |                |    | init
    //     |     |                |    assign
    //     |     |                restOpt
    //     |     fields
    //     type
    const type = (0, cst_helpers_1.childByField)(node, "type");
    const fields = (0, cst_helpers_1.childByField)(node, "fields");
    const restOpt = (0, cst_helpers_1.childByType)(node, "RestArgument");
    const assign = (0, cst_helpers_1.childLeafWithText)(node, "=");
    const init = (0, cst_helpers_1.childByField)(node, "init");
    if (!type || !fields || !assign || !init) {
        throw new Error("Invalid destruct statement");
    }
    code.add("let").space();
    (0, format_types_1.formatType)(code, type);
    code.space();
    const restArg = restOpt?.type === "RestArgument" ? ".." : undefined;
    (0, helpers_1.formatSeparatedList)(code, fields, formatDestructField, {
        wrapperLeft: "{",
        wrapperRight: "}",
        extraWrapperSpace: " ",
        startIndex: 0,
        endIndex: 0,
        suffixElement: restArg,
        needSeparatorAfterSuffixElement: false, // comma is forbidden after `..`
    });
    code.space().add("=").space();
    (0, format_expressions_1.formatExpression)(code, init);
    code.addIf(needSemicolon, ";");
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "init");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatUntilStatement = (code, node, needSemicolon) => {
    // do {} until (true);
    //    ^^       ^^^^^^
    //    |        |
    //    |        condition
    //    body
    const body = (0, cst_helpers_1.childByField)(node, "body");
    const condition = (0, cst_helpers_1.childByField)(node, "condition");
    if (!body || !condition) {
        throw new Error("Invalid until statement");
    }
    // prettier-ignore
    code.add("do").space()
        .apply(exports.formatStatements, body)
        .space().add("until").space()
        .apply(format_expressions_1.formatExpression, condition)
        .addIf(needSemicolon, ";");
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "condition");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatTryStatement = (code, node) => {
    // try {} catch (e) {}
    //     ^^ ^^^^^^^^^^^^
    //     |  |
    //     |  handlerOpt
    //     body
    const body = (0, cst_helpers_1.childByField)(node, "body");
    const handlerOpt = (0, cst_helpers_1.childByField)(node, "handler");
    if (!body) {
        throw new Error("Invalid try statement");
    }
    code.add("try").space();
    (0, exports.formatStatements)(code, body);
    if (handlerOpt) {
        // catch (e) {}
        //        ^  ^^
        //        |  |
        //        |  handlerBody
        //        name
        const name = (0, cst_helpers_1.childByField)(handlerOpt, "name");
        const handlerBody = (0, cst_helpers_1.childByField)(handlerOpt, "body");
        if (!name || !handlerBody) {
            throw new Error("Invalid catch handler");
        }
        code.space()
            .add("catch")
            .space()
            .add("(")
            .apply(helpers_1.formatId, name)
            .add(")")
            .space();
        (0, exports.formatStatements)(code, handlerBody);
    }
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, handlerOpt ? "handler" : "body");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
const formatForEachStatement = (code, node) => {
    // foreach (key, value in foo()) {}
    //          ^^^  ^^^^^    ^^^^^  ^^
    //          |    |        |      |
    //          |    |        |      body
    //          |    |        expression
    //          |    value
    //          key
    const key = (0, cst_helpers_1.childByField)(node, "key");
    const value = (0, cst_helpers_1.childByField)(node, "value");
    const expression = (0, cst_helpers_1.childByField)(node, "expression");
    const body = (0, cst_helpers_1.childByField)(node, "body");
    if (!key || !value || !expression || !body) {
        throw new Error("Invalid forEach statement");
    }
    code.add("foreach").space().add("(");
    code.apply(helpers_1.formatId, key)
        .add(",")
        .space()
        .apply(helpers_1.formatId, value)
        .space()
        .add("in")
        .space();
    (0, format_expressions_1.formatExpression)(code, expression);
    code.add(")").space();
    (0, exports.formatStatements)(code, body);
    const endIndex = (0, cst_helpers_1.childIdxByField)(node, "body");
    (0, format_comments_1.formatTrailingComments)(code, node, endIndex, true);
};
function isSemicolonStatement(node) {
    return (node.type === "StatementLet" ||
        node.type === "StatementDestruct" ||
        node.type === "StatementReturn" ||
        node.type === "StatementExpression" ||
        node.type === "StatementAssign" ||
        node.type === "StatementUntil");
}
function canBeSingleLine(node) {
    const hasInlineComments = node.children.some((it) => (0, cst_helpers_1.isInlineComment)(it));
    if (hasInlineComments) {
        return false;
    }
    if (node.type === "StatementUntil") {
        return false;
    }
    if (node.type === "StatementReturn") {
        const expr = (0, cst_helpers_1.childByField)(node, "expression");
        if (expr && expr.type === "StructInstance") {
            return false;
        }
    }
    const multiline = (0, cst_helpers_1.visit)(node).trim().includes("\n");
    return !multiline;
}
function isSingleLineStatement(node) {
    const endIndex = (0, cst_helpers_1.childLeafIdxWithText)(node, "}");
    const statements = node.children
        .slice(0, endIndex)
        .filter((it) => it.$ === "node");
    if (statements.length === 0) {
        return false;
    }
    const comments = (0, cst_helpers_1.filterComments)(statements);
    const firstStatement = statements[0];
    return (statements.length === 1 &&
        typeof firstStatement !== "undefined" &&
        (0, cst_helpers_1.childLeafWithText)(firstStatement, ";") === undefined &&
        isSemicolonStatement(firstStatement) &&
        canBeSingleLine(firstStatement) &&
        comments.length === 0);
}
