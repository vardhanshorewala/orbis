"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatId = exports.idText = exports.getLeafsBetween = exports.getCommentsBetween = exports.formatSeparatedList = void 0;
exports.declName = declName;
exports.containsSeveralNewlines = containsSeveralNewlines;
exports.multilineComments = multilineComments;
exports.isIgnoreDirective = isIgnoreDirective;
exports.hasIgnoreDirective = hasIgnoreDirective;
const cst_helpers_1 = require("../cst/cst-helpers");
const format_comments_1 = require("./format-comments");
function collectListInfo(node, startIndex, endIndex) {
    const result = [];
    let currentItem = null;
    let wasComma = false;
    const listInlineLeadingComments = [];
    const listLeadingComments = [];
    let leadingComments = [];
    let inLeadingComments = true;
    let shouldBeMultiline = false;
    let i = startIndex;
    let processList = node.children.slice(0, endIndex === 0 ? node.children.length : endIndex);
    let wasInitialNewline = false;
    while (i < processList.length) {
        const child = processList.at(i);
        if (typeof child === "undefined") {
            i++;
            continue;
        }
        if (child.$ === "leaf") {
            if (child.text === ",") {
                wasComma = true;
            }
            else if (child.text.includes("\n")) {
                if (currentItem && containsSeveralNewlines(child.text)) {
                    currentItem.hasTrailingNewline = true;
                }
                if (leadingComments.length > 0) {
                    // @ts-expect-error TS2532
                    leadingComments[leadingComments.length - 1].hasNewline =
                        true;
                }
                else if (listLeadingComments.length > 0 &&
                    inLeadingComments) {
                    // @ts-expect-error TS2532
                    listLeadingComments[listLeadingComments.length - 1].hasNewline = true;
                }
                if (currentItem && wasComma) {
                    result.push(currentItem);
                    currentItem = null;
                    wasComma = false;
                }
                shouldBeMultiline = true;
                wasInitialNewline = true;
            }
        }
        else if (child.type === "Comment") {
            const commentWithNewline = {
                node: child,
                hasNewline: false,
            };
            if (currentItem) {
                currentItem.trailingComments.push(commentWithNewline);
            }
            else if (result.length === 0) {
                if (wasInitialNewline) {
                    listLeadingComments.push(commentWithNewline);
                }
                else {
                    listInlineLeadingComments.push(commentWithNewline);
                }
            }
            else {
                leadingComments.push(commentWithNewline);
            }
        }
        else {
            if (child.type === "tail" || child.type === "fields") {
                processList = child.children;
                i = 0;
                continue;
            }
            if (currentItem) {
                result.push(currentItem);
                currentItem = null;
                leadingComments = [];
            }
            currentItem = {
                item: child,
                leadingComments: leadingComments,
                trailingComments: [],
                hasLeadingNewline: leadingComments.some((c) => c.hasNewline) ||
                    (result.length > 0 &&
                        (result.at(-1)?.hasTrailingNewline ?? false)),
                hasTrailingNewline: false,
            };
            leadingComments = [];
            inLeadingComments = false;
        }
        i++;
    }
    if (currentItem) {
        result.push(currentItem);
    }
    return {
        items: result,
        shouldBeMultiline,
        leadingComments: listLeadingComments,
        inlineLeadingComments: listInlineLeadingComments,
        trailingComments: leadingComments,
    };
}
const formatSeparatedList = (code, node, formatItem, options = {}) => {
    const { wrapperLeft = "(", wrapperRight = ")", separator = ",", startIndex = 1, endIndex = -1, extraWrapperSpace, suffixElement, spaceBeforeIfNotMultiline, needSeparatorAfterSuffixElement, } = options;
    const info = collectListInfo(node, startIndex, endIndex);
    const items = info.items;
    const shouldBeMultiline = info.shouldBeMultiline;
    if (!shouldBeMultiline && spaceBeforeIfNotMultiline) {
        code.add(" ");
    }
    code.add(wrapperLeft);
    if (shouldBeMultiline) {
        if (info.inlineLeadingComments.length > 0) {
            code.space();
            for (const comment of info.inlineLeadingComments) {
                (0, format_comments_1.formatComment)(code, comment.node);
            }
        }
        code.newLine().indent();
        for (const comment of info.leadingComments) {
            (0, format_comments_1.formatComment)(code, comment.node);
            if (comment.hasNewline) {
                code.newLine();
            }
        }
        for (const item of items) {
            for (const comment of item.leadingComments) {
                (0, format_comments_1.formatComment)(code, comment.node);
                if (comment.hasNewline) {
                    code.newLine();
                }
                else {
                    code.space();
                }
            }
            if (item.item.$ === "node") {
                formatItem(code, item.item);
            }
            code.add(separator);
            if (item.hasTrailingNewline) {
                code.newLine();
            }
            const trailingComments = [
                ...(options.provideTrailingComments?.(item.item) ?? []),
                ...item.trailingComments.map((it) => it.node),
            ];
            if (trailingComments.length > 0) {
                code.space();
            }
            trailingComments.forEach((comment, index) => {
                (0, format_comments_1.formatComment)(code, comment);
                if (index !== trailingComments.length - 1) {
                    code.newLine();
                }
            });
            code.newLine();
        }
        if (suffixElement) {
            code.add(suffixElement);
            if (needSeparatorAfterSuffixElement) {
                code.add(separator);
            }
            code.newLine();
        }
        if (info.trailingComments.length > 0) {
            info.trailingComments.forEach((comment, index) => {
                (0, format_comments_1.formatComment)(code, comment.node);
                if (comment.hasNewline ||
                    index === info.trailingComments.length - 1) {
                    code.newLine();
                }
            });
        }
        code.dedent().add(wrapperRight);
    }
    else {
        if (items.length > 0 && extraWrapperSpace) {
            code.add(extraWrapperSpace);
        }
        if (info.inlineLeadingComments.length > 0) {
            for (const comment of info.inlineLeadingComments) {
                (0, format_comments_1.formatComment)(code, comment.node);
                code.space();
            }
        }
        for (const comment of info.leadingComments) {
            (0, format_comments_1.formatComment)(code, comment.node);
            if (comment.hasNewline) {
                code.newLine();
            }
            else {
                code.space();
            }
        }
        items.forEach((item, index) => {
            if (item.item.$ === "node") {
                formatItem(code, item.item);
            }
            if (index < items.length - 1) {
                code.add(separator).space();
            }
        });
        if (suffixElement) {
            code.add(separator).space().add(suffixElement);
        }
        if (items.length > 0 && extraWrapperSpace) {
            code.add(extraWrapperSpace);
        }
        code.add(wrapperRight);
    }
};
exports.formatSeparatedList = formatSeparatedList;
const getCommentsBetween = (node, startNode, endNode) => {
    const startIndex = startNode ? node.children.indexOf(startNode) : -1;
    const endIndex = endNode
        ? node.children.indexOf(endNode)
        : node.children.length;
    return node.children.filter((child, childIndex) => {
        if (child.$ !== "node" || child.type !== "Comment")
            return false;
        return childIndex > startIndex && childIndex < endIndex;
    });
};
exports.getCommentsBetween = getCommentsBetween;
const getLeafsBetween = (node, startNode, endNode) => {
    const startIndex = startNode ? node.children.indexOf(startNode) : -1;
    const endIndex = endNode
        ? node.children.indexOf(endNode)
        : node.children.length;
    return node.children.filter((_, childIndex) => childIndex > startIndex && childIndex < endIndex);
};
exports.getLeafsBetween = getLeafsBetween;
// name: Id
//   name: name
//      "some"
const idText = (node) => {
    const name = (0, cst_helpers_1.childByField)(node, "name");
    if (!name)
        return "";
    const child = name.children.at(0);
    if (!child)
        return "";
    return (0, cst_helpers_1.visit)(child);
};
exports.idText = idText;
const formatId = (code, node) => {
    if (node.$ === "leaf")
        return;
    const name = (0, exports.idText)(node);
    code.add(name);
    (0, format_comments_1.formatTrailingComments)(code, node, 0, true);
};
exports.formatId = formatId;
function declName(node) {
    const name = (0, cst_helpers_1.childByField)(node, "name");
    if (!name || (name.type !== "TypeId" && name.type !== "Id")) {
        throw new Error(`Invalid name`);
    }
    return (0, exports.idText)(name);
}
function containsSeveralNewlines(text) {
    const index = text.indexOf("\n");
    if (index === -1) {
        return false;
    }
    return text.slice(index + 1).includes("\n");
}
function multilineComments(comments) {
    return comments.some((it) => (0, cst_helpers_1.visit)(it).includes("\n"));
}
function isIgnoreDirective(statement) {
    return (0, cst_helpers_1.commentText)(statement).startsWith("fmt-ignore");
}
function hasIgnoreDirective(declaration) {
    const doc = (0, cst_helpers_1.childByField)(declaration, "doc");
    if (!doc)
        return false;
    const comments = (0, cst_helpers_1.filterComments)(doc.children);
    return comments.some((it) => isIgnoreDirective(it));
}
