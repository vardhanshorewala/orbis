import type { SrcInfo } from "../grammar";
import type * as Ast from "../ast/ast";
import type { ExpressionTransformer } from "./types";
import { Rule } from "./types";
import type { AstUtil } from "../ast/util";
type TransformData = {
    simplifiedExpression: Ast.Expression;
    safetyCondition: boolean;
};
type Transform = (x1: Ast.Expression, c1: Ast.Literal, c2: Ast.Literal, util: AstUtil, s: SrcInfo) => TransformData;
declare abstract class AssociativeRewriteRule extends Rule {
    private associativeOps;
    private commutativeOps;
    constructor();
    areAssociative(op1: Ast.BinaryOperation, op2: Ast.BinaryOperation): boolean;
    isCommutative(op: Ast.BinaryOperation): boolean;
}
declare abstract class AllowableOpRule extends AssociativeRewriteRule {
    private allowedOps;
    constructor();
    isAllowedOp(op: Ast.BinaryOperation): boolean;
    areAllowedOps(op: Ast.BinaryOperation[]): boolean;
}
export declare class AssociativeRule1 extends AllowableOpRule {
    applyRule(ast: Ast.Expression, { applyRules, util }: ExpressionTransformer): Ast.Expression;
}
export declare class AssociativeRule2 extends AllowableOpRule {
    applyRule(ast: Ast.Expression, { applyRules, util }: ExpressionTransformer): Ast.Expression;
}
export declare class AssociativeRule3 extends Rule {
    private leftAssocTransforms;
    private rightAssocTransforms;
    private rightCommuteTransforms;
    private leftCommuteTransforms;
    private standardAdditiveCondition;
    private shiftedAdditiveCondition;
    private oppositeAdditiveCondition;
    private standardMultiplicativeCondition;
    constructor();
    private lookupTransform;
    protected getLeftAssociativityTransform(keyOp1: Ast.BinaryOperation, keyOp2: Ast.BinaryOperation): Transform | undefined;
    protected getRightAssociativityTransform(keyOp1: Ast.BinaryOperation, keyOp2: Ast.BinaryOperation): Transform | undefined;
    protected getLeftCommutativityTransform(keyOp1: Ast.BinaryOperation, keyOp2: Ast.BinaryOperation): Transform | undefined;
    protected getRightCommutativityTransform(keyOp1: Ast.BinaryOperation, keyOp2: Ast.BinaryOperation): Transform | undefined;
    applyRule(ast: Ast.Expression, { applyRules, util }: ExpressionTransformer): Ast.Expression;
}
export {};
