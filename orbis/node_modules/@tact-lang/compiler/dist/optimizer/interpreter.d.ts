import { type DictionaryKey, type DictionaryKeyTypes, type DictionaryValue } from "@ton/core";
import type * as Ast from "../ast/ast";
import { CompilerContext } from "../context/context";
import type { AstUtil } from "../ast/util";
import { type Parser, type SrcInfo } from "../grammar";
import type { FactoryAst } from "../ast/ast-helpers";
import { type MapSerializerDescrKey, type MapSerializerDescrValue } from "../bindings/typescript/serializers";
export declare function throwNonFatalErrorConstEval(msg: string, source: SrcInfo): never;
type EvalResult = {
    kind: "ok";
    value: Ast.Literal;
} | {
    kind: "error";
    message: string;
};
export declare function ensureInt(val: Ast.Expression): Ast.Number;
export declare function ensureBoolean(val: Ast.Expression): Ast.Boolean;
export declare function ensureString(val: Ast.Expression): Ast.String;
export declare function evalUnaryOp(op: Ast.UnaryOperation, valOperand: Ast.Literal, source: SrcInfo, util: AstUtil): Ast.Literal;
export declare function evalBinaryOp(op: Ast.BinaryOperation, valLeft: Ast.Literal, valRightContinuation: () => Ast.Literal, // It needs to be a continuation, because some binary operators short-circuit
source: SrcInfo, util: AstUtil): Ast.Literal;
export type InterpreterConfig = {
    maxLoopIterations: bigint;
};
export declare function parseAndEvalExpression(sourceCode: string, ast?: FactoryAst, parser?: Parser, util?: AstUtil): EvalResult;
type KeyExist = <R>(cb: <K extends DictionaryKeyTypes>(type: DictionaryKey<K>, parse: (value: Ast.Literal, keyExprLoc: SrcInfo) => K) => R) => R;
type ValueExist = <R>(cb: <V>(type: DictionaryValue<V>, parse: (value: Ast.Literal, valueExprLoc: SrcInfo) => V) => R) => R;
export declare class Interpreter {
    private envStack;
    private context;
    /**
     * Stores all visited constants during the current computation.
     */
    private visitedConstants;
    /**
     * Stores all constants that were calculated during the computation of some constant,
     * and the functions that were called for this process.
     * Used only in case of circular dependencies to return a clear error.
     */
    private constantComputationPath;
    private config;
    private util;
    constructor(util: AstUtil, context?: CompilerContext, config?: InterpreterConfig);
    /**
     * This is the public access for expression interpretation.
     * @param ast Expression to interpret.
     */
    interpretExpression(expr: Ast.Expression): Ast.Literal;
    /**
     * This is the public access for statement interpretation.
     * @param stmt Statement to interpret.
     */
    interpretStatement(stmt: Ast.Statement): void;
    /**
     * This is the public access for module item interpretation.
     * @param modItem Module item to interpret.
     */
    interpretModuleItem(modItem: Ast.ModuleItem): void;
    private interpretModuleItemInternal;
    private interpretConstantDef;
    private interpretFunctionDef;
    private interpretStructDecl;
    private interpretMessageDecl;
    private interpretPrimitiveTypeDecl;
    private interpretFunctionDecl;
    private interpretContract;
    private interpretTrait;
    private interpretExpressionInternal;
    private interpretName;
    private interpretMethodCall;
    private interpretInitOf;
    private interpretCodeOf;
    private interpretNull;
    private interpretBoolean;
    private interpretNumber;
    private interpretString;
    private interpretAddress;
    private interpretCell;
    private interpretSlice;
    private interpretUnaryOp;
    private interpretBinaryOp;
    private interpretConditional;
    private interpretStructInstance;
    private interpretStructValue;
    private interpretMapValue;
    private interpretMapLiteral;
    getKeyParser(src: MapSerializerDescrKey): KeyExist;
    getValueParser(src: MapSerializerDescrValue): ValueExist;
    private interpretFieldAccess;
    private interpretStaticCall;
    private parseTonBuiltinValue;
    private evalStaticFunction;
    private interpretStatementInternal;
    private interpretLetStatement;
    private interpretDestructStatement;
    private interpretAssignStatement;
    private interpretAugmentedAssignStatement;
    private interpretConditionStatement;
    private interpretExpressionStatement;
    private interpretForEachStatement;
    private interpretRepeatStatement;
    private interpretReturnStatement;
    private interpretTryStatement;
    private interpretUntilStatement;
    private interpretWhileStatement;
    private interpretBlockStatement;
    private inComputationPath;
    private formatComputationPath;
    private handleStackOverflow;
}
export {};
