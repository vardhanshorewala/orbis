"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evalComptimeExpressions = evalComptimeExpressions;
const iterators_1 = require("../ast/iterators");
const util_1 = require("../ast/util");
const errors_1 = require("../error/errors");
const constEval_1 = require("../optimizer/constEval");
const interpreter_1 = require("../optimizer/interpreter");
const crc16_1 = require("../utils/crc16");
const resolveDescriptors_1 = require("./resolveDescriptors");
function initializeConstants(constants, ctx, util) {
    for (const constant of constants) {
        if (constant.ast.kind === "constant_def") {
            constant.value ??= (0, constEval_1.evalConstantExpression)(constant.ast.initializer, ctx, util);
        }
    }
}
function evalComptimeExpressions(ctx, astF) {
    const util = (0, util_1.getAstUtil)(astF);
    const staticConstants = (0, resolveDescriptors_1.getAllStaticConstants)(ctx);
    for (const aggregateTy of (0, resolveDescriptors_1.getAllTypes)(ctx)) {
        switch (aggregateTy.kind) {
            case "primitive_type_decl":
                break;
            case "trait":
            case "contract":
            case "struct": {
                {
                    for (const field of aggregateTy.fields) {
                        if (field.ast.initializer !== undefined) {
                            field.default ??= (0, constEval_1.evalConstantExpression)(field.ast.initializer, ctx, util);
                        }
                        else {
                            // if a field has optional type and it is missing an explicit initializer
                            // we consider it to be initialized with the null value
                            field.default =
                                field.type.kind === "ref" && field.type.optional
                                    ? util.makeNullLiteral(field.ast.loc)
                                    : undefined;
                        }
                    }
                    // Initialize constants after fields to ensure default struct fields can be used in constants, like
                    // struct S {f: Int = 42}
                    // const A: Int = S{}.f;
                    initializeConstants(aggregateTy.constants, ctx, util);
                }
                break;
            }
        }
    }
    // We initialize all remaining uninitialized constants,
    // the constant may already be initialized since we call initialization recursively
    // if one constant depends on another
    initializeConstants(staticConstants, ctx, util);
    // Evaluate getter method IDs and check for collisions
    for (const t of (0, resolveDescriptors_1.getAllTypes)(ctx)) {
        const methodIds = new Map();
        for (const f of t.functions.values()) {
            if (f.ast.kind !== "native_function_decl" &&
                f.ast.kind !== "function_decl" &&
                f.ast.kind !== "asm_function_def" &&
                f.isGetter) {
                const methodId = getMethodId(f, ctx, util);
                const existing = methodIds.get(methodId);
                if (existing) {
                    (0, errors_1.throwCompilationError)(`Method ID collision: getter '${f.name}' has the same method ID ${methodId} as getter '${existing}'\nPick a different getter name or explicit method ID to avoid collisions`, f.ast.name.loc);
                }
                else {
                    f.methodId = methodId;
                    methodIds.set(methodId, f.name);
                }
            }
        }
    }
    // FIXME: We need to do this hack to check shift operators. The code in the callback function checkShiftOperators
    // was previously in resolveExpressions.
    // Remove these calls to traverse and function checkShiftOperators once the partial evaluator is active.
    (0, resolveDescriptors_1.getAllStaticFunctions)(ctx).forEach((fDesc) => {
        (0, iterators_1.traverse)(fDesc.ast, (n) => {
            checkShiftOperators(ctx, util, n);
        });
    });
    for (const t of (0, resolveDescriptors_1.getAllTypes)(ctx)) {
        if (t.init) {
            (0, iterators_1.traverse)(t.init.ast, (n) => {
                checkShiftOperators(ctx, util, n);
            });
        }
        t.functions.forEach((fDesc) => {
            (0, iterators_1.traverse)(fDesc.ast, (n) => {
                checkShiftOperators(ctx, util, n);
            });
        });
        t.receivers.forEach((rDesc) => {
            (0, iterators_1.traverse)(rDesc.ast, (n) => {
                checkShiftOperators(ctx, util, n);
            });
        });
    }
}
function checkMethodId(methodId, loc) {
    // method ids are 19-bit signed integers
    if (methodId < -(2n ** 18n) || methodId >= 2n ** 18n) {
        (0, errors_1.throwConstEvalError)("method ids must fit 19-bit signed integer range", true, loc);
    }
    // method ids -4, -3, -2, -1, 0 ... 2^14 - 1 (inclusive) are kind of reserved by TVM
    // for the upper bound see F12_n (CALL) TVM instruction
    // and many small ids will be taken by internal procedures
    //
    // also, some ids are taken by the getters generated by Tact:
    // supported_interfaces -> 113617
    // lazy_deployment_completed -> 115390
    // get_abi_ipfs -> 121275
    if (-4n <= methodId && methodId < 2n ** 14n) {
        (0, errors_1.throwConstEvalError)("method ids cannot overlap with the TVM reserved ids: -4, -3, -2, -1, 0 ... 2^14 - 1", true, loc);
    }
    const tactGeneratedGetterMethodIds = [113617n, 115390n, 121275n];
    if (tactGeneratedGetterMethodIds.includes(methodId)) {
        (0, errors_1.throwConstEvalError)(`method ids cannot overlap with Tact reserved method ids: ${tactGeneratedGetterMethodIds.map((n) => n.toString()).join(", ")}`, true, loc);
    }
}
function getMethodId(funcDescr, ctx, util) {
    const optMethodId = funcDescr.ast.attributes.find((attr) => attr.type === "get")?.methodId;
    if (optMethodId) {
        const methodId = (0, interpreter_1.ensureInt)((0, constEval_1.evalConstantExpression)(optMethodId, ctx, util)).value;
        checkMethodId(methodId, optMethodId.loc);
        return Number(methodId);
    }
    else {
        const methodId = ((0, crc16_1.crc16)(funcDescr.name) & 0xffff) | 0x10000;
        checkMethodId(BigInt(methodId), funcDescr.ast.loc);
        return methodId;
    }
}
function checkShiftOperators(ctx, util, ast) {
    // poor man's constant propagation analysis (very local)
    // it works only in the case when the right-hand side is a constant expression
    // and does not have any variables
    if (ast.kind !== "op_binary") {
        return;
    }
    if (ast.op !== ">>" && ast.op !== "<<") {
        return;
    }
    try {
        const valBits = (0, interpreter_1.ensureInt)((0, constEval_1.evalConstantExpression)(ast.right, ctx, util));
        if (0n > valBits.value || valBits.value > 256n) {
            (0, errors_1.throwCompilationError)(`the number of bits shifted ('${valBits.value}') must be within [0..256] range`, ast.right.loc);
        }
    }
    catch (error) {
        if (!(error instanceof errors_1.TactConstEvalError)) {
            throw error;
        }
    }
}
