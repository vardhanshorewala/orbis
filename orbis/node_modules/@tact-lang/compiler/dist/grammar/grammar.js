"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.typePrimary = exports.TypeRegular = exports.TypeGeneric = exports.TypeOptional = exports.ascription = exports.$type = exports.TypeAs = exports.assemblySequence = exports.assemblyItem = exports.Comment = exports.assembly = exports.receiverParam = exports.StringLiteral = exports.Parameter = exports.ReceiverType = exports.GetAttribute = exports.FunctionAttribute = exports.ContractAttribute = exports.inheritedTraits = exports.commaList = exports.keyword = exports.structFields = exports.inter = exports.ConstantDeclaration = exports.ConstantDefinition = exports.ConstantAttribute = exports.shuffle = exports.IntegerLiteralDec = exports.Id = exports.FunctionDeclaration = exports.FunctionDefinition = exports.traitItemDecl = exports.contractItemDecl = exports.storageVar = exports.semicolon = exports.FieldDecl = exports.Receiver = exports.ContractInit = exports.moduleItem = exports.Trait = exports.Contract = exports.MessageDecl = exports.StructDecl = exports.Constant = exports.NativeFunctionDecl = exports.AsmFunction = exports.$Function = exports.PrimitiveTypeDecl = exports.Import = exports.Module = void 0;
exports.SetLiteral = exports.MapLiteral = exports.Parens = exports.suffix = exports.SuffixFieldAccess = exports.SuffixCall = exports.SuffixUnboxNotNull = exports.Operator = exports.Suffix = exports.or = exports.and = exports.bitwiseOr = exports.bitwiseXor = exports.bitwiseAnd = exports.equality = exports.compare = exports.bitwiseShift = exports.add = exports.mul = exports.Unary = exports.Binary = exports.expression = exports.Conditional = exports.optionalRest = exports.NoRestArgument = exports.RestArgument = exports.destructItem = exports.PunnedField = exports.RegularField = exports.FalseBranch = exports.augmentedOp = exports.statements = exports.statement = exports.StatementAssign = exports.StatementExpression = exports.StatementForEach = exports.StatementTry = exports.StatementUntil = exports.StatementRepeat = exports.StatementWhile = exports.StatementCondition = exports.StatementReturn = exports.StatementBlock = exports.StatementDestruct = exports.StatementLet = exports.typeArgs = exports.generic = exports.TypeId = exports.Bounced = exports.MapKeyword = void 0;
exports.JustImports = exports.singleLineComment = exports.multiLineComment = exports.space = exports.reservedWord = exports.escapeChar = exports.hexDigit = exports.FuncId = exports.idPart = exports.digit = exports.underscored = exports.IntegerLiteralOct = exports.IntegerLiteralBin = exports.IntegerLiteralHex = exports.ParameterList = exports.StructFieldInitializer = exports.mapField = exports.StructInstanceFields = exports.parens = exports.primary = exports.Null = exports.CodeOf = exports.InitOf = exports.BoolLiteral = exports.IntegerLiteral = exports.StructInstance = void 0;
/* Generated. Do not edit. */
/* eslint-disable @typescript-eslint/no-namespace */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-redundant-type-constituents */
/* eslint-disable @typescript-eslint/no-duplicate-type-constituents */
/* eslint-disable @typescript-eslint/no-unused-vars */
const $ = __importStar(require("@tonstudio/parser-runtime"));
exports.Module = $.loc($.field($.pure("Module"), "$", $.field($.star($.lazy(() => exports.Import)), "imports", $.field($.star($.lazy(() => exports.moduleItem)), "items", $.eps))));
exports.Import = $.loc($.field($.pure("Import"), "$", $.right($.lazy(() => (0, exports.keyword)($.str("import"))), $.field($.lazy(() => exports.StringLiteral), "path", $.right($.str(";"), $.eps)))));
exports.PrimitiveTypeDecl = $.loc($.field($.pure("PrimitiveTypeDecl"), "$", $.right($.lazy(() => (0, exports.keyword)($.str("primitive"))), $.field($.lazy(() => exports.TypeId), "name", $.right($.str(";"), $.eps)))));
exports.$Function = $.loc($.field($.pure("Function"), "$", $.field($.star($.lazy(() => exports.FunctionAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("fun"))), $.field($.lazy(() => exports.Id), "name", $.field($.lazy(() => (0, exports.ParameterList)($.lazy(() => exports.Parameter))), "parameters", $.field($.opt($.lazy(() => exports.ascription)), "returnType", $.field($.alt($.lazy(() => exports.FunctionDefinition), $.lazy(() => exports.FunctionDeclaration)), "body", $.eps))))))));
exports.AsmFunction = $.loc($.field($.pure("AsmFunction"), "$", $.right($.str("asm"), $.field($.opt($.lazy(() => exports.shuffle)), "shuffle", $.field($.star($.lazy(() => exports.FunctionAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("fun"))), $.field($.lazy(() => exports.Id), "name", $.field($.lazy(() => (0, exports.ParameterList)($.lazy(() => exports.Parameter))), "parameters", $.field($.opt($.lazy(() => exports.ascription)), "returnType", $.right($.str("{"), $.field($.lazy(() => exports.assembly), "instructions", $.right($.str("}"), $.eps))))))))))));
exports.NativeFunctionDecl = $.loc($.field($.pure("NativeFunctionDecl"), "$", $.right($.str("@name"), $.right($.str("("), $.field($.lex($.lazy(() => exports.FuncId)), "nativeName", $.right($.str(")"), $.field($.star($.lazy(() => exports.FunctionAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("native"))), $.field($.lazy(() => exports.Id), "name", $.field($.lazy(() => (0, exports.ParameterList)($.lazy(() => exports.Parameter))), "parameters", $.field($.opt($.lazy(() => exports.ascription)), "returnType", $.right($.str(";"), $.eps))))))))))));
exports.Constant = $.loc($.field($.pure("Constant"), "$", $.field($.star($.lazy(() => exports.ConstantAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("const"))), $.field($.lazy(() => exports.Id), "name", $.field($.lazy(() => exports.ascription), "type", $.field($.alt($.lazy(() => exports.ConstantDefinition), $.lazy(() => exports.ConstantDeclaration)), "body", $.eps)))))));
exports.StructDecl = $.loc($.field($.pure("StructDecl"), "$", $.right($.str("struct"), $.field($.lazy(() => exports.TypeId), "name", $.right($.str("{"), $.field($.lazy(() => exports.structFields), "fields", $.right($.str("}"), $.eps)))))));
exports.MessageDecl = $.loc($.field($.pure("MessageDecl"), "$", $.right($.str("message"), $.field($.opt($.right($.str("("), $.left($.lazy(() => exports.expression), $.str(")")))), "opcode", $.field($.lazy(() => exports.TypeId), "name", $.right($.str("{"), $.field($.lazy(() => exports.structFields), "fields", $.right($.str("}"), $.eps))))))));
exports.Contract = $.loc($.field($.pure("Contract"), "$", $.field($.star($.lazy(() => exports.ContractAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("contract"))), $.field($.lazy(() => exports.Id), "name", $.field($.opt($.lazy(() => (0, exports.ParameterList)($.lazy(() => exports.Parameter)))), "parameters", $.field($.opt($.lazy(() => exports.inheritedTraits)), "traits", $.right($.str("{"), $.field($.star($.lazy(() => exports.contractItemDecl)), "declarations", $.right($.str("}"), $.eps))))))))));
exports.Trait = $.loc($.field($.pure("Trait"), "$", $.field($.star($.lazy(() => exports.ContractAttribute)), "attributes", $.right($.lazy(() => (0, exports.keyword)($.str("trait"))), $.field($.lazy(() => exports.Id), "name", $.field($.opt($.lazy(() => exports.inheritedTraits)), "traits", $.right($.str("{"), $.field($.star($.lazy(() => exports.traitItemDecl)), "declarations", $.right($.str("}"), $.eps)))))))));
exports.moduleItem = $.alt(exports.PrimitiveTypeDecl, $.alt(exports.$Function, $.alt(exports.AsmFunction, $.alt(exports.NativeFunctionDecl, $.alt(exports.Constant, $.alt(exports.StructDecl, $.alt(exports.MessageDecl, $.alt(exports.Contract, exports.Trait))))))));
exports.ContractInit = $.loc($.field($.pure("ContractInit"), "$", $.right($.str("init"), $.field($.lazy(() => (0, exports.ParameterList)($.lazy(() => exports.Parameter))), "parameters", $.field($.lazy(() => exports.statements), "body", $.eps)))));
exports.Receiver = $.loc($.field($.pure("Receiver"), "$", $.field($.lazy(() => exports.ReceiverType), "type", $.right($.str("("), $.field($.lazy(() => exports.receiverParam), "param", $.right($.str(")"), $.field($.lazy(() => exports.statements), "body", $.eps)))))));
exports.FieldDecl = $.loc($.field($.pure("FieldDecl"), "$", $.field($.lazy(() => exports.Id), "name", $.field($.lazy(() => exports.ascription), "type", $.field($.opt($.right($.str("="), $.lazy(() => exports.expression))), "expression", $.eps)))));
exports.semicolon = $.alt($.str(";"), $.lookPos($.str("}")));
exports.storageVar = $.left(exports.FieldDecl, exports.semicolon);
exports.contractItemDecl = $.alt(exports.ContractInit, $.alt(exports.Receiver, $.alt(exports.$Function, $.alt(exports.AsmFunction, $.alt(exports.Constant, exports.storageVar)))));
exports.traitItemDecl = $.alt(exports.Receiver, $.alt(exports.$Function, $.alt(exports.AsmFunction, $.alt(exports.Constant, exports.storageVar))));
exports.FunctionDefinition = $.loc($.field($.pure("FunctionDefinition"), "$", $.field($.lazy(() => exports.statements), "body", $.eps)));
exports.FunctionDeclaration = $.loc($.field($.pure("FunctionDeclaration"), "$", $.right(exports.semicolon, $.eps)));
exports.Id = $.named("identifier", $.loc($.field($.pure("Id"), "$", $.field($.lex($.stry($.right($.lookNeg($.lazy(() => exports.reservedWord)), $.right($.regex("a-zA-Z_", [$.ExpRange("a", "z"), $.ExpRange("A", "Z"), $.ExpString("_")]), $.right($.star($.lazy(() => exports.idPart)), $.eps))))), "name", $.eps))));
exports.IntegerLiteralDec = $.loc($.field($.pure("IntegerLiteralDec"), "$", $.field($.lex($.lazy(() => (0, exports.underscored)($.lazy(() => exports.digit)))), "digits", $.eps)));
exports.shuffle = $.right($.str("("), $.field($.star(exports.Id), "ids", $.field($.opt($.right($.str("->"), $.plus(exports.IntegerLiteralDec))), "to", $.right($.str(")"), $.eps))));
exports.ConstantAttribute = $.loc($.field($.pure("ConstantAttribute"), "$", $.field($.alt($.lazy(() => (0, exports.keyword)($.str("virtual"))), $.alt($.lazy(() => (0, exports.keyword)($.str("override"))), $.lazy(() => (0, exports.keyword)($.str("abstract"))))), "name", $.eps)));
exports.ConstantDefinition = $.loc($.field($.pure("ConstantDefinition"), "$", $.right($.str("="), $.field($.lazy(() => exports.expression), "expression", $.right(exports.semicolon, $.eps)))));
exports.ConstantDeclaration = $.loc($.field($.pure("ConstantDeclaration"), "$", $.right(exports.semicolon, $.eps)));
const inter = (A, B) => $.field($.lazy(() => A), "head", $.field($.star($.field($.lazy(() => B), "op", $.field($.lazy(() => A), "right", $.eps))), "tail", $.eps));
exports.inter = inter;
exports.structFields = $.left($.opt((0, exports.inter)(exports.FieldDecl, $.str(";"))), $.opt($.str(";")));
const keyword = (T) => $.lex($.left($.lazy(() => T), $.lookNeg($.lazy(() => exports.idPart))));
exports.keyword = keyword;
const commaList = (T) => $.left((0, exports.inter)($.lazy(() => T), $.str(",")), $.opt($.str(",")));
exports.commaList = commaList;
exports.inheritedTraits = $.right((0, exports.keyword)($.str("with")), (0, exports.commaList)(exports.Id));
exports.ContractAttribute = $.loc($.field($.pure("ContractAttribute"), "$", $.right($.str("@interface"), $.right($.str("("), $.field($.lazy(() => exports.StringLiteral), "name", $.right($.str(")"), $.eps))))));
exports.FunctionAttribute = $.loc($.field($.pure("FunctionAttribute"), "$", $.field($.alt($.lazy(() => exports.GetAttribute), $.alt((0, exports.keyword)($.str("mutates")), $.alt((0, exports.keyword)($.str("extends")), $.alt((0, exports.keyword)($.str("virtual")), $.alt((0, exports.keyword)($.str("override")), $.alt((0, exports.keyword)($.str("inline")), (0, exports.keyword)($.str("abstract")))))))), "name", $.eps)));
exports.GetAttribute = $.loc($.field($.pure("GetAttribute"), "$", $.right($.str("get"), $.field($.opt($.right($.str("("), $.left($.lazy(() => exports.expression), $.str(")")))), "methodId", $.eps))));
exports.ReceiverType = $.loc($.field($.pure("ReceiverType"), "$", $.field($.alt($.str("bounced"), $.alt((0, exports.keyword)($.str("receive")), (0, exports.keyword)($.str("external")))), "name", $.eps)));
exports.Parameter = $.loc($.field($.pure("Parameter"), "$", $.field(exports.Id, "name", $.field($.lazy(() => exports.ascription), "type", $.eps))));
exports.StringLiteral = $.loc($.field($.pure("StringLiteral"), "$", $.field($.lex($.right($.str("\""), $.left($.stry($.star($.alt($.regex("^\"\\\\", $.negateExps([$.ExpString("\""), $.ExpString("\\")])), $.right($.str("\\"), $.lazy(() => exports.escapeChar))))), $.str("\"")))), "value", $.eps)));
exports.receiverParam = $.opt($.alt(exports.Parameter, exports.StringLiteral));
exports.assembly = $.lex($.stry($.lazy(() => exports.assemblySequence)));
exports.Comment = $.loc($.field($.pure("Comment"), "$", $.right($.alt($.lazy(() => exports.multiLineComment), $.lazy(() => exports.singleLineComment)), $.eps)));
exports.assemblyItem = $.alt($.right($.str("{"), $.right($.lazy(() => exports.assemblySequence), $.right($.str("}"), $.eps))), $.alt(exports.Comment, $.alt($.right($.str("\""), $.right($.star($.regex("^\"", $.negateExps([$.ExpString("\"")]))), $.right($.str("\""), $.eps))), $.plus($.right($.lookNeg($.alt($.regex("\"{}", [$.ExpString("\""), $.ExpString("{"), $.ExpString("}")]), $.alt($.str("//"), $.str("/*")))), $.right($.any, $.eps))))));
exports.assemblySequence = $.star(exports.assemblyItem);
exports.TypeAs = $.loc($.field($.pure("TypeAs"), "$", $.field($.lazy(() => exports.TypeOptional), "type", $.field($.star($.right((0, exports.keyword)($.str("as")), exports.Id)), "as", $.eps))));
exports.$type = exports.TypeAs;
exports.ascription = $.right($.str(":"), exports.$type);
exports.TypeOptional = $.loc($.field($.pure("TypeOptional"), "$", $.field($.lazy(() => exports.typePrimary), "type", $.field($.star($.str("?")), "optionals", $.eps))));
exports.TypeGeneric = $.loc($.field($.pure("TypeGeneric"), "$", $.field($.alt($.lazy(() => exports.MapKeyword), $.alt($.lazy(() => exports.Bounced), $.lazy(() => exports.TypeId))), "name", $.right($.str("<"), $.field((0, exports.commaList)(exports.$type), "args", $.right($.str(">"), $.eps))))));
exports.TypeRegular = $.loc($.field($.pure("TypeRegular"), "$", $.field($.lazy(() => exports.TypeId), "child", $.eps)));
exports.typePrimary = $.alt(exports.TypeGeneric, exports.TypeRegular);
exports.MapKeyword = $.loc($.field($.pure("MapKeyword"), "$", $.right((0, exports.keyword)($.str("map")), $.eps)));
exports.Bounced = $.loc($.field($.pure("Bounced"), "$", $.right($.str("bounced"), $.eps)));
exports.TypeId = $.named("capitalized identifier", $.loc($.field($.pure("TypeId"), "$", $.field($.lex($.stry($.right($.regex("A-Z", [$.ExpRange("A", "Z")]), $.right($.star($.regex("a-zA-Z0-9_", [$.ExpRange("a", "z"), $.ExpRange("A", "Z"), $.ExpRange("0", "9"), $.ExpString("_")])), $.eps)))), "name", $.eps))));
const generic = (T) => $.right($.str("<"), $.left($.opt((0, exports.commaList)($.lazy(() => T))), $.str(">")));
exports.generic = generic;
exports.typeArgs = (0, exports.generic)(exports.$type);
exports.StatementLet = $.loc($.field($.pure("StatementLet"), "$", $.right((0, exports.keyword)($.str("let")), $.field(exports.Id, "name", $.field($.opt(exports.ascription), "type", $.right($.str("="), $.field($.lazy(() => exports.expression), "init", $.right(exports.semicolon, $.eps))))))));
exports.StatementDestruct = $.loc($.field($.pure("StatementDestruct"), "$", $.right((0, exports.keyword)($.str("let")), $.field(exports.TypeId, "type", $.right($.str("{"), $.field((0, exports.inter)($.lazy(() => exports.destructItem), $.str(",")), "fields", $.field($.lazy(() => exports.optionalRest), "rest", $.right($.str("}"), $.right($.str("="), $.field($.lazy(() => exports.expression), "init", $.right(exports.semicolon, $.eps)))))))))));
exports.StatementBlock = $.loc($.field($.pure("StatementBlock"), "$", $.field($.lazy(() => exports.statements), "body", $.eps)));
exports.StatementReturn = $.loc($.field($.pure("StatementReturn"), "$", $.right((0, exports.keyword)($.str("return")), $.field($.opt($.lazy(() => exports.expression)), "expression", $.right(exports.semicolon, $.eps)))));
exports.StatementCondition = $.loc($.field($.pure("StatementCondition"), "$", $.right((0, exports.keyword)($.str("if")), $.field($.lazy(() => exports.expression), "condition", $.field($.lazy(() => exports.statements), "trueBranch", $.field($.opt($.right((0, exports.keyword)($.str("else")), $.alt($.lazy(() => exports.FalseBranch), $.lazy(() => exports.StatementCondition)))), "falseBranch", $.eps))))));
exports.StatementWhile = $.loc($.field($.pure("StatementWhile"), "$", $.right((0, exports.keyword)($.str("while")), $.field($.lazy(() => exports.parens), "condition", $.field($.lazy(() => exports.statements), "body", $.eps)))));
exports.StatementRepeat = $.loc($.field($.pure("StatementRepeat"), "$", $.right((0, exports.keyword)($.str("repeat")), $.field($.lazy(() => exports.parens), "condition", $.field($.lazy(() => exports.statements), "body", $.eps)))));
exports.StatementUntil = $.loc($.field($.pure("StatementUntil"), "$", $.right((0, exports.keyword)($.str("do")), $.field($.lazy(() => exports.statements), "body", $.right((0, exports.keyword)($.str("until")), $.field($.lazy(() => exports.parens), "condition", $.right(exports.semicolon, $.eps)))))));
exports.StatementTry = $.loc($.field($.pure("StatementTry"), "$", $.right((0, exports.keyword)($.str("try")), $.field($.lazy(() => exports.statements), "body", $.field($.opt($.right((0, exports.keyword)($.str("catch")), $.right($.str("("), $.field(exports.Id, "name", $.right($.str(")"), $.field($.lazy(() => exports.statements), "body", $.eps)))))), "handler", $.eps)))));
exports.StatementForEach = $.loc($.field($.pure("StatementForEach"), "$", $.right((0, exports.keyword)($.str("foreach")), $.right($.str("("), $.field(exports.Id, "key", $.right($.str(","), $.field(exports.Id, "value", $.right($.str("in"), $.field($.lazy(() => exports.expression), "expression", $.right($.str(")"), $.field($.lazy(() => exports.statements), "body", $.eps)))))))))));
exports.StatementExpression = $.loc($.field($.pure("StatementExpression"), "$", $.field($.lazy(() => exports.expression), "expression", $.right(exports.semicolon, $.eps))));
exports.StatementAssign = $.loc($.field($.pure("StatementAssign"), "$", $.field($.lazy(() => exports.expression), "left", $.field($.alt($.lazy(() => exports.augmentedOp), $.str("=")), "operator", $.field($.lazy(() => exports.expression), "right", $.right(exports.semicolon, $.eps))))));
exports.statement = $.alt(exports.StatementLet, $.alt(exports.StatementDestruct, $.alt(exports.StatementBlock, $.alt(exports.StatementReturn, $.alt(exports.StatementCondition, $.alt(exports.StatementWhile, $.alt(exports.StatementRepeat, $.alt(exports.StatementUntil, $.alt(exports.StatementTry, $.alt(exports.StatementForEach, $.alt(exports.StatementExpression, exports.StatementAssign)))))))))));
exports.statements = $.right($.str("{"), $.left($.star(exports.statement), $.str("}")));
exports.augmentedOp = $.alt($.str("||="), $.alt($.str("&&="), $.alt($.str(">>="), $.alt($.str("<<="), $.alt($.str("-="), $.alt($.str("+="), $.alt($.str("*="), $.alt($.str("/="), $.alt($.str("%="), $.alt($.str("|="), $.alt($.str("&="), $.str("^="))))))))))));
exports.FalseBranch = $.loc($.field($.pure("FalseBranch"), "$", $.field(exports.statements, "body", $.eps)));
exports.RegularField = $.loc($.field($.pure("RegularField"), "$", $.field(exports.Id, "fieldName", $.right($.str(":"), $.field(exports.Id, "varName", $.eps)))));
exports.PunnedField = $.loc($.field($.pure("PunnedField"), "$", $.field(exports.Id, "name", $.eps)));
exports.destructItem = $.alt(exports.RegularField, exports.PunnedField);
exports.RestArgument = $.loc($.field($.pure("RestArgument"), "$", $.right($.str(".."), $.eps)));
exports.NoRestArgument = $.loc($.field($.pure("NoRestArgument"), "$", $.right($.opt($.str(",")), $.eps)));
exports.optionalRest = $.alt($.right($.str(","), exports.RestArgument), exports.NoRestArgument);
exports.Conditional = $.loc($.field($.pure("Conditional"), "$", $.field($.lazy(() => exports.or), "head", $.field($.opt($.right($.str("?"), $.field($.lazy(() => exports.or), "thenBranch", $.right($.str(":"), $.field($.lazy(() => exports.Conditional), "elseBranch", $.eps))))), "tail", $.eps))));
exports.expression = exports.Conditional;
const Binary = (T, U) => $.loc($.field($.pure("Binary"), "$", $.field((0, exports.inter)($.lazy(() => T), $.lazy(() => (0, exports.Operator)($.lazy(() => U)))), "exprs", $.eps)));
exports.Binary = Binary;
exports.Unary = $.loc($.field($.pure("Unary"), "$", $.field($.star($.lazy(() => (0, exports.Operator)($.regex("-+!~", [$.ExpString("-"), $.ExpString("+"), $.ExpString("!"), $.ExpString("~")])))), "prefixes", $.field($.lazy(() => exports.Suffix), "expression", $.eps))));
exports.mul = (0, exports.Binary)(exports.Unary, $.regex("*/%", [$.ExpString("*"), $.ExpString("/"), $.ExpString("%")]));
exports.add = (0, exports.Binary)(exports.mul, $.alt($.str("+"), $.str("-")));
exports.bitwiseShift = (0, exports.Binary)(exports.add, $.alt($.str("<<"), $.str(">>")));
exports.compare = (0, exports.Binary)(exports.bitwiseShift, $.alt($.str("<="), $.alt($.str("<"), $.alt($.str(">="), $.str(">")))));
exports.equality = (0, exports.Binary)(exports.compare, $.alt($.str("!="), $.str("==")));
exports.bitwiseAnd = (0, exports.Binary)(exports.equality, $.str("&"));
exports.bitwiseXor = (0, exports.Binary)(exports.bitwiseAnd, $.str("^"));
exports.bitwiseOr = (0, exports.Binary)(exports.bitwiseXor, $.str("|"));
exports.and = (0, exports.Binary)(exports.bitwiseOr, $.str("&&"));
exports.or = (0, exports.Binary)(exports.and, $.str("||"));
exports.Suffix = $.loc($.field($.pure("Suffix"), "$", $.field($.lazy(() => exports.primary), "expression", $.field($.star($.lazy(() => exports.suffix)), "suffixes", $.eps))));
const Operator = (U) => $.loc($.field($.pure("Operator"), "$", $.field($.lazy(() => U), "name", $.eps)));
exports.Operator = Operator;
exports.SuffixUnboxNotNull = $.loc($.field($.pure("SuffixUnboxNotNull"), "$", $.right($.str("!!"), $.eps)));
exports.SuffixCall = $.loc($.field($.pure("SuffixCall"), "$", $.field($.lazy(() => (0, exports.ParameterList)(exports.expression)), "params", $.eps)));
exports.SuffixFieldAccess = $.loc($.field($.pure("SuffixFieldAccess"), "$", $.right($.str("."), $.field(exports.Id, "name", $.eps))));
exports.suffix = $.alt(exports.SuffixUnboxNotNull, $.alt(exports.SuffixCall, exports.SuffixFieldAccess));
exports.Parens = $.loc($.field($.pure("Parens"), "$", $.field($.lazy(() => exports.parens), "child", $.eps)));
exports.MapLiteral = $.loc($.field($.pure("MapLiteral"), "$", $.right((0, exports.keyword)($.str("map")), $.field(exports.typeArgs, "typeArgs", $.right($.str("{"), $.field($.opt((0, exports.commaList)($.lazy(() => exports.mapField))), "fields", $.right($.str("}"), $.eps)))))));
exports.SetLiteral = $.loc($.field($.pure("SetLiteral"), "$", $.right($.str("set"), $.field(exports.typeArgs, "typeArgs", $.right($.str("{"), $.field($.opt((0, exports.commaList)(exports.expression)), "fields", $.right($.str("}"), $.eps)))))));
exports.StructInstance = $.loc($.field($.pure("StructInstance"), "$", $.field(exports.TypeId, "type", $.field($.lazy(() => exports.StructInstanceFields), "body", $.eps))));
exports.IntegerLiteral = $.loc($.field($.pure("IntegerLiteral"), "$", $.field($.alt($.lazy(() => exports.IntegerLiteralHex), $.alt($.lazy(() => exports.IntegerLiteralBin), $.alt($.lazy(() => exports.IntegerLiteralOct), exports.IntegerLiteralDec))), "value", $.eps)));
exports.BoolLiteral = $.loc($.field($.pure("BoolLiteral"), "$", $.field($.alt($.str("true"), $.str("false")), "value", $.right($.lookNeg($.lazy(() => exports.idPart)), $.eps))));
exports.InitOf = $.loc($.field($.pure("InitOf"), "$", $.right((0, exports.keyword)($.str("initOf")), $.field(exports.Id, "name", $.field($.lazy(() => (0, exports.ParameterList)(exports.expression)), "params", $.eps)))));
exports.CodeOf = $.loc($.field($.pure("CodeOf"), "$", $.right($.str("codeOf"), $.field(exports.Id, "name", $.eps))));
exports.Null = $.loc($.field($.pure("Null"), "$", $.right((0, exports.keyword)($.str("null")), $.eps)));
exports.primary = $.alt(exports.Parens, $.alt(exports.MapLiteral, $.alt(exports.SetLiteral, $.alt(exports.StructInstance, $.alt(exports.IntegerLiteral, $.alt(exports.BoolLiteral, $.alt(exports.InitOf, $.alt(exports.CodeOf, $.alt(exports.Null, $.alt(exports.StringLiteral, exports.Id))))))))));
exports.parens = $.right($.str("("), $.left(exports.expression, $.str(")")));
exports.StructInstanceFields = $.loc($.field($.pure("StructInstanceFields"), "$", $.right($.str("{"), $.field($.opt((0, exports.commaList)($.lazy(() => exports.StructFieldInitializer))), "fields", $.right($.str("}"), $.eps)))));
exports.mapField = $.field(exports.expression, "key", $.right($.str(":"), $.field(exports.expression, "value", $.eps)));
exports.StructFieldInitializer = $.loc($.field($.pure("StructFieldInitializer"), "$", $.field(exports.Id, "name", $.field($.opt($.right($.str(":"), exports.expression)), "init", $.eps))));
const ParameterList = (T) => $.loc($.field($.pure("ParameterList"), "$", $.right($.str("("), $.field($.opt((0, exports.commaList)($.lazy(() => T))), "values", $.right($.str(")"), $.eps)))));
exports.ParameterList = ParameterList;
exports.IntegerLiteralHex = $.loc($.field($.pure("IntegerLiteralHex"), "$", $.field($.lex($.right($.str("0"), $.right($.regex("xX", [$.ExpString("x"), $.ExpString("X")]), $.lazy(() => (0, exports.underscored)($.lazy(() => exports.hexDigit)))))), "digits", $.eps)));
exports.IntegerLiteralBin = $.loc($.field($.pure("IntegerLiteralBin"), "$", $.field($.lex($.right($.str("0"), $.right($.regex("bB", [$.ExpString("b"), $.ExpString("B")]), $.lazy(() => (0, exports.underscored)($.regex("01", [$.ExpString("0"), $.ExpString("1")])))))), "digits", $.eps)));
exports.IntegerLiteralOct = $.loc($.field($.pure("IntegerLiteralOct"), "$", $.field($.lex($.right($.str("0"), $.right($.regex("oO", [$.ExpString("o"), $.ExpString("O")]), $.lazy(() => (0, exports.underscored)($.regex("0-7", [$.ExpRange("0", "7")])))))), "digits", $.eps)));
const underscored = (T) => $.stry($.right($.lazy(() => T), $.right($.star($.right($.opt($.str("_")), $.right($.lazy(() => T), $.eps))), $.eps)));
exports.underscored = underscored;
exports.digit = $.named("digit", $.regex("0-9", [$.ExpRange("0", "9")]));
exports.idPart = $.named("identifier character", $.regex("a-zA-Z0-9_", [$.ExpRange("a", "z"), $.ExpRange("A", "Z"), $.ExpRange("0", "9"), $.ExpString("_")]));
exports.FuncId = $.named("FunC identifier", $.loc($.field($.pure("FuncId"), "$", $.field($.opt($.regex(".~", [$.ExpString("."), $.ExpString("~")])), "accessor", $.field($.stry($.alt($.right($.str("`"), $.right($.plus($.regex("^`\\r\\n", $.negateExps([$.ExpString("`"), $.ExpString("\r"), $.ExpString("\n")]))), $.right($.str("`"), $.eps))), $.plus($.regex("^ \\t\\r\\n()[\\],.;~", $.negateExps([$.ExpString(" "), $.ExpString("\t"), $.ExpString("\r"), $.ExpString("\n"), $.ExpString("("), $.ExpString(")"), $.ExpString("["), $.ExpString("\"\\]\""), $.ExpString(","), $.ExpString("."), $.ExpString(";"), $.ExpString("~")]))))), "id", $.eps)))));
exports.hexDigit = $.named("hexadecimal digit", $.regex("0-9a-fA-F", [$.ExpRange("0", "9"), $.ExpRange("a", "f"), $.ExpRange("A", "F")]));
exports.escapeChar = $.alt($.regex("\\\\\"nrtvbf", [$.ExpString("\\"), $.ExpString("\""), $.ExpString("n"), $.ExpString("r"), $.ExpString("t"), $.ExpString("v"), $.ExpString("b"), $.ExpString("f")]), $.alt($.right($.str("u{"), $.left($.stry($.right(exports.hexDigit, $.right($.opt(exports.hexDigit), $.right($.opt(exports.hexDigit), $.right($.opt(exports.hexDigit), $.right($.opt(exports.hexDigit), $.right($.opt(exports.hexDigit), $.eps))))))), $.str("}"))), $.alt($.right($.str("u"), $.stry($.right(exports.hexDigit, $.right(exports.hexDigit, $.right(exports.hexDigit, $.right(exports.hexDigit, $.eps)))))), $.right($.str("x"), $.stry($.right(exports.hexDigit, $.right(exports.hexDigit, $.eps)))))));
exports.reservedWord = $.named("reserved word", (0, exports.keyword)($.alt($.str("extend"), $.alt($.str("public"), $.alt($.str("fun"), $.alt($.str("let"), $.alt($.str("return"), $.alt($.str("receive"), $.alt($.str("native"), $.alt($.str("primitive"), $.alt($.str("null"), $.alt($.str("if"), $.alt($.str("else"), $.alt($.str("while"), $.alt($.str("repeat"), $.alt($.str("do"), $.alt($.str("until"), $.alt($.str("try"), $.alt($.str("catch"), $.alt($.str("foreach"), $.alt($.str("as"), $.alt($.str("map"), $.alt($.str("mutates"), $.alt($.str("extends"), $.alt($.str("external"), $.alt($.str("import"), $.alt($.str("with"), $.alt($.str("trait"), $.alt($.str("initOf"), $.alt($.str("override"), $.alt($.str("abstract"), $.alt($.str("virtual"), $.alt($.str("inline"), $.str("const"))))))))))))))))))))))))))))))))));
exports.space = $.named("space", $.plus($.alt($.lex($.stry($.plus($.regex(" \\t\\r\\n", [$.ExpString(" "), $.ExpString("\t"), $.ExpString("\r"), $.ExpString("\n")])))), exports.Comment)));
exports.multiLineComment = $.right($.str("/*"), $.left($.stry($.star($.right($.lookNeg($.str("*/")), $.right($.any, $.eps)))), $.str("*/")));
exports.singleLineComment = $.right($.str("//"), $.stry($.star($.regex("^\\r\\n", $.negateExps([$.ExpString("\r"), $.ExpString("\n")])))));
exports.JustImports = $.loc($.field($.pure("JustImports"), "$", $.field($.star(exports.Import), "imports", $.right($.star($.any), $.eps))));
