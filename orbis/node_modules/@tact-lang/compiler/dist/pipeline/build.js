"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildFail = exports.BuildOk = void 0;
exports.build = build;
exports.enableFeatures = enableFeatures;
const features_1 = require("../config/features");
const context_1 = require("../context/context");
const logger_1 = require("../context/logger");
const filePath_1 = require("../utils/filePath");
const compile_1 = require("./compile");
const precompile_1 = require("./precompile");
const errors_1 = require("../error/errors");
const packaging_1 = require("./packaging");
const bindings_1 = require("./bindings");
const reports_1 = require("./reports");
const createVirtualFileSystem_1 = require("../vfs/createVirtualFileSystem");
const Stdlib = __importStar(require("../stdlib/stdlib"));
const BuildOk = () => ({ ok: true, error: [] });
exports.BuildOk = BuildOk;
const BuildFail = (error) => ({
    ok: false,
    error,
});
exports.BuildFail = BuildFail;
async function build(args) {
    const { config, project, logger = new logger_1.Logger() } = args;
    const stdlib = typeof args.stdlib === "string"
        ? (0, createVirtualFileSystem_1.createVirtualFileSystem)(args.stdlib, Stdlib.files)
        : args.stdlib;
    // Configure context
    let ctx = new context_1.CompilerContext();
    ctx = enableFeatures(ctx, logger, config);
    // Precompile
    try {
        ctx = (0, precompile_1.precompile)(ctx, project, stdlib, config.path);
    }
    catch (e) {
        logger.error(config.mode === "checkOnly" || config.mode === "funcOnly"
            ? "Syntax and type checking failed"
            : "Tact compilation failed");
        // show an error with a backtrace only in verbose mode
        if (e instanceof errors_1.TactError && config.verbose && config.verbose < 2) {
            logger.error(e.message);
        }
        else {
            logger.error(e);
        }
        return (0, exports.BuildFail)([e]);
    }
    if (config.mode === "checkOnly") {
        logger.info("✔️ Syntax and type checking succeeded.");
        return (0, exports.BuildOk)();
    }
    const compilerInfo = JSON.stringify({
        entrypoint: (0, filePath_1.posixNormalize)(config.path),
        options: config.options ?? {},
    });
    const bCtx = {
        config,
        logger,
        project,
        stdlib,
        compilerInfo,
        ctx,
        built: {},
        errorMessages: [],
    };
    const ok = await (0, compile_1.doCompileContracts)(bCtx);
    if (!ok) {
        bCtx.logger.info("💥 Compilation failed. Skipping packaging");
        return (0, exports.BuildFail)(bCtx.errorMessages);
    }
    if (bCtx.config.mode === "funcOnly") {
        bCtx.logger.info("✔️ FunC code generation succeeded.");
        return (0, exports.BuildOk)();
    }
    const packages = (0, packaging_1.doPackaging)(bCtx);
    if (!packages) {
        return (0, exports.BuildFail)(bCtx.errorMessages);
    }
    const bindingsRes = (0, bindings_1.doBindings)(bCtx, packages);
    if (!bindingsRes) {
        return (0, exports.BuildFail)(bCtx.errorMessages);
    }
    const reportsRes = (0, reports_1.doReports)(bCtx, packages);
    if (!reportsRes) {
        return (0, exports.BuildFail)(bCtx.errorMessages);
    }
    return (0, exports.BuildOk)();
}
function enableFeatures(ctx, logger, config) {
    if (config.options === undefined) {
        return ctx;
    }
    const features = [
        { option: config.options.debug, name: "debug" },
        { option: config.options.external, name: "external" },
        { option: config.options.experimental?.inline, name: "inline" },
        { option: config.options.ipfsAbiGetter, name: "ipfsAbiGetter" },
        { option: config.options.interfacesGetter, name: "interfacesGetter" },
        {
            option: config.options.safety?.nullChecks ?? true,
            name: "nullChecks",
        },
        {
            option: config.options.optimizations?.alwaysSaveContractData ?? false,
            name: "alwaysSaveContractData",
        },
        {
            option: config.options.optimizations
                ?.internalExternalReceiversOutsideMethodsMap ?? true,
            name: "internalExternalReceiversOutsideMethodsMap",
        },
        {
            option: config.options.enableLazyDeploymentCompletedGetter ?? false,
            name: "lazyDeploymentCompletedGetter",
        },
    ];
    return features.reduce((currentCtx, { option, name }) => {
        if (option) {
            logger.debug(`   > 👀 Enabling ${name}`);
            return (0, features_1.featureEnable)(currentCtx, name);
        }
        return currentCtx;
    }, ctx);
}
