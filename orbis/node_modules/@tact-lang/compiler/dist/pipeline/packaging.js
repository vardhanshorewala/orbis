"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doPackaging = doPackaging;
const core_1 = require("@ton/core");
const packageCode_1 = require("../packaging/packageCode");
const version_1 = require("./version");
const resolveABITypeRef_1 = require("../types/resolveABITypeRef");
const ast_helpers_1 = require("../ast/ast-helpers");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const filePath_1 = require("../utils/filePath");
const store_1 = require("../context/store");
const NonEmptyChildContractsDict = (cell) => ({
    $: "NonEmptyChildContractsDict",
    cell,
});
const NoChildContracts = { $: "NoChildContracts" };
function doPackaging(bCtx) {
    bCtx.logger.info("   > Packaging");
    const packages = [];
    const contracts = (0, resolveDescriptors_1.getContracts)(bCtx.ctx);
    for (const contract of contracts) {
        const pkg = packageContract(bCtx, contract.name);
        if (!pkg)
            continue;
        packages.push(pkg);
    }
    return packages;
}
function buildChildContractsDict(bCtx, contract) {
    const depends = core_1.Dictionary.empty(core_1.Dictionary.Keys.Uint(16), core_1.Dictionary.Values.Cell());
    const contractType = (0, resolveDescriptors_1.getType)(bCtx.ctx, contract);
    for (const dependencyContract of contractType.dependsOn) {
        const dependencyContractBuild = bCtx.built[dependencyContract.name];
        if (!dependencyContractBuild) {
            const message = `   > ${dependencyContract.name}: no artifacts found`;
            bCtx.logger.error(message);
            bCtx.errorMessages.push(new Error(message));
            return undefined;
        }
        const dependencyContractCell = core_1.Cell.fromBoc(dependencyContractBuild.codeBoc)[0];
        depends.set(dependencyContract.uid, dependencyContractCell);
    }
    if (contractType.dependsOn.length === 0) {
        return NoChildContracts;
    }
    return NonEmptyChildContractsDict((0, core_1.beginCell)().storeDict(depends).endCell());
}
function packageContract(bCtx, contract) {
    const { project, config, logger, errorMessages, stdlib } = bCtx;
    logger.info("   > " + contract);
    const artifacts = bCtx.built[contract];
    if (!artifacts) {
        const message = `   > ${contract}: no artifacts found`;
        logger.error(message);
        errorMessages.push(new Error(message));
        return undefined;
    }
    const childContractsDict = buildChildContractsDict(bCtx, contract);
    if (childContractsDict === undefined) {
        return undefined;
    }
    // Collect sources
    const sources = {};
    const rawAst = (0, store_1.getRawAST)(bCtx.ctx);
    for (const source of [...rawAst.funcSources, ...rawAst.sources]) {
        if (source.path.startsWith(project.root) &&
            !source.path.startsWith(stdlib.root)) {
            const source_path = (0, filePath_1.posixNormalize)(source.path.slice(project.root.length));
            sources[source_path] = Buffer.from(source.code).toString("base64");
        }
    }
    const descriptor = (0, resolveDescriptors_1.getType)(bCtx.ctx, contract);
    const init = descriptor.init;
    const args = init.kind !== "contract-params"
        ? init.params.map((v) => ({
            // FIXME: wildcards in ABI?
            name: v.name.kind === "id" ? v.name.text : "_",
            type: (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(bCtx.ctx, v.type, v.loc, v.as),
        }))
        : (init.contract.params ?? []).map((v) => ({
            name: (0, ast_helpers_1.idText)(v.name),
            type: (0, resolveABITypeRef_1.resolveABIType)(v),
        }));
    // Package
    const pkg = {
        name: contract,
        abi: artifacts.abi,
        code: artifacts.codeBoc.toString("base64"),
        init: {
            kind: "direct",
            args,
            prefix: init.kind !== "contract-params"
                ? {
                    bits: 1,
                    value: 0,
                }
                : undefined,
            deployment: {
                kind: "system-cell",
                system: childContractsDict.$ === "NonEmptyChildContractsDict"
                    ? childContractsDict.cell.toBoc().toString("base64")
                    : null,
            },
        },
        sources,
        compiler: {
            name: "tact",
            version: (0, version_1.getCompilerVersion)(),
            parameters: bCtx.compilerInfo,
        },
    };
    const pkgData = (0, packageCode_1.packageCode)(pkg);
    const pathPkg = project.resolve(config.output, config.name + "_" + contract + ".pkg");
    project.writeFile(pathPkg, pkgData);
    return pkg;
}
