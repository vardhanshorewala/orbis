"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.precompile = precompile;
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const resolveAllocation_1 = require("../storage/resolveAllocation");
const store_1 = require("../context/store");
const resolveStatements_1 = require("../types/resolveStatements");
const resolveErrors_1 = require("../types/resolveErrors");
const resolveSignatures_1 = require("../types/resolveSignatures");
const resolveImports_1 = require("../imports/resolveImports");
const ast_helpers_1 = require("../ast/ast-helpers");
const grammar_1 = require("../grammar");
const evalComptimeExpressions_1 = require("../types/evalComptimeExpressions");
const effects_1 = require("../types/effects");
const ast_factory_store_1 = require("./ast-factory-store");
function precompile(ctx, project, stdlib, entrypoint, parsedModules) {
    const ast = (0, ast_helpers_1.getAstFactory)();
    (0, ast_factory_store_1.setAstFactoryToStore)(ctx, ast);
    const parser = (0, grammar_1.getParser)(ast);
    // Load all sources
    const imported = (0, resolveImports_1.resolveImports)({ entrypoint, project, stdlib, parser });
    // Parse the sources and attach the given parsed modules
    const modules = [
        ...(0, store_1.parseModules)(imported.tact, parser),
        ...(parsedModules ?? []),
    ];
    // Add information about all the source code entries to the context
    ctx = (0, store_1.openContext)(ctx, imported.tact, imported.func, modules);
    // First load type descriptors and check that
    //       they all have valid signatures
    ctx = (0, resolveDescriptors_1.resolveDescriptors)(ctx, ast);
    // This checks and resolves all statements
    ctx = (0, resolveStatements_1.resolveStatements)(ctx);
    // From this point onwards, it is safe to call evalConstantExpression.
    /* Evaluate all comp-time expressions:
       constants, default contract fields, default struct fields, method Ids

       The original code inside constant, field and method id initialization actually mutated the CompilerContext object,
       while the rest of the typechecker's code built a new CompilerContext every time it changed something.
       Hence the reason of why this line is not written as:

       ctx = evalComptimeExpressions(ctx, ast);

       The code mutates fields in ConstantDescription, FieldDescription and FunctionDescription.

       Evaluation of Message op-codes is done later in resolveSignatures. It was left there because
       the computation of those op-codes is more involved than the computation of method ids, and so
       it is hard to extract the call to evalConstantExpression in resolveSignatures.
    */
    (0, evalComptimeExpressions_1.evalComptimeExpressions)(ctx, ast);
    ctx = (0, resolveDescriptors_1.computeGlobalVariablesUsages)(ctx);
    // This creates TLB-style type definitions
    ctx = (0, resolveSignatures_1.resolveSignatures)(ctx, ast);
    // This extracts error messages
    ctx = (0, resolveErrors_1.resolveErrors)(ctx, ast);
    // This creates allocations for all defined types
    ctx = (0, resolveAllocation_1.resolveAllocations)(ctx);
    // To use in code generation to decide if a receiver needs to call the contract storage function
    (0, effects_1.computeReceiversEffects)(ctx);
    // Prepared context
    return ctx;
}
