"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doCompileContracts = doCompileContracts;
exports.compileFunc = compileFunc;
exports.compileTact = compileTact;
const createABI_1 = require("../generator/createABI");
const writeProgram_1 = require("../generator/writeProgram");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const utils_1 = require("./utils");
const features_1 = require("../config/features");
const opcode_1 = require("@tact-lang/opcode");
const funcCompile_1 = require("../func/funcCompile");
const filePath_1 = require("../utils/filePath");
const errors_1 = require("../error/errors");
const GeneratedOnlyFunc = { $: "GeneratedOnlyFunc" };
const CompiledSuccessfully = (built) => ({
    $: "CompiledSuccessfully",
    built,
});
const CompilationFailed = { $: "CompilationFailed" };
async function doCompileContracts(bCtx) {
    const allContracts = (0, resolveDescriptors_1.getContracts)(bCtx.ctx);
    // Sort contracts in topological order
    // If a cycle is found, topSortContracts returns undefined
    const sortedContracts = (0, utils_1.topSortContracts)(allContracts);
    if (sortedContracts !== undefined) {
        bCtx.ctx = (0, features_1.featureEnable)(bCtx.ctx, "optimizedChildCode");
    }
    const contracts = sortedContracts ?? allContracts;
    let ok = true;
    for (const contract of contracts) {
        const res = await compileContract(bCtx, contract);
        if (res.$ === "CompilationFailed") {
            ok = false;
            continue;
        }
        if (res.$ === "GeneratedOnlyFunc") {
            continue;
        }
        bCtx.built[contract.name] = res.built;
    }
    return ok;
}
async function compileContract(bCtx, contract) {
    const { config, logger } = bCtx;
    const contractName = contract.name;
    logger.info(`   > ${contractName}: tact compiler`);
    const compileRes = await compileTact(bCtx, contract);
    if (!compileRes) {
        return CompilationFailed;
    }
    if (config.mode === "funcOnly") {
        return GeneratedOnlyFunc;
    }
    const codeBoc = await compileFunc(bCtx, contractName, compileRes.entrypointPath, compileRes.funcSource);
    if (typeof codeBoc === "undefined") {
        return CompilationFailed;
    }
    if (bCtx.config.mode === "fullWithDecompilation") {
        // TODO: return error on fail
        decompileContract(bCtx, contractName, codeBoc);
    }
    const { abi, constants } = compileRes;
    return CompiledSuccessfully({
        codeBoc,
        abi,
        constants,
        contract,
    });
}
function decompileContract(bCtx, contractName, codeBoc) {
    const { project, config, logger, errorMessages } = bCtx;
    logger.info(`   > ${contractName}: fift decompiler`);
    try {
        const cell = opcode_1.Cell.fromBoc(codeBoc).at(0);
        if (typeof cell === "undefined") {
            throw new Error("Cannot create Cell from BoC file");
        }
        const program = (0, opcode_1.disassembleRoot)(cell, { computeRefs: true });
        const codeFiftDecompiled = opcode_1.AssemblyWriter.write(program, {
            useAliases: true,
        });
        const pathCodeFifDec = project.resolve(config.output, `${config.name}_${contractName}.rev.fif`);
        project.writeFile(pathCodeFifDec, codeFiftDecompiled);
        return true;
    }
    catch (e) {
        logger.error("Fift decompiler crashed");
        logger.error(e);
        errorMessages.push(e);
    }
    return false;
}
async function compileFunc(bCtx, contract, entrypointPath, funcSource) {
    const { project, config, logger, errorMessages, stdlib } = bCtx;
    logger.info(`   > ${contract}: func compiler`);
    try {
        const stdlibPath = stdlib.resolve("std/stdlib.fc");
        const stdlibCode = stdlib.readFile(stdlibPath).toString();
        const c = await (0, funcCompile_1.funcCompile)({
            entries: [
                stdlibPath,
                (0, filePath_1.posixNormalize)(project.resolve(config.output, entrypointPath)),
            ],
            sources: [
                {
                    path: stdlibPath,
                    content: stdlibCode,
                },
                funcSource,
            ],
            logger,
        });
        if (!c.ok) {
            const match = c.log.match(/undefined function `([^`]+)`, defining a global function of unknown type/);
            if (match) {
                const message = `Function '${match[1]}' does not exist in imported FunC sources`;
                logger.error(message);
                errorMessages.push(new Error(message));
                return undefined;
            }
            logger.error(c.log);
            errorMessages.push(new Error(c.log));
            return undefined;
        }
        const pathCodeBoc = project.resolve(config.output, 
        // need to keep `.code.boc` here because Blueprint looks for this pattern
        `${config.name}_${contract}.code.boc`);
        const pathCodeFif = project.resolve(config.output, `${config.name}_${contract}.fif`);
        project.writeFile(pathCodeFif, c.fift);
        project.writeFile(pathCodeBoc, c.output);
        return c.output;
    }
    catch (e) {
        logger.error("FunC compiler crashed");
        logger.error(e);
        errorMessages.push(e);
    }
    return undefined;
}
async function compileTact(bCtx, contract) {
    const { project, config } = bCtx;
    try {
        const contractAbi = (0, createABI_1.createABI)(bCtx.ctx, contract.name);
        const res = await (0, writeProgram_1.writeProgram)(bCtx.ctx, contract, contractAbi, `${config.name}_${contract.name}`, bCtx.built, false);
        const { abi, funcFile, constants, entrypoint: entrypointPath } = res;
        const pathFunc = project.resolve(config.output, funcFile.name);
        project.writeFile(pathFunc, funcFile.code);
        const pathAbi = project.resolve(config.output, `${config.name}_${contract.name}.abi`);
        project.writeFile(pathAbi, abi);
        const funcSource = {
            path: (0, filePath_1.posixNormalize)(project.resolve(config.output, funcFile.name)),
            content: funcFile.code,
        };
        return { abi, funcSource, entrypointPath, constants };
    }
    catch (e) {
        bCtx.logger.error("Tact compilation failed");
        // show an error with a backtrace only in verbose mode
        if (e instanceof errors_1.TactError && config.verbose && config.verbose < 2) {
            bCtx.logger.error(e.message);
        }
        else {
            bCtx.logger.error(e);
        }
        bCtx.errorMessages.push(e);
    }
    return undefined;
}
