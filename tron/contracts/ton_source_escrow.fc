;; TON Source Escrow HTLC Contract for 1inch Fusion+ (Simplified)
;; This contract locks assets on the source chain with hashlock/timelock

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/jetton-utils.fc";

;; Operation codes
const int OP_CREATE_ESCROW = 0x1;
const int OP_WITHDRAW = 0x2;
const int OP_REFUND = 0x3;
const int OP_LOCK_ESCROW = 0x5;
const int OP_JETTON_TRANSFER = 0x178d4519;
const int OP_JETTON_NOTIFICATION = 0x7362d09c;

;; Escrow statuses
const int STATUS_CREATED = 1;
const int STATUS_LOCKED = 2;
const int STATUS_WITHDRAWN = 3;
const int STATUS_REFUNDED = 4;

;; Simplified storage layout with reference cell to avoid cell size limits:
;; maker_address (MsgAddress)
;; resolver_address (MsgAddress) 
;; asset_type (uint8) - 0 for TON, 1 for Jetton
;; amount (Coins)
;; safety_deposit (Coins)
;; ref_cell containing:
;;   target_address (MsgAddress)
;;   refund_address (MsgAddress)
;;   jetton_master (MsgAddress) - only if asset_type = 1
;;   secret_hash (32 bits for testing)
;;   timelock_duration (uint32)
;;   finality_timelock (uint32)
;; created_at (uint32)
;; status (uint8)

(slice, slice, slice, slice, int, slice, int, int, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    slice maker_address = ds~load_msg_addr();
    slice resolver_address = ds~load_msg_addr();
    int asset_type = ds~load_uint(8);
    int amount = ds~load_coins();
    int safety_deposit = ds~load_coins();
    
    slice ref_cell = ds~load_ref().begin_parse();
    slice target_address = ref_cell~load_msg_addr();
    slice refund_address = ref_cell~load_msg_addr();
    slice jetton_master = ref_cell~load_msg_addr();
    int secret_hash = ref_cell~load_uint(32); ;; 32 bits for testing
    int timelock_duration = ref_cell~load_uint(32);
    int finality_timelock = ref_cell~load_uint(32);
    
    ;; Safe loading of runtime fields - default to 0 if not present
    int created_at = 0;
    int status = 0;
    if (~ ds.slice_empty?()) {
        created_at = ds~load_uint(32);
        if (~ ds.slice_empty?()) {
            status = ds~load_uint(8);
        }
    }
    
    return (maker_address, resolver_address, target_address, refund_address,
            asset_type, jetton_master, amount, safety_deposit, secret_hash,
            timelock_duration, finality_timelock, created_at, status);
}

() save_data(slice maker_address, slice resolver_address, slice target_address, slice refund_address,
             int asset_type, slice jetton_master, int amount, int safety_deposit, int secret_hash,
             int timelock_duration, int finality_timelock, int created_at, int status) impure inline {
    
    cell ref_cell = begin_cell()
        .store_slice(target_address)
        .store_slice(refund_address)
        .store_slice(jetton_master)
        .store_uint(secret_hash, 32) ;; 32 bits for testing
        .store_uint(timelock_duration, 32)
        .store_uint(finality_timelock, 32)
        .end_cell();
    
    set_data(begin_cell()
        .store_slice(maker_address)
        .store_slice(resolver_address)
        .store_uint(asset_type, 8)
        .store_coins(amount)
        .store_coins(safety_deposit)
        .store_ref(ref_cell)
        .store_uint(created_at, 32)
        .store_uint(status, 8)
        .end_cell());
}

;; Simple secret verification - full swap only (32-bit hash for testing)
int verify_secret(int secret_hash, slice secret) inline {
    ;; For testing: Convert secret slice to int and compare directly
    int secret_as_int = 0;
    if (secret.slice_bits() >= 32) {
        secret_as_int = secret~load_uint(32);
    }
    return secret_as_int == secret_hash;
}

;; Create escrow - initialize with config data
() create_escrow(int msg_value) impure {
    ;; Load config from init data (same format as storage but without runtime fields)
    slice ds = get_data().begin_parse();
    slice maker_address = ds~load_msg_addr();
    slice resolver_address = ds~load_msg_addr();
    int asset_type = ds~load_uint(8);
    int amount = ds~load_coins();
    int safety_deposit = ds~load_coins();
    
    slice ref_cell = ds~load_ref().begin_parse();
    slice target_address = ref_cell~load_msg_addr();
    slice refund_address = ref_cell~load_msg_addr();
    slice jetton_master = ref_cell~load_msg_addr();
    int secret_hash = ref_cell~load_uint(32); ;; 32 bits for testing
    int timelock_duration = ref_cell~load_uint(32);
    int finality_timelock = ref_cell~load_uint(32);
    
    ;; For deployment, check if the message value is sufficient
    ;; We need at least the escrow amount + safety deposit + some gas
    int min_required = amount + safety_deposit + 50000000; ;; 0.05 TON for gas
    throw_unless(ERROR_INSUFFICIENT_BALANCE, msg_value >= min_required);
    
    int now_time = now();
    
    ;; Save with runtime state
    save_data(maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, now_time, STATUS_CREATED);
}

;; Lock escrow after finality period (called by resolver)
() lock_escrow(slice sender_address) impure {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(101, status == STATUS_CREATED);
    throw_unless(102, now() >= created_at + finality_timelock);
    
    save_data(maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_LOCKED);
}

;; Withdraw with secret (full amount only - called by resolver)
() withdraw_with_secret(slice sender_address, slice secret) impure {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(103, status == STATUS_LOCKED);
    throw_unless(ERROR_INVALID_SECRET, verify_secret(secret_hash, secret));
    
    ;; Transfer full amount to target address
    if (asset_type == 0) {
        ;; TON transfer - send full amount
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(target_address)
            .store_coins(amount)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Jetton transfer - send full amount
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000) ;; 0.1 TON for gas
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64) ;; query_id
            .store_coins(amount)
            .store_slice(target_address)
            .store_slice(target_address) ;; response_destination
            .store_uint(0, 1) ;; custom_payload
            .store_coins(50000000) ;; forward_ton_amount
            .store_uint(0, 1) ;; forward_payload
            .end_cell(), 1);
    }
    
    ;; Transfer safety deposit to resolver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(resolver_address)
        .store_coins(safety_deposit)
        .store_uint(0, 107)
        .end_cell(), 1);
    
    ;; Mark as withdrawn
    save_data(maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_WITHDRAWN);
}

;; Refund after timeout (callable by maker or resolver)
() refund_escrow(slice sender_address) impure {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    throw_unless(105, equal_slices(sender_address, maker_address) | equal_slices(sender_address, resolver_address));
    throw_unless(106, (status == STATUS_LOCKED) | (status == STATUS_CREATED));
    throw_unless(ERROR_TIMEOUT_NOT_REACHED, now() >= created_at + timelock_duration);
    
    ;; Refund full amount to refund address
    if (asset_type == 0) {
        ;; TON refund
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(amount)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Jetton refund
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000)
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64)
            .store_coins(amount)
            .store_slice(refund_address)
            .store_slice(refund_address)
            .store_uint(0, 1)
            .store_coins(50000000)
            .store_uint(0, 1)
            .end_cell(), 1);
    }
    
    ;; Refund safety deposit to resolver if they initiated refund
    if (equal_slices(sender_address, resolver_address)) {
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(resolver_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    save_data(maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED);
}

;; Get escrow details (for 1inch SDK queries)
(int, slice, slice, slice, slice, int, slice, int, int, int, int) get_escrow_details() method_id {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    return (status, maker_address, resolver_address, target_address, refund_address,
            asset_type, jetton_master, amount, safety_deposit, timelock_duration, created_at);
}

;; Check if escrow can be withdrawn with given secret
int can_withdraw(slice secret) method_id {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    if (~ verify_secret(secret_hash, secret)) { return 0; }
    
    return -1;
}

;; Check if escrow can be refunded
int can_refund() method_id {
    var (maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash,
         timelock_duration, finality_timelock, created_at, status) = load_data();
    
    if ((status != STATUS_LOCKED) & (status != STATUS_CREATED)) { return 0; }
    if (now() < created_at + timelock_duration) { return 0; }
    
    return -1;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    ;; Parse message flags
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    ;; Handle bounced messages
    if (flags & 1) {
        ;; This is a bounced message, just accept it to avoid further bounces
        return ();
    }
    
    ;; Get sender address
    slice sender_address = cs~load_msg_addr();
    
    ;; Handle empty messages (simple transfers)
    if (in_msg_body.slice_empty?()) {
        ;; Check if this is the initial deployment
        var (maker_address, resolver_address, target_address, refund_address,
             asset_type, jetton_master, amount, safety_deposit, secret_hash,
             timelock_duration, finality_timelock, created_at, status) = load_data();
        
        ;; If status is 0, this is the deployment message
        if (status == 0) {
            create_escrow(msg_value);
        }
        ;; Otherwise, ignore empty messages
        return ();
    }
    
    ;; Parse operation
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    ;; Handle operations
    if (op == OP_CREATE_ESCROW) {
        create_escrow(msg_value);
        return ();
    }
    
    if (op == OP_LOCK_ESCROW) {
        lock_escrow(sender_address);
        return ();
    }
    
    if (op == OP_WITHDRAW) {
        slice secret = in_msg_body~load_ref().begin_parse();
        withdraw_with_secret(sender_address, secret);
        return ();
    }
    
    if (op == OP_REFUND) {
        refund_escrow(sender_address);
        return ();
    }
    
    ;; Unknown operation - throw to return funds
    throw(0xffff);
} 