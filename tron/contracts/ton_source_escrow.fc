;; TON Source Escrow HTLC Contract for 1inch Fusion+
;; This contract locks assets on the source chain with hashlock/timelock

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/jetton-utils.fc";

;; Operation codes
const int OP_CREATE_ESCROW = 0x1;
const int OP_WITHDRAW = 0x2;
const int OP_REFUND = 0x3;
const int OP_UPDATE_STATUS = 0x4;
const int OP_JETTON_TRANSFER = 0x178d4519;
const int OP_JETTON_NOTIFICATION = 0x7362d09c;

;; Escrow statuses
const int STATUS_CREATED = 1;
const int STATUS_LOCKED = 2;
const int STATUS_WITHDRAWN = 3;
const int STATUS_REFUNDED = 4;
const int STATUS_EXPIRED = 5;

;; Error codes are defined in imports/constants.fc

;; Storage layout
;; escrow_id (uint256)
;; maker_address (MsgAddress)
;; resolver_address (MsgAddress) 
;; target_address (MsgAddress)
;; refund_address (MsgAddress)
;; asset_type (uint8) - 0 for TON, 1 for Jetton
;; jetton_master (MsgAddress) - only if asset_type = 1
;; amount (Coins)
;; safety_deposit (Coins)
;; secret_hash (uint256)
;; timelock_duration (uint32)
;; finality_timelock (uint32)
;; created_at (uint32)
;; status (uint8)
;; merkle_root (uint256) - for partial fills
;; fill_percentage (uint32)

(slice, slice, slice, slice, slice, int, slice, int, int, int, int, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),      ;; escrow_id  
        ds~load_msg_addr(),      ;; maker_address
        ds~load_msg_addr(),      ;; resolver_address
        ds~load_msg_addr(),      ;; target_address
        ds~load_msg_addr(),      ;; refund_address
        ds~load_uint(8),         ;; asset_type
        ds~load_msg_addr(),      ;; jetton_master
        ds~load_coins(),         ;; amount
        ds~load_coins(),         ;; safety_deposit
        ds~load_uint(256),       ;; secret_hash
        ds~load_uint(32),        ;; timelock_duration
        ds~load_uint(32),        ;; finality_timelock
        ds~load_uint(32),        ;; created_at
        ds~load_uint(8),         ;; status
        ds~load_uint(256),       ;; merkle_root
        ds~load_uint(32)         ;; fill_percentage
    );
}

() save_data(slice escrow_id, slice maker_address, slice resolver_address, slice target_address, 
             slice refund_address, int asset_type, slice jetton_master, int amount, int safety_deposit,
             int secret_hash, int timelock_duration, int finality_timelock, int created_at, 
             int status, int merkle_root, int fill_percentage) impure inline {
    set_data(begin_cell()
        .store_slice(escrow_id)
        .store_slice(maker_address)
        .store_slice(resolver_address)
        .store_slice(target_address)
        .store_slice(refund_address)
        .store_uint(asset_type, 8)
        .store_slice(jetton_master)
        .store_coins(amount)
        .store_coins(safety_deposit)
        .store_uint(secret_hash, 256)
        .store_uint(timelock_duration, 32)
        .store_uint(finality_timelock, 32)
        .store_uint(created_at, 32)
        .store_uint(status, 8)
        .store_uint(merkle_root, 256)
        .store_uint(fill_percentage, 32)
        .end_cell());
}

;; Verify secret against hash (supports partial fills with Merkle proofs)
int verify_secret(int secret_hash, slice secret, slice merkle_proof, int fill_amount) inline {
    ;; For full fills, verify direct hash
    if (merkle_proof.slice_empty?()) {
        int computed_hash = string_hash(secret);
        return computed_hash == secret_hash;
    }
    
    ;; For partial fills, verify Merkle proof
    int leaf_hash = string_hash(secret);
    slice proof = merkle_proof;
    int current_hash = leaf_hash;
    
    while (~ proof.slice_empty?()) {
        int sibling = proof~load_uint(256);
        int is_right = proof~load_uint(1);
        
        if (is_right) {
            current_hash = string_hash(begin_cell()
                .store_uint(sibling, 256)
                .store_uint(current_hash, 256)
                .end_cell().begin_parse());
        } else {
            current_hash = string_hash(begin_cell()
                .store_uint(current_hash, 256)
                .store_uint(sibling, 256)
                .end_cell().begin_parse());
        }
    }
    
    return current_hash == secret_hash;
}

;; Create escrow with parameters from 1inch SDK
() create_escrow(int balance, slice sender_address, slice maker_address, slice resolver_address, 
                slice target_address, slice refund_address, int asset_type, slice jetton_master,
                int amount, int safety_deposit, int secret_hash, int timelock_duration, 
                int finality_timelock, int merkle_root) impure {
    
    throw_unless(ERROR_INSUFFICIENT_BALANCE, balance >= amount + safety_deposit);
    
    int now_time = now();
    slice escrow_id = begin_cell()
        .store_uint(now_time, 32)
        .store_slice(maker_address)
        .store_uint(secret_hash, 256)
        .end_cell().begin_parse();
    
    save_data(escrow_id, maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash, 
              timelock_duration, finality_timelock, now_time, STATUS_CREATED, merkle_root, 0);
    

}

;; Lock escrow after finality period
() lock_escrow(slice sender_address) impure {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(101, status == STATUS_CREATED);
    throw_unless(102, now() >= created_at + finality_timelock);
    
    save_data(escrow_id, maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash, 
              timelock_duration, finality_timelock, created_at, STATUS_LOCKED, merkle_root, fill_percentage);
              

}

;; Withdraw with secret (callable by resolver)
() withdraw_with_secret(slice sender_address, slice secret, slice merkle_proof, int withdraw_amount) impure {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(103, status == STATUS_LOCKED);
    throw_unless(ERROR_INVALID_SECRET, verify_secret(secret_hash, secret, merkle_proof, withdraw_amount));
    
    int new_fill_percentage = fill_percentage + withdraw_amount;
    throw_unless(104, new_fill_percentage <= amount);
    
    ;; Transfer assets to target address
    if (asset_type == 0) {
        ;; TON transfer
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(target_address)
            .store_coins(withdraw_amount)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Jetton transfer
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000) ;; 0.1 TON for gas
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64) ;; query_id
            .store_coins(withdraw_amount)
            .store_slice(target_address)
            .store_slice(target_address) ;; response_destination
            .store_uint(0, 1) ;; custom_payload
            .store_coins(50000000) ;; forward_ton_amount
            .store_uint(0, 1) ;; forward_payload
            .end_cell(), 1);
    }
    
    ;; Transfer safety deposit to resolver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(resolver_address)
        .store_coins(safety_deposit)
        .store_uint(0, 107)
        .end_cell(), 1);
    
    ;; Update status
    int new_status = (new_fill_percentage == amount) ? STATUS_WITHDRAWN : STATUS_LOCKED;
    save_data(escrow_id, maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash, 
              timelock_duration, finality_timelock, created_at, new_status, merkle_root, new_fill_percentage);
    

}

;; Refund after timeout (callable by maker or resolver)
() refund_escrow(slice sender_address) impure {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    throw_unless(105, equal_slices(sender_address, maker_address) | equal_slices(sender_address, resolver_address));
    throw_unless(106, (status == STATUS_LOCKED) | (status == STATUS_CREATED));
    throw_unless(ERROR_TIMEOUT_NOT_REACHED, now() >= created_at + timelock_duration);
    
    int remaining_amount = amount - fill_percentage;
    
    ;; Refund remaining assets to maker
    if (remaining_amount > 0) {
        if (asset_type == 0) {
            ;; TON refund
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(refund_address)
                .store_coins(remaining_amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton refund
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(remaining_amount)
                .store_slice(refund_address)
                .store_slice(refund_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
    }
    
    ;; Refund safety deposit to resolver if they initiated refund
    if (equal_slices(sender_address, resolver_address)) {
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(resolver_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    save_data(escrow_id, maker_address, resolver_address, target_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash, 
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED, merkle_root, fill_percentage);
    

}

;; Get escrow details (for 1inch SDK queries)
(int, slice, slice, slice, slice, int, int, int, int, int, int, int) get_escrow_details() method_id {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    return (status, maker_address, resolver_address, target_address, refund_address,
            asset_type, amount, safety_deposit, timelock_duration, created_at, 
            fill_percentage, (amount - fill_percentage));
}

;; Check if escrow can be withdrawn
int can_withdraw(slice secret, slice merkle_proof, int withdraw_amount) method_id {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    if (fill_percentage + withdraw_amount > amount) { return 0; }
    if (~ verify_secret(secret_hash, secret, merkle_proof, withdraw_amount)) { return 0; }
    
    return -1;
}

;; Check if escrow can be refunded
int can_refund() method_id {
    var (escrow_id, maker_address, resolver_address, target_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, merkle_root, fill_percentage) = load_data();
    
    if ((status != STATUS_LOCKED) & (status != STATUS_CREATED)) { return 0; }
    if (now() < created_at + timelock_duration) { return 0; }
    
    return -1;
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == OP_CREATE_ESCROW) {
        slice maker_address = in_msg_body~load_msg_addr();
        slice resolver_address = in_msg_body~load_msg_addr();
        slice target_address = in_msg_body~load_msg_addr();
        slice refund_address = in_msg_body~load_msg_addr();
        int asset_type = in_msg_body~load_uint(8);
        slice jetton_master = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        int safety_deposit = in_msg_body~load_coins();
        int secret_hash = in_msg_body~load_uint(256);
        int timelock_duration = in_msg_body~load_uint(32);
        int finality_timelock = in_msg_body~load_uint(32);
        int merkle_root = in_msg_body~load_uint(256);
        
        create_escrow(my_balance, sender_address, maker_address, resolver_address, target_address, 
                     refund_address, asset_type, jetton_master, amount, safety_deposit,
                     secret_hash, timelock_duration, finality_timelock, merkle_root);
        return ();
    }
    
    if (op == 0x2) { ;; lock_escrow
        lock_escrow(sender_address);
        return ();
    }
    
    if (op == OP_WITHDRAW) {
        slice secret = in_msg_body~load_ref().begin_parse();
        slice merkle_proof = in_msg_body~load_ref().begin_parse();
        int withdraw_amount = in_msg_body~load_coins();
        
        withdraw_with_secret(sender_address, secret, merkle_proof, withdraw_amount);
        return ();
    }
    
    if (op == OP_REFUND) {
        refund_escrow(sender_address);
        return ();
    }
    
    throw(0xffff);
} 