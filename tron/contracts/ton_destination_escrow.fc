;; TON Destination Escrow HTLC Contract for 1inch Fusion+ (Simplified)
;; This contract locks assets on the destination chain for maker withdrawal

#include "imports/stdlib.fc";
#include "imports/constants.fc";
#include "imports/jetton-utils.fc";

;; Operation codes
const int OP_CREATE_ESCROW = 0x1;
const int OP_WITHDRAW = 0x2;
const int OP_REFUND = 0x3;
const int OP_LOCK_ESCROW = 0x4;
const int OP_CANCEL_ESCROW = 0x5;
const int OP_JETTON_TRANSFER = 0x178d4519;
const int OP_JETTON_NOTIFICATION = 0x7362d09c;

;; Escrow statuses
const int STATUS_CREATED = 1;
const int STATUS_LOCKED = 2;
const int STATUS_WITHDRAWN = 3;
const int STATUS_REFUNDED = 4;

;; Simplified storage layout for destination escrow:
;; escrow_id (slice) - unique identifier
;; resolver_address (MsgAddress) - who deposits assets
;; maker_address (MsgAddress) - who can withdraw with secret
;; refund_address (MsgAddress) - where to refund resolver
;; asset_type (uint8) - 0 for TON, 1 for Jetton
;; jetton_master (MsgAddress) - only if asset_type = 1
;; amount (Coins)
;; safety_deposit (Coins)
;; secret_hash (uint256)
;; timelock_duration (uint32) - shorter than source chain
;; finality_timelock (uint32)
;; created_at (uint32)
;; status (uint8)
;; exclusive_period (uint32) - resolver exclusive withdrawal period

(slice, slice, slice, slice, int, slice, int, int, int, int, int, int, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    slice escrow_id = ds~load_ref().begin_parse();
    slice resolver_address = ds~load_msg_addr();
    slice maker_address = ds~load_msg_addr();
    slice refund_address = ds~load_msg_addr();
    int asset_type = ds~load_uint(8);
    slice jetton_master = ds~load_msg_addr();
    int amount = ds~load_coins();
    int safety_deposit = ds~load_coins();
    int secret_hash = ds~load_uint(256);
    int timelock_duration = ds~load_uint(32);
    int finality_timelock = ds~load_uint(32);
    int created_at = ds~load_uint(32);
    int status = ds~load_uint(8);
    int exclusive_period = ds~load_uint(32);
    
    return (escrow_id, resolver_address, maker_address, refund_address,
            asset_type, jetton_master, amount, safety_deposit, secret_hash,
            timelock_duration, finality_timelock, created_at, status, exclusive_period);
}

() save_data(slice escrow_id, slice resolver_address, slice maker_address, slice refund_address,
             int asset_type, slice jetton_master, int amount, int safety_deposit,
             int secret_hash, int timelock_duration, int finality_timelock, int created_at,
             int status, int exclusive_period) impure inline {
    
    cell escrow_id_cell = begin_cell().store_slice(escrow_id).end_cell();
    
    set_data(begin_cell()
        .store_ref(escrow_id_cell)
        .store_slice(resolver_address)
        .store_slice(maker_address)
        .store_slice(refund_address)
        .store_uint(asset_type, 8)
        .store_slice(jetton_master)
        .store_coins(amount)
        .store_coins(safety_deposit)
        .store_uint(secret_hash, 256)
        .store_uint(timelock_duration, 32)
        .store_uint(finality_timelock, 32)
        .store_uint(created_at, 32)
        .store_uint(status, 8)
        .store_uint(exclusive_period, 32)
        .end_cell());
}

;; Simple secret verification - full swap only
int verify_secret(int secret_hash, slice secret) inline {
    ;; Hash the provided secret and compare with stored hash
    int computed_hash = string_hash(secret);
    return computed_hash == secret_hash;
}

;; Create destination escrow (called by resolver with assets)
() create_escrow(int balance, slice resolver_address, slice maker_address,
                slice refund_address, int asset_type, slice jetton_master,
                int amount, int safety_deposit, int secret_hash, int timelock_duration,
                int finality_timelock, int exclusive_period) impure {
    
    throw_unless(ERROR_INSUFFICIENT_BALANCE, balance >= amount + safety_deposit);
    
    int now_time = now();
    slice escrow_id = begin_cell()
        .store_uint(now_time, 32)
        .store_slice(maker_address)
        .store_uint(secret_hash, 256)
        .end_cell().begin_parse();
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, now_time, STATUS_CREATED,
              exclusive_period);
}

;; Lock escrow after finality period (called by resolver)
() lock_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(101, status == STATUS_CREATED);
    throw_unless(102, now() >= created_at + finality_timelock);
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_LOCKED,
              exclusive_period);
}

;; Withdraw with secret (full amount only - resolver during exclusive period, then maker)
() withdraw_with_secret(slice sender_address, slice secret) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    throw_unless(103, status == STATUS_LOCKED);
    throw_unless(ERROR_INVALID_SECRET, verify_secret(secret_hash, secret));
    
    int now_time = now();
    int locked_at = created_at + finality_timelock;
    int exclusive_end = locked_at + exclusive_period;
    
    ;; During exclusive period, only resolver can withdraw
    if (now_time < exclusive_end) {
        throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
        
        ;; Resolver withdraws full amount to maker's address and gets safety deposit
        if (asset_type == 0) {
            ;; TON transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(maker_address)
                .store_coins(amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(amount)
                .store_slice(maker_address)
                .store_slice(maker_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
        
        ;; Transfer safety deposit to resolver
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(resolver_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
            
    } else {
        ;; After exclusive period, anyone with secret can withdraw to maker
        throw_unless(ERROR_INVALID_MAKER, 
            equal_slices(sender_address, maker_address) | 
            equal_slices(sender_address, resolver_address));
        
        if (asset_type == 0) {
            ;; TON transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x10, 6)
                .store_slice(maker_address)
                .store_coins(amount)
                .store_uint(0, 107)
                .end_cell(), 1);
        } else {
            ;; Jetton transfer to maker
            send_raw_message(begin_cell()
                .store_uint(0x18, 6)
                .store_slice(jetton_master)
                .store_coins(100000000)
                .store_uint(OP_JETTON_TRANSFER, 32)
                .store_uint(0, 64)
                .store_coins(amount)
                .store_slice(maker_address)
                .store_slice(maker_address)
                .store_uint(0, 1)
                .store_coins(50000000)
                .store_uint(0, 1)
                .end_cell(), 1);
        }
        
        ;; Safety deposit goes to whoever executed the withdrawal
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(sender_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    ;; Mark as withdrawn
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_WITHDRAWN,
              exclusive_period);
}

;; Refund to resolver after timeout (shorter timeout than source chain)
() refund_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    throw_unless(105, equal_slices(sender_address, resolver_address));
    throw_unless(106, (status == STATUS_LOCKED) | (status == STATUS_CREATED));
    throw_unless(ERROR_TIMEOUT_NOT_REACHED, now() >= created_at + timelock_duration);
    
    ;; Refund full amount to resolver
    if (asset_type == 0) {
        ;; TON refund
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(amount)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Jetton refund
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000)
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64)
            .store_coins(amount)
            .store_slice(refund_address)
            .store_slice(refund_address)
            .store_uint(0, 1)
            .store_coins(50000000)
            .store_uint(0, 1)
            .end_cell(), 1);
    }
    
    ;; Refund safety deposit to resolver
    send_raw_message(begin_cell()
        .store_uint(0x10, 6)
        .store_slice(resolver_address)
        .store_coins(safety_deposit)
        .store_uint(0, 107)
        .end_cell(), 1);
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED,
              exclusive_period);
}

;; Emergency cancellation by resolver (before locking)
() cancel_escrow(slice sender_address) impure {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    throw_unless(ERROR_INVALID_RESOLVER, equal_slices(sender_address, resolver_address));
    throw_unless(107, status == STATUS_CREATED);
    
    ;; Refund all assets to resolver immediately
    if (asset_type == 0) {
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(amount + safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    } else {
        ;; Return jettons and TON safety deposit separately
        send_raw_message(begin_cell()
            .store_uint(0x18, 6)
            .store_slice(jetton_master)
            .store_coins(100000000)
            .store_uint(OP_JETTON_TRANSFER, 32)
            .store_uint(0, 64)
            .store_coins(amount)
            .store_slice(refund_address)
            .store_slice(refund_address)
            .store_uint(0, 1)
            .store_coins(50000000)
            .store_uint(0, 1)
            .end_cell(), 1);
            
        send_raw_message(begin_cell()
            .store_uint(0x10, 6)
            .store_slice(refund_address)
            .store_coins(safety_deposit)
            .store_uint(0, 107)
            .end_cell(), 1);
    }
    
    save_data(escrow_id, resolver_address, maker_address, refund_address,
              asset_type, jetton_master, amount, safety_deposit, secret_hash,
              timelock_duration, finality_timelock, created_at, STATUS_REFUNDED,
              exclusive_period);
}

;; Get escrow details (for 1inch SDK queries)
(int, slice, slice, slice, slice, int, slice, int, int, int, int, int) get_escrow_details() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    return (status, escrow_id, resolver_address, maker_address, refund_address,
            asset_type, jetton_master, amount, safety_deposit, timelock_duration, 
            created_at, exclusive_period);
}

;; Check if escrow can be withdrawn with given secret
int can_withdraw(slice secret) method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    if (~ verify_secret(secret_hash, secret)) { return 0; }
    
    return -1;
}

;; Check if escrow can be refunded
int can_refund() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    if ((status != STATUS_LOCKED) & (status != STATUS_CREATED)) { return 0; }
    if (now() < created_at + timelock_duration) { return 0; }
    
    return -1;
}

;; Check if currently in exclusive period
int in_exclusive_period() method_id {
    var (escrow_id, resolver_address, maker_address, refund_address,
         asset_type, jetton_master, amount, safety_deposit, secret_hash, timelock_duration,
         finality_timelock, created_at, status, exclusive_period) = load_data();
    
    if (status != STATUS_LOCKED) { return 0; }
    
    int now_time = now();
    int locked_at = created_at + finality_timelock;
    int exclusive_end = locked_at + exclusive_period;
    
    return (now_time >= locked_at) & (now_time < exclusive_end);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { return (); }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    if (op == OP_CREATE_ESCROW) {
        slice resolver_address = in_msg_body~load_msg_addr();
        slice maker_address = in_msg_body~load_msg_addr();
        slice refund_address = in_msg_body~load_msg_addr();
        int asset_type = in_msg_body~load_uint(8);
        slice jetton_master = in_msg_body~load_msg_addr();
        int amount = in_msg_body~load_coins();
        int safety_deposit = in_msg_body~load_coins();
        int secret_hash = in_msg_body~load_uint(256);
        int timelock_duration = in_msg_body~load_uint(32);
        int finality_timelock = in_msg_body~load_uint(32);
        int exclusive_period = in_msg_body~load_uint(32);
        
        create_escrow(my_balance, resolver_address, maker_address, refund_address,
                     asset_type, jetton_master, amount, safety_deposit,
                     secret_hash, timelock_duration, finality_timelock, exclusive_period);
        return ();
    }
    
    if (op == OP_LOCK_ESCROW) {
        lock_escrow(sender_address);
        return ();
    }
    
    if (op == OP_WITHDRAW) {
        slice secret = in_msg_body~load_ref().begin_parse();
        withdraw_with_secret(sender_address, secret);
        return ();
    }
    
    if (op == OP_REFUND) {
        refund_escrow(sender_address);
        return ();
    }
    
    if (op == OP_CANCEL_ESCROW) {
        cancel_escrow(sender_address);
        return ();
    }
    
    throw(0xffff);
} 